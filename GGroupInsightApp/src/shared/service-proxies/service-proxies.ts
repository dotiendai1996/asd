/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailActivationLink(body: SendEmailActivationLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonate(body: ImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param query (optional) 
     * @return Success
     */
    executeRawQuery(query: string | undefined): Observable<QueryResult> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/ExecuteRawQuery?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecuteRawQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecuteRawQuery(<any>response_);
                } catch (e) {
                    return <Observable<QueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<QueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processExecuteRawQuery(response: HttpResponseBase): Observable<QueryResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QueryResult.fromJS(resultData200) : new QueryResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QueryResult>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, entityTypeFullName: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | undefined, entityId: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, entityTypeFullName: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' cannot be null.");
        else if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCacheDto.fromJS(resultData200) : new ListResultDtoOfCacheDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearCache(body: EntityDtoOfString | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommandDatasourcesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param commandFilter (optional) 
     * @param keyFilter (optional) 
     * @param valueFilter (optional) 
     * @param maxDynamicDatasourceIdFilter (optional) 
     * @param minDynamicDatasourceIdFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, commandFilter: string | undefined, keyFilter: string | undefined, valueFilter: string | undefined, maxDynamicDatasourceIdFilter: number | undefined, minDynamicDatasourceIdFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, isActiveFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetCommandDatasourceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CommandDatasources/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (commandFilter === null)
            throw new Error("The parameter 'commandFilter' cannot be null.");
        else if (commandFilter !== undefined)
            url_ += "CommandFilter=" + encodeURIComponent("" + commandFilter) + "&"; 
        if (keyFilter === null)
            throw new Error("The parameter 'keyFilter' cannot be null.");
        else if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (valueFilter === null)
            throw new Error("The parameter 'valueFilter' cannot be null.");
        else if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (maxDynamicDatasourceIdFilter === null)
            throw new Error("The parameter 'maxDynamicDatasourceIdFilter' cannot be null.");
        else if (maxDynamicDatasourceIdFilter !== undefined)
            url_ += "MaxDynamicDatasourceIdFilter=" + encodeURIComponent("" + maxDynamicDatasourceIdFilter) + "&"; 
        if (minDynamicDatasourceIdFilter === null)
            throw new Error("The parameter 'minDynamicDatasourceIdFilter' cannot be null.");
        else if (minDynamicDatasourceIdFilter !== undefined)
            url_ += "MinDynamicDatasourceIdFilter=" + encodeURIComponent("" + minDynamicDatasourceIdFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCommandDatasourceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCommandDatasourceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCommandDatasourceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetCommandDatasourceForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetCommandDatasourceForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCommandDatasourceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCommandDatasourceForView(id: number | undefined): Observable<GetCommandDatasourceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CommandDatasources/GetCommandDatasourceForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommandDatasourceForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommandDatasourceForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCommandDatasourceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCommandDatasourceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCommandDatasourceForView(response: HttpResponseBase): Observable<GetCommandDatasourceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCommandDatasourceForViewDto.fromJS(resultData200) : new GetCommandDatasourceForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCommandDatasourceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCommandDatasourceForEdit(id: number | undefined): Observable<GetCommandDatasourceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommandDatasources/GetCommandDatasourceForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommandDatasourceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommandDatasourceForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCommandDatasourceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCommandDatasourceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCommandDatasourceForEdit(response: HttpResponseBase): Observable<GetCommandDatasourceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCommandDatasourceForEditOutput.fromJS(resultData200) : new GetCommandDatasourceForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCommandDatasourceForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditCommandDatasourceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CommandDatasources/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CommandDatasources/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param commandFilter (optional) 
     * @param keyFilter (optional) 
     * @param valueFilter (optional) 
     * @param maxDynamicDatasourceIdFilter (optional) 
     * @param minDynamicDatasourceIdFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param isActiveFilter (optional) 
     * @return Success
     */
    getCommandDatasourcesToExcel(filter: string | undefined, commandFilter: string | undefined, keyFilter: string | undefined, valueFilter: string | undefined, maxDynamicDatasourceIdFilter: number | undefined, minDynamicDatasourceIdFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, isActiveFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/CommandDatasources/GetCommandDatasourcesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (commandFilter === null)
            throw new Error("The parameter 'commandFilter' cannot be null.");
        else if (commandFilter !== undefined)
            url_ += "CommandFilter=" + encodeURIComponent("" + commandFilter) + "&"; 
        if (keyFilter === null)
            throw new Error("The parameter 'keyFilter' cannot be null.");
        else if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (valueFilter === null)
            throw new Error("The parameter 'valueFilter' cannot be null.");
        else if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (maxDynamicDatasourceIdFilter === null)
            throw new Error("The parameter 'maxDynamicDatasourceIdFilter' cannot be null.");
        else if (maxDynamicDatasourceIdFilter !== undefined)
            url_ += "MaxDynamicDatasourceIdFilter=" + encodeURIComponent("" + maxDynamicDatasourceIdFilter) + "&"; 
        if (minDynamicDatasourceIdFilter === null)
            throw new Error("The parameter 'minDynamicDatasourceIdFilter' cannot be null.");
        else if (minDynamicDatasourceIdFilter !== undefined)
            url_ += "MinDynamicDatasourceIdFilter=" + encodeURIComponent("" + minDynamicDatasourceIdFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommandDatasourcesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommandDatasourcesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCommandDatasourcesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200) : new ListResultDtoOfSubscribableEditionComboboxItemDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class ConfigEmailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param diaChiEmailFilter (optional) 
     * @param tenHienThiFilter (optional) 
     * @param diaChiIPFilter (optional) 
     * @param maxCongSMTPFilter (optional) 
     * @param minCongSMTPFilter (optional) 
     * @param checkSSLFilter (optional) 
     * @param checkThongTinFilter (optional) 
     * @param tenMienFilter (optional) 
     * @param tenTruyCapFilter (optional) 
     * @param matKhauFilter (optional) 
     * @param tenCTYFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, diaChiEmailFilter: string | undefined, tenHienThiFilter: string | undefined, diaChiIPFilter: string | undefined, maxCongSMTPFilter: number | undefined, minCongSMTPFilter: number | undefined, checkSSLFilter: number | undefined, checkThongTinFilter: number | undefined, tenMienFilter: string | undefined, tenTruyCapFilter: string | undefined, matKhauFilter: string | undefined, tenCTYFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetConfigEmailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ConfigEmails/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (diaChiEmailFilter === null)
            throw new Error("The parameter 'diaChiEmailFilter' cannot be null.");
        else if (diaChiEmailFilter !== undefined)
            url_ += "DiaChiEmailFilter=" + encodeURIComponent("" + diaChiEmailFilter) + "&"; 
        if (tenHienThiFilter === null)
            throw new Error("The parameter 'tenHienThiFilter' cannot be null.");
        else if (tenHienThiFilter !== undefined)
            url_ += "TenHienThiFilter=" + encodeURIComponent("" + tenHienThiFilter) + "&"; 
        if (diaChiIPFilter === null)
            throw new Error("The parameter 'diaChiIPFilter' cannot be null.");
        else if (diaChiIPFilter !== undefined)
            url_ += "DiaChiIPFilter=" + encodeURIComponent("" + diaChiIPFilter) + "&"; 
        if (maxCongSMTPFilter === null)
            throw new Error("The parameter 'maxCongSMTPFilter' cannot be null.");
        else if (maxCongSMTPFilter !== undefined)
            url_ += "MaxCongSMTPFilter=" + encodeURIComponent("" + maxCongSMTPFilter) + "&"; 
        if (minCongSMTPFilter === null)
            throw new Error("The parameter 'minCongSMTPFilter' cannot be null.");
        else if (minCongSMTPFilter !== undefined)
            url_ += "MinCongSMTPFilter=" + encodeURIComponent("" + minCongSMTPFilter) + "&"; 
        if (checkSSLFilter === null)
            throw new Error("The parameter 'checkSSLFilter' cannot be null.");
        else if (checkSSLFilter !== undefined)
            url_ += "CheckSSLFilter=" + encodeURIComponent("" + checkSSLFilter) + "&"; 
        if (checkThongTinFilter === null)
            throw new Error("The parameter 'checkThongTinFilter' cannot be null.");
        else if (checkThongTinFilter !== undefined)
            url_ += "CheckThongTinFilter=" + encodeURIComponent("" + checkThongTinFilter) + "&"; 
        if (tenMienFilter === null)
            throw new Error("The parameter 'tenMienFilter' cannot be null.");
        else if (tenMienFilter !== undefined)
            url_ += "TenMienFilter=" + encodeURIComponent("" + tenMienFilter) + "&"; 
        if (tenTruyCapFilter === null)
            throw new Error("The parameter 'tenTruyCapFilter' cannot be null.");
        else if (tenTruyCapFilter !== undefined)
            url_ += "TenTruyCapFilter=" + encodeURIComponent("" + tenTruyCapFilter) + "&"; 
        if (matKhauFilter === null)
            throw new Error("The parameter 'matKhauFilter' cannot be null.");
        else if (matKhauFilter !== undefined)
            url_ += "MatKhauFilter=" + encodeURIComponent("" + matKhauFilter) + "&"; 
        if (tenCTYFilter === null)
            throw new Error("The parameter 'tenCTYFilter' cannot be null.");
        else if (tenCTYFilter !== undefined)
            url_ += "TenCTYFilter=" + encodeURIComponent("" + tenCTYFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetConfigEmailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetConfigEmailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetConfigEmailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetConfigEmailForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetConfigEmailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetConfigEmailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getConfigEmailForView(id: number | undefined): Observable<GetConfigEmailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ConfigEmails/GetConfigEmailForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigEmailForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigEmailForView(<any>response_);
                } catch (e) {
                    return <Observable<GetConfigEmailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetConfigEmailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigEmailForView(response: HttpResponseBase): Observable<GetConfigEmailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetConfigEmailForViewDto.fromJS(resultData200) : new GetConfigEmailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetConfigEmailForViewDto>(<any>null);
    }

    /**
     * @param tenCongty (optional) 
     * @return Success
     */
    getConfigEmailByTenCtyForView(tenCongty: string | undefined): Observable<GetConfigEmailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ConfigEmails/GetConfigEmailByTenCtyForView?";
        if (tenCongty === null)
            throw new Error("The parameter 'tenCongty' cannot be null.");
        else if (tenCongty !== undefined)
            url_ += "tenCongty=" + encodeURIComponent("" + tenCongty) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigEmailByTenCtyForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigEmailByTenCtyForView(<any>response_);
                } catch (e) {
                    return <Observable<GetConfigEmailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetConfigEmailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigEmailByTenCtyForView(response: HttpResponseBase): Observable<GetConfigEmailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetConfigEmailForViewDto.fromJS(resultData200) : new GetConfigEmailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetConfigEmailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getConfigEmailForEdit(id: number | undefined): Observable<GetConfigEmailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ConfigEmails/GetConfigEmailForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigEmailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigEmailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetConfigEmailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetConfigEmailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigEmailForEdit(response: HttpResponseBase): Observable<GetConfigEmailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetConfigEmailForEditOutput.fromJS(resultData200) : new GetConfigEmailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetConfigEmailForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditConfigEmailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ConfigEmails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ConfigEmails/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param diaChiEmailFilter (optional) 
     * @param tenHienThiFilter (optional) 
     * @param diaChiIPFilter (optional) 
     * @param maxCongSMTPFilter (optional) 
     * @param minCongSMTPFilter (optional) 
     * @param checkSSLFilter (optional) 
     * @param checkThongTinFilter (optional) 
     * @param tenMienFilter (optional) 
     * @param tenTruyCapFilter (optional) 
     * @param matKhauFilter (optional) 
     * @param tenCTYFilter (optional) 
     * @return Success
     */
    getConfigEmailsToExcel(filter: string | undefined, diaChiEmailFilter: string | undefined, tenHienThiFilter: string | undefined, diaChiIPFilter: string | undefined, maxCongSMTPFilter: number | undefined, minCongSMTPFilter: number | undefined, checkSSLFilter: number | undefined, checkThongTinFilter: number | undefined, tenMienFilter: string | undefined, tenTruyCapFilter: string | undefined, matKhauFilter: string | undefined, tenCTYFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ConfigEmails/GetConfigEmailsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (diaChiEmailFilter === null)
            throw new Error("The parameter 'diaChiEmailFilter' cannot be null.");
        else if (diaChiEmailFilter !== undefined)
            url_ += "DiaChiEmailFilter=" + encodeURIComponent("" + diaChiEmailFilter) + "&"; 
        if (tenHienThiFilter === null)
            throw new Error("The parameter 'tenHienThiFilter' cannot be null.");
        else if (tenHienThiFilter !== undefined)
            url_ += "TenHienThiFilter=" + encodeURIComponent("" + tenHienThiFilter) + "&"; 
        if (diaChiIPFilter === null)
            throw new Error("The parameter 'diaChiIPFilter' cannot be null.");
        else if (diaChiIPFilter !== undefined)
            url_ += "DiaChiIPFilter=" + encodeURIComponent("" + diaChiIPFilter) + "&"; 
        if (maxCongSMTPFilter === null)
            throw new Error("The parameter 'maxCongSMTPFilter' cannot be null.");
        else if (maxCongSMTPFilter !== undefined)
            url_ += "MaxCongSMTPFilter=" + encodeURIComponent("" + maxCongSMTPFilter) + "&"; 
        if (minCongSMTPFilter === null)
            throw new Error("The parameter 'minCongSMTPFilter' cannot be null.");
        else if (minCongSMTPFilter !== undefined)
            url_ += "MinCongSMTPFilter=" + encodeURIComponent("" + minCongSMTPFilter) + "&"; 
        if (checkSSLFilter === null)
            throw new Error("The parameter 'checkSSLFilter' cannot be null.");
        else if (checkSSLFilter !== undefined)
            url_ += "CheckSSLFilter=" + encodeURIComponent("" + checkSSLFilter) + "&"; 
        if (checkThongTinFilter === null)
            throw new Error("The parameter 'checkThongTinFilter' cannot be null.");
        else if (checkThongTinFilter !== undefined)
            url_ += "CheckThongTinFilter=" + encodeURIComponent("" + checkThongTinFilter) + "&"; 
        if (tenMienFilter === null)
            throw new Error("The parameter 'tenMienFilter' cannot be null.");
        else if (tenMienFilter !== undefined)
            url_ += "TenMienFilter=" + encodeURIComponent("" + tenMienFilter) + "&"; 
        if (tenTruyCapFilter === null)
            throw new Error("The parameter 'tenTruyCapFilter' cannot be null.");
        else if (tenTruyCapFilter !== undefined)
            url_ += "TenTruyCapFilter=" + encodeURIComponent("" + tenTruyCapFilter) + "&"; 
        if (matKhauFilter === null)
            throw new Error("The parameter 'matKhauFilter' cannot be null.");
        else if (matKhauFilter !== undefined)
            url_ += "MatKhauFilter=" + encodeURIComponent("" + matKhauFilter) + "&"; 
        if (tenCTYFilter === null)
            throw new Error("The parameter 'tenCTYFilter' cannot be null.");
        else if (tenCTYFilter !== undefined)
            url_ += "TenCTYFilter=" + encodeURIComponent("" + tenCTYFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigEmailsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigEmailsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigEmailsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserChatFriendsWithSettingsOutput.fromJS(resultData200) : new GetUserChatFriendsWithSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | undefined, userId: number | undefined, minMessageId: number | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId === null)
            throw new Error("The parameter 'minMessageId' cannot be null.");
        else if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfChatMessageDto.fromJS(resultData200) : new ListResultDtoOfChatMessageDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(body: MarkAllUnreadMessagesOfUserAsReadInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DangKyKCBsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param tenNoiKCBFilter (optional) 
     * @param maNoiKCBFilter (optional) 
     * @param diaChiFilter (optional) 
     * @param maxTinhThanhIDFilter (optional) 
     * @param minTinhThanhIDFilter (optional) 
     * @param ghiChuFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, tenNoiKCBFilter: string | undefined, maNoiKCBFilter: string | undefined, diaChiFilter: string | undefined, maxTinhThanhIDFilter: number | undefined, minTinhThanhIDFilter: number | undefined, ghiChuFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDangKyKCBForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DangKyKCBs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenNoiKCBFilter === null)
            throw new Error("The parameter 'tenNoiKCBFilter' cannot be null.");
        else if (tenNoiKCBFilter !== undefined)
            url_ += "TenNoiKCBFilter=" + encodeURIComponent("" + tenNoiKCBFilter) + "&"; 
        if (maNoiKCBFilter === null)
            throw new Error("The parameter 'maNoiKCBFilter' cannot be null.");
        else if (maNoiKCBFilter !== undefined)
            url_ += "MaNoiKCBFilter=" + encodeURIComponent("" + maNoiKCBFilter) + "&"; 
        if (diaChiFilter === null)
            throw new Error("The parameter 'diaChiFilter' cannot be null.");
        else if (diaChiFilter !== undefined)
            url_ += "DiaChiFilter=" + encodeURIComponent("" + diaChiFilter) + "&"; 
        if (maxTinhThanhIDFilter === null)
            throw new Error("The parameter 'maxTinhThanhIDFilter' cannot be null.");
        else if (maxTinhThanhIDFilter !== undefined)
            url_ += "MaxTinhThanhIDFilter=" + encodeURIComponent("" + maxTinhThanhIDFilter) + "&"; 
        if (minTinhThanhIDFilter === null)
            throw new Error("The parameter 'minTinhThanhIDFilter' cannot be null.");
        else if (minTinhThanhIDFilter !== undefined)
            url_ += "MinTinhThanhIDFilter=" + encodeURIComponent("" + minTinhThanhIDFilter) + "&"; 
        if (ghiChuFilter === null)
            throw new Error("The parameter 'ghiChuFilter' cannot be null.");
        else if (ghiChuFilter !== undefined)
            url_ += "GhiChuFilter=" + encodeURIComponent("" + ghiChuFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDangKyKCBForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDangKyKCBForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDangKyKCBForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetDangKyKCBForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetDangKyKCBForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDangKyKCBForViewDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllNoiDangKy(): Observable<DangKyKCBDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DangKyKCBs/GetAllNoiDangKy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNoiDangKy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNoiDangKy(<any>response_);
                } catch (e) {
                    return <Observable<DangKyKCBDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DangKyKCBDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNoiDangKy(response: HttpResponseBase): Observable<DangKyKCBDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DangKyKCBDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DangKyKCBDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDangKyKCBForView(id: number | undefined): Observable<GetDangKyKCBForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DangKyKCBs/GetDangKyKCBForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDangKyKCBForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDangKyKCBForView(<any>response_);
                } catch (e) {
                    return <Observable<GetDangKyKCBForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDangKyKCBForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDangKyKCBForView(response: HttpResponseBase): Observable<GetDangKyKCBForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDangKyKCBForViewDto.fromJS(resultData200) : new GetDangKyKCBForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDangKyKCBForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDangKyKCBForEdit(id: number | undefined): Observable<GetDangKyKCBForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DangKyKCBs/GetDangKyKCBForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDangKyKCBForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDangKyKCBForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDangKyKCBForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDangKyKCBForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDangKyKCBForEdit(response: HttpResponseBase): Observable<GetDangKyKCBForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDangKyKCBForEditOutput.fromJS(resultData200) : new GetDangKyKCBForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDangKyKCBForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDangKyKCBDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DangKyKCBs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DangKyKCBs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenNoiKCBFilter (optional) 
     * @param maNoiKCBFilter (optional) 
     * @param diaChiFilter (optional) 
     * @param maxTinhThanhIDFilter (optional) 
     * @param minTinhThanhIDFilter (optional) 
     * @param ghiChuFilter (optional) 
     * @return Success
     */
    getDangKyKCBsToExcel(filter: string | undefined, tenNoiKCBFilter: string | undefined, maNoiKCBFilter: string | undefined, diaChiFilter: string | undefined, maxTinhThanhIDFilter: number | undefined, minTinhThanhIDFilter: number | undefined, ghiChuFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DangKyKCBs/GetDangKyKCBsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenNoiKCBFilter === null)
            throw new Error("The parameter 'tenNoiKCBFilter' cannot be null.");
        else if (tenNoiKCBFilter !== undefined)
            url_ += "TenNoiKCBFilter=" + encodeURIComponent("" + tenNoiKCBFilter) + "&"; 
        if (maNoiKCBFilter === null)
            throw new Error("The parameter 'maNoiKCBFilter' cannot be null.");
        else if (maNoiKCBFilter !== undefined)
            url_ += "MaNoiKCBFilter=" + encodeURIComponent("" + maNoiKCBFilter) + "&"; 
        if (diaChiFilter === null)
            throw new Error("The parameter 'diaChiFilter' cannot be null.");
        else if (diaChiFilter !== undefined)
            url_ += "DiaChiFilter=" + encodeURIComponent("" + diaChiFilter) + "&"; 
        if (maxTinhThanhIDFilter === null)
            throw new Error("The parameter 'maxTinhThanhIDFilter' cannot be null.");
        else if (maxTinhThanhIDFilter !== undefined)
            url_ += "MaxTinhThanhIDFilter=" + encodeURIComponent("" + maxTinhThanhIDFilter) + "&"; 
        if (minTinhThanhIDFilter === null)
            throw new Error("The parameter 'minTinhThanhIDFilter' cannot be null.");
        else if (minTinhThanhIDFilter !== undefined)
            url_ += "MinTinhThanhIDFilter=" + encodeURIComponent("" + minTinhThanhIDFilter) + "&"; 
        if (ghiChuFilter === null)
            throw new Error("The parameter 'ghiChuFilter' cannot be null.");
        else if (ghiChuFilter !== undefined)
            url_ += "GhiChuFilter=" + encodeURIComponent("" + ghiChuFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDangKyKCBsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDangKyKCBsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDangKyKCBsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class DashboardCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getUserDashboard(dashboardName: string | undefined, application: string | undefined): Observable<Dashboard> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetUserDashboard?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&"; 
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDashboard(<any>response_);
                } catch (e) {
                    return <Observable<Dashboard>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dashboard>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDashboard(response: HttpResponseBase): Observable<Dashboard> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dashboard.fromJS(resultData200) : new Dashboard();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dashboard>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePage(body: SavePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/SavePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSavePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renamePage(body: RenamePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/RenamePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenamePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenamePage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRenamePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewPage(body: AddNewPageInput | undefined): Observable<AddNewPageOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddNewPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewPage(<any>response_);
                } catch (e) {
                    return <Observable<AddNewPageOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddNewPageOutput>><any>_observableThrow(response_);
        }));
    }

    protected processAddNewPage(response: HttpResponseBase): Observable<AddNewPageOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AddNewPageOutput.fromJS(resultData200) : new AddNewPageOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddNewPageOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    deletePage(id: string | undefined, dashboardName: string | undefined, application: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/DeletePage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&"; 
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addWidget(body: AddWidgetInput | undefined): Observable<Widget> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddWidget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWidget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWidget(<any>response_);
                } catch (e) {
                    return <Observable<Widget>><any>_observableThrow(e);
                }
            } else
                return <Observable<Widget>><any>_observableThrow(response_);
        }));
    }

    protected processAddWidget(response: HttpResponseBase): Observable<Widget> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Widget.fromJS(resultData200) : new Widget();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Widget>(<any>null);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getDashboardDefinition(dashboardName: string | undefined, application: string | undefined): Observable<DashboardOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetDashboardDefinition?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&"; 
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardDefinition(<any>response_);
                } catch (e) {
                    return <Observable<DashboardOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardDefinition(response: HttpResponseBase): Observable<DashboardOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DashboardOutput.fromJS(resultData200) : new DashboardOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardOutput>(<any>null);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getAllWidgetDefinitions(dashboardName: string | undefined, application: string | undefined): Observable<WidgetOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetAllWidgetDefinitions?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&"; 
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWidgetDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWidgetDefinitions(<any>response_);
                } catch (e) {
                    return <Observable<WidgetOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWidgetDefinitions(response: HttpResponseBase): Observable<WidgetOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WidgetOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetOutput[]>(<any>null);
    }

    /**
     * @param application (optional) 
     * @return Success
     */
    getSettingName(application: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetSettingName?";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "application=" + encodeURIComponent("" + application) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingName(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettingName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class DataChamCongsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param minProcessDate (optional) 
     * @param maxProcessDate (optional) 
     * @param tenCTy (optional) 
     * @param phongBan (optional) 
     * @param chucDanh (optional) 
     * @param diTre (optional) 
     * @param veSom (optional) 
     * @param tangCa (optional) 
     * @param nghiPhep (optional) 
     * @param congTac (optional) 
     * @param quenChamCong (optional) 
     * @param isExportExcel (optional) 
     * @param totalCount (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, minProcessDate: moment.Moment | undefined, maxProcessDate: moment.Moment | undefined, tenCTy: string | undefined, phongBan: string | undefined, chucDanh: string | undefined, diTre: boolean | undefined, veSom: boolean | undefined, tangCa: boolean | undefined, nghiPhep: boolean | undefined, congTac: boolean | undefined, quenChamCong: boolean | undefined, isExportExcel: boolean | undefined, totalCount: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDataChamCongForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DataChamCongs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (minProcessDate === null)
            throw new Error("The parameter 'minProcessDate' cannot be null.");
        else if (minProcessDate !== undefined)
            url_ += "MinProcessDate=" + encodeURIComponent(minProcessDate ? "" + minProcessDate.toJSON() : "") + "&"; 
        if (maxProcessDate === null)
            throw new Error("The parameter 'maxProcessDate' cannot be null.");
        else if (maxProcessDate !== undefined)
            url_ += "MaxProcessDate=" + encodeURIComponent(maxProcessDate ? "" + maxProcessDate.toJSON() : "") + "&"; 
        if (tenCTy === null)
            throw new Error("The parameter 'tenCTy' cannot be null.");
        else if (tenCTy !== undefined)
            url_ += "TenCTy=" + encodeURIComponent("" + tenCTy) + "&"; 
        if (phongBan === null)
            throw new Error("The parameter 'phongBan' cannot be null.");
        else if (phongBan !== undefined)
            url_ += "PhongBan=" + encodeURIComponent("" + phongBan) + "&"; 
        if (chucDanh === null)
            throw new Error("The parameter 'chucDanh' cannot be null.");
        else if (chucDanh !== undefined)
            url_ += "ChucDanh=" + encodeURIComponent("" + chucDanh) + "&"; 
        if (diTre === null)
            throw new Error("The parameter 'diTre' cannot be null.");
        else if (diTre !== undefined)
            url_ += "DiTre=" + encodeURIComponent("" + diTre) + "&"; 
        if (veSom === null)
            throw new Error("The parameter 'veSom' cannot be null.");
        else if (veSom !== undefined)
            url_ += "VeSom=" + encodeURIComponent("" + veSom) + "&"; 
        if (tangCa === null)
            throw new Error("The parameter 'tangCa' cannot be null.");
        else if (tangCa !== undefined)
            url_ += "TangCa=" + encodeURIComponent("" + tangCa) + "&"; 
        if (nghiPhep === null)
            throw new Error("The parameter 'nghiPhep' cannot be null.");
        else if (nghiPhep !== undefined)
            url_ += "NghiPhep=" + encodeURIComponent("" + nghiPhep) + "&"; 
        if (congTac === null)
            throw new Error("The parameter 'congTac' cannot be null.");
        else if (congTac !== undefined)
            url_ += "CongTac=" + encodeURIComponent("" + congTac) + "&"; 
        if (quenChamCong === null)
            throw new Error("The parameter 'quenChamCong' cannot be null.");
        else if (quenChamCong !== undefined)
            url_ += "QuenChamCong=" + encodeURIComponent("" + quenChamCong) + "&"; 
        if (isExportExcel === null)
            throw new Error("The parameter 'isExportExcel' cannot be null.");
        else if (isExportExcel !== undefined)
            url_ += "IsExportExcel=" + encodeURIComponent("" + isExportExcel) + "&"; 
        if (totalCount === null)
            throw new Error("The parameter 'totalCount' cannot be null.");
        else if (totalCount !== undefined)
            url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDataChamCongForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDataChamCongForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDataChamCongForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetDataChamCongForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetDataChamCongForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDataChamCongForViewDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDataChamCongFilter(): Observable<DataChamCongFilter> {
        let url_ = this.baseUrl + "/api/services/app/DataChamCongs/GetDataChamCongFilter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataChamCongFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataChamCongFilter(<any>response_);
                } catch (e) {
                    return <Observable<DataChamCongFilter>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataChamCongFilter>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataChamCongFilter(response: HttpResponseBase): Observable<DataChamCongFilter> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataChamCongFilter.fromJS(resultData200) : new DataChamCongFilter();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataChamCongFilter>(<any>null);
    }

    /**
     * @param tenCty (optional) 
     * @return Success
     */
    getCongViecByTenCty(tenCty: string | undefined): Observable<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DataChamCongs/GetCongViecByTenCty?";
        if (tenCty === null)
            throw new Error("The parameter 'tenCty' cannot be null.");
        else if (tenCty !== undefined)
            url_ += "tenCty=" + encodeURIComponent("" + tenCty) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCongViecByTenCty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCongViecByTenCty(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCongViecByTenCty(response: HttpResponseBase): Observable<OrganizationUnitDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationUnitDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getProcessDateMax(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DataChamCongs/GetProcessDateMax";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessDateMax(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessDateMax(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessDateMax(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDataChamCongForView(id: number | undefined): Observable<GetDataChamCongForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DataChamCongs/GetDataChamCongForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataChamCongForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataChamCongForView(<any>response_);
                } catch (e) {
                    return <Observable<GetDataChamCongForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDataChamCongForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataChamCongForView(response: HttpResponseBase): Observable<GetDataChamCongForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDataChamCongForViewDto.fromJS(resultData200) : new GetDataChamCongForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDataChamCongForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDataChamCongForEdit(id: number | undefined): Observable<GetDataChamCongForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DataChamCongs/GetDataChamCongForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataChamCongForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataChamCongForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDataChamCongForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDataChamCongForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataChamCongForEdit(response: HttpResponseBase): Observable<GetDataChamCongForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDataChamCongForEditOutput.fromJS(resultData200) : new GetDataChamCongForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDataChamCongForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDataChamCongDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DataChamCongs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DataChamCongs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param processDate (optional) 
     * @return Success
     */
    getDataChamCongsToExcel(processDate: moment.Moment | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DataChamCongs/GetDataChamCongsToExcel?";
        if (processDate === null)
            throw new Error("The parameter 'processDate' cannot be null.");
        else if (processDate !== undefined)
            url_ += "ProcessDate=" + encodeURIComponent(processDate ? "" + processDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataChamCongsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataChamCongsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataChamCongsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param minProcessDate (optional) 
     * @param maxProcessDate (optional) 
     * @param tenCTy (optional) 
     * @param phongBan (optional) 
     * @param chucDanh (optional) 
     * @param diTre (optional) 
     * @param veSom (optional) 
     * @param tangCa (optional) 
     * @param nghiPhep (optional) 
     * @param congTac (optional) 
     * @param quenChamCong (optional) 
     * @param isExportExcel (optional) 
     * @param totalCount (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDataChamCongsFilterToExcel(filter: string | undefined, minProcessDate: moment.Moment | undefined, maxProcessDate: moment.Moment | undefined, tenCTy: string | undefined, phongBan: string | undefined, chucDanh: string | undefined, diTre: boolean | undefined, veSom: boolean | undefined, tangCa: boolean | undefined, nghiPhep: boolean | undefined, congTac: boolean | undefined, quenChamCong: boolean | undefined, isExportExcel: boolean | undefined, totalCount: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DataChamCongs/GetDataChamCongsFilterToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (minProcessDate === null)
            throw new Error("The parameter 'minProcessDate' cannot be null.");
        else if (minProcessDate !== undefined)
            url_ += "MinProcessDate=" + encodeURIComponent(minProcessDate ? "" + minProcessDate.toJSON() : "") + "&"; 
        if (maxProcessDate === null)
            throw new Error("The parameter 'maxProcessDate' cannot be null.");
        else if (maxProcessDate !== undefined)
            url_ += "MaxProcessDate=" + encodeURIComponent(maxProcessDate ? "" + maxProcessDate.toJSON() : "") + "&"; 
        if (tenCTy === null)
            throw new Error("The parameter 'tenCTy' cannot be null.");
        else if (tenCTy !== undefined)
            url_ += "TenCTy=" + encodeURIComponent("" + tenCTy) + "&"; 
        if (phongBan === null)
            throw new Error("The parameter 'phongBan' cannot be null.");
        else if (phongBan !== undefined)
            url_ += "PhongBan=" + encodeURIComponent("" + phongBan) + "&"; 
        if (chucDanh === null)
            throw new Error("The parameter 'chucDanh' cannot be null.");
        else if (chucDanh !== undefined)
            url_ += "ChucDanh=" + encodeURIComponent("" + chucDanh) + "&"; 
        if (diTre === null)
            throw new Error("The parameter 'diTre' cannot be null.");
        else if (diTre !== undefined)
            url_ += "DiTre=" + encodeURIComponent("" + diTre) + "&"; 
        if (veSom === null)
            throw new Error("The parameter 'veSom' cannot be null.");
        else if (veSom !== undefined)
            url_ += "VeSom=" + encodeURIComponent("" + veSom) + "&"; 
        if (tangCa === null)
            throw new Error("The parameter 'tangCa' cannot be null.");
        else if (tangCa !== undefined)
            url_ += "TangCa=" + encodeURIComponent("" + tangCa) + "&"; 
        if (nghiPhep === null)
            throw new Error("The parameter 'nghiPhep' cannot be null.");
        else if (nghiPhep !== undefined)
            url_ += "NghiPhep=" + encodeURIComponent("" + nghiPhep) + "&"; 
        if (congTac === null)
            throw new Error("The parameter 'congTac' cannot be null.");
        else if (congTac !== undefined)
            url_ += "CongTac=" + encodeURIComponent("" + congTac) + "&"; 
        if (quenChamCong === null)
            throw new Error("The parameter 'quenChamCong' cannot be null.");
        else if (quenChamCong !== undefined)
            url_ += "QuenChamCong=" + encodeURIComponent("" + quenChamCong) + "&"; 
        if (isExportExcel === null)
            throw new Error("The parameter 'isExportExcel' cannot be null.");
        else if (isExportExcel !== undefined)
            url_ += "IsExportExcel=" + encodeURIComponent("" + isExportExcel) + "&"; 
        if (totalCount === null)
            throw new Error("The parameter 'totalCount' cannot be null.");
        else if (totalCount !== undefined)
            url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataChamCongsFilterToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataChamCongsFilterToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataChamCongsFilterToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: moment.Moment | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: moment.Moment | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(body: NameValueOfString[] | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringOutput.fromJS(resultData200) : new StringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(<any>null);
    }
}

@Injectable()
export class DocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param numberFilter (optional) 
     * @param maxIncommingNumberFilter (optional) 
     * @param minIncommingNumberFilter (optional) 
     * @param maxPagesFilter (optional) 
     * @param minPagesFilter (optional) 
     * @param maxDocumentTypeIdFilter (optional) 
     * @param minDocumentTypeIdFilter (optional) 
     * @param dateIssueFilter (optional) 
     * @param placeRecevieFilter (optional) 
     * @param saveToFilter (optional) 
     * @param summaryFilter (optional) 
     * @param approvedByFilter (optional) 
     * @param attachmentFilter (optional) 
     * @param typeReceiveFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param statusFilter (optional) 
     * @param noteFilter (optional) 
     * @param priorityFilter (optional) 
     * @param incommingDateFilter (optional) 
     * @param rangeFilter (optional) 
     * @param positionFilter (optional) 
     * @param linkedDocumentFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, numberFilter: string | undefined, maxIncommingNumberFilter: number | undefined, minIncommingNumberFilter: number | undefined, maxPagesFilter: number | undefined, minPagesFilter: number | undefined, maxDocumentTypeIdFilter: number | undefined, minDocumentTypeIdFilter: number | undefined, dateIssueFilter: string | undefined, placeRecevieFilter: string | undefined, saveToFilter: string | undefined, summaryFilter: string | undefined, approvedByFilter: string | undefined, attachmentFilter: string | undefined, typeReceiveFilter: string | undefined, maxStartDateFilter: moment.Moment | undefined, minStartDateFilter: moment.Moment | undefined, maxEndDateFilter: moment.Moment | undefined, minEndDateFilter: moment.Moment | undefined, statusFilter: string | undefined, noteFilter: string | undefined, priorityFilter: number | undefined, incommingDateFilter: moment.Moment | undefined, rangeFilter: string | undefined, positionFilter: string | undefined, linkedDocumentFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDocumentsForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (numberFilter === null)
            throw new Error("The parameter 'numberFilter' cannot be null.");
        else if (numberFilter !== undefined)
            url_ += "NumberFilter=" + encodeURIComponent("" + numberFilter) + "&"; 
        if (maxIncommingNumberFilter === null)
            throw new Error("The parameter 'maxIncommingNumberFilter' cannot be null.");
        else if (maxIncommingNumberFilter !== undefined)
            url_ += "MaxIncommingNumberFilter=" + encodeURIComponent("" + maxIncommingNumberFilter) + "&"; 
        if (minIncommingNumberFilter === null)
            throw new Error("The parameter 'minIncommingNumberFilter' cannot be null.");
        else if (minIncommingNumberFilter !== undefined)
            url_ += "MinIncommingNumberFilter=" + encodeURIComponent("" + minIncommingNumberFilter) + "&"; 
        if (maxPagesFilter === null)
            throw new Error("The parameter 'maxPagesFilter' cannot be null.");
        else if (maxPagesFilter !== undefined)
            url_ += "MaxPagesFilter=" + encodeURIComponent("" + maxPagesFilter) + "&"; 
        if (minPagesFilter === null)
            throw new Error("The parameter 'minPagesFilter' cannot be null.");
        else if (minPagesFilter !== undefined)
            url_ += "MinPagesFilter=" + encodeURIComponent("" + minPagesFilter) + "&"; 
        if (maxDocumentTypeIdFilter === null)
            throw new Error("The parameter 'maxDocumentTypeIdFilter' cannot be null.");
        else if (maxDocumentTypeIdFilter !== undefined)
            url_ += "MaxDocumentTypeIdFilter=" + encodeURIComponent("" + maxDocumentTypeIdFilter) + "&"; 
        if (minDocumentTypeIdFilter === null)
            throw new Error("The parameter 'minDocumentTypeIdFilter' cannot be null.");
        else if (minDocumentTypeIdFilter !== undefined)
            url_ += "MinDocumentTypeIdFilter=" + encodeURIComponent("" + minDocumentTypeIdFilter) + "&"; 
        if (dateIssueFilter === null)
            throw new Error("The parameter 'dateIssueFilter' cannot be null.");
        else if (dateIssueFilter !== undefined)
            url_ += "DateIssueFilter=" + encodeURIComponent("" + dateIssueFilter) + "&"; 
        if (placeRecevieFilter === null)
            throw new Error("The parameter 'placeRecevieFilter' cannot be null.");
        else if (placeRecevieFilter !== undefined)
            url_ += "PlaceRecevieFilter=" + encodeURIComponent("" + placeRecevieFilter) + "&"; 
        if (saveToFilter === null)
            throw new Error("The parameter 'saveToFilter' cannot be null.");
        else if (saveToFilter !== undefined)
            url_ += "SaveToFilter=" + encodeURIComponent("" + saveToFilter) + "&"; 
        if (summaryFilter === null)
            throw new Error("The parameter 'summaryFilter' cannot be null.");
        else if (summaryFilter !== undefined)
            url_ += "SummaryFilter=" + encodeURIComponent("" + summaryFilter) + "&"; 
        if (approvedByFilter === null)
            throw new Error("The parameter 'approvedByFilter' cannot be null.");
        else if (approvedByFilter !== undefined)
            url_ += "ApprovedByFilter=" + encodeURIComponent("" + approvedByFilter) + "&"; 
        if (attachmentFilter === null)
            throw new Error("The parameter 'attachmentFilter' cannot be null.");
        else if (attachmentFilter !== undefined)
            url_ += "AttachmentFilter=" + encodeURIComponent("" + attachmentFilter) + "&"; 
        if (typeReceiveFilter === null)
            throw new Error("The parameter 'typeReceiveFilter' cannot be null.");
        else if (typeReceiveFilter !== undefined)
            url_ += "TypeReceiveFilter=" + encodeURIComponent("" + typeReceiveFilter) + "&"; 
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (noteFilter === null)
            throw new Error("The parameter 'noteFilter' cannot be null.");
        else if (noteFilter !== undefined)
            url_ += "NoteFilter=" + encodeURIComponent("" + noteFilter) + "&"; 
        if (priorityFilter === null)
            throw new Error("The parameter 'priorityFilter' cannot be null.");
        else if (priorityFilter !== undefined)
            url_ += "PriorityFilter=" + encodeURIComponent("" + priorityFilter) + "&"; 
        if (incommingDateFilter === null)
            throw new Error("The parameter 'incommingDateFilter' cannot be null.");
        else if (incommingDateFilter !== undefined)
            url_ += "IncommingDateFilter=" + encodeURIComponent(incommingDateFilter ? "" + incommingDateFilter.toJSON() : "") + "&"; 
        if (rangeFilter === null)
            throw new Error("The parameter 'rangeFilter' cannot be null.");
        else if (rangeFilter !== undefined)
            url_ += "RangeFilter=" + encodeURIComponent("" + rangeFilter) + "&"; 
        if (positionFilter === null)
            throw new Error("The parameter 'positionFilter' cannot be null.");
        else if (positionFilter !== undefined)
            url_ += "PositionFilter=" + encodeURIComponent("" + positionFilter) + "&"; 
        if (linkedDocumentFilter === null)
            throw new Error("The parameter 'linkedDocumentFilter' cannot be null.");
        else if (linkedDocumentFilter !== undefined)
            url_ += "LinkedDocumentFilter=" + encodeURIComponent("" + linkedDocumentFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDocumentsForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDocumentsForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDocumentsForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetDocumentsForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetDocumentsForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDocumentsForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentsForView(id: number | undefined): Observable<GetDocumentsForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetDocumentsForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentsForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentsForView(<any>response_);
                } catch (e) {
                    return <Observable<GetDocumentsForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDocumentsForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentsForView(response: HttpResponseBase): Observable<GetDocumentsForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDocumentsForViewDto.fromJS(resultData200) : new GetDocumentsForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentsForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentsForEdit(id: number | undefined): Observable<DocumentsDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetDocumentsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<DocumentsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentsForEdit(response: HttpResponseBase): Observable<DocumentsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentsDto.fromJS(resultData200) : new DocumentsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentsDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: DocumentsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Document/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Document/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param numberFilter (optional) 
     * @param maxIncommingNumberFilter (optional) 
     * @param minIncommingNumberFilter (optional) 
     * @param maxPagesFilter (optional) 
     * @param minPagesFilter (optional) 
     * @param maxDocumentTypeIdFilter (optional) 
     * @param minDocumentTypeIdFilter (optional) 
     * @param dateIssueFilter (optional) 
     * @param placeRecevieFilter (optional) 
     * @param saveToFilter (optional) 
     * @param summaryFilter (optional) 
     * @param approvedByFilter (optional) 
     * @param attachmentFilter (optional) 
     * @param typeReceiveFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param statusFilter (optional) 
     * @param noteFilter (optional) 
     * @param priorityFilter (optional) 
     * @param incommingDateFilter (optional) 
     * @param rangeFilter (optional) 
     * @param positionFilter (optional) 
     * @return Success
     */
    getDocumentsesToExcel(filter: string | undefined, numberFilter: string | undefined, maxIncommingNumberFilter: number | undefined, minIncommingNumberFilter: number | undefined, maxPagesFilter: number | undefined, minPagesFilter: number | undefined, maxDocumentTypeIdFilter: number | undefined, minDocumentTypeIdFilter: number | undefined, dateIssueFilter: string | undefined, placeRecevieFilter: string | undefined, saveToFilter: string | undefined, summaryFilter: string | undefined, approvedByFilter: string | undefined, attachmentFilter: string | undefined, typeReceiveFilter: string | undefined, maxStartDateFilter: moment.Moment | undefined, minStartDateFilter: moment.Moment | undefined, maxEndDateFilter: moment.Moment | undefined, minEndDateFilter: moment.Moment | undefined, statusFilter: string | undefined, noteFilter: string | undefined, priorityFilter: number | undefined, incommingDateFilter: moment.Moment | undefined, rangeFilter: string | undefined, positionFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetDocumentsesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (numberFilter === null)
            throw new Error("The parameter 'numberFilter' cannot be null.");
        else if (numberFilter !== undefined)
            url_ += "NumberFilter=" + encodeURIComponent("" + numberFilter) + "&"; 
        if (maxIncommingNumberFilter === null)
            throw new Error("The parameter 'maxIncommingNumberFilter' cannot be null.");
        else if (maxIncommingNumberFilter !== undefined)
            url_ += "MaxIncommingNumberFilter=" + encodeURIComponent("" + maxIncommingNumberFilter) + "&"; 
        if (minIncommingNumberFilter === null)
            throw new Error("The parameter 'minIncommingNumberFilter' cannot be null.");
        else if (minIncommingNumberFilter !== undefined)
            url_ += "MinIncommingNumberFilter=" + encodeURIComponent("" + minIncommingNumberFilter) + "&"; 
        if (maxPagesFilter === null)
            throw new Error("The parameter 'maxPagesFilter' cannot be null.");
        else if (maxPagesFilter !== undefined)
            url_ += "MaxPagesFilter=" + encodeURIComponent("" + maxPagesFilter) + "&"; 
        if (minPagesFilter === null)
            throw new Error("The parameter 'minPagesFilter' cannot be null.");
        else if (minPagesFilter !== undefined)
            url_ += "MinPagesFilter=" + encodeURIComponent("" + minPagesFilter) + "&"; 
        if (maxDocumentTypeIdFilter === null)
            throw new Error("The parameter 'maxDocumentTypeIdFilter' cannot be null.");
        else if (maxDocumentTypeIdFilter !== undefined)
            url_ += "MaxDocumentTypeIdFilter=" + encodeURIComponent("" + maxDocumentTypeIdFilter) + "&"; 
        if (minDocumentTypeIdFilter === null)
            throw new Error("The parameter 'minDocumentTypeIdFilter' cannot be null.");
        else if (minDocumentTypeIdFilter !== undefined)
            url_ += "MinDocumentTypeIdFilter=" + encodeURIComponent("" + minDocumentTypeIdFilter) + "&"; 
        if (dateIssueFilter === null)
            throw new Error("The parameter 'dateIssueFilter' cannot be null.");
        else if (dateIssueFilter !== undefined)
            url_ += "DateIssueFilter=" + encodeURIComponent("" + dateIssueFilter) + "&"; 
        if (placeRecevieFilter === null)
            throw new Error("The parameter 'placeRecevieFilter' cannot be null.");
        else if (placeRecevieFilter !== undefined)
            url_ += "PlaceRecevieFilter=" + encodeURIComponent("" + placeRecevieFilter) + "&"; 
        if (saveToFilter === null)
            throw new Error("The parameter 'saveToFilter' cannot be null.");
        else if (saveToFilter !== undefined)
            url_ += "SaveToFilter=" + encodeURIComponent("" + saveToFilter) + "&"; 
        if (summaryFilter === null)
            throw new Error("The parameter 'summaryFilter' cannot be null.");
        else if (summaryFilter !== undefined)
            url_ += "SummaryFilter=" + encodeURIComponent("" + summaryFilter) + "&"; 
        if (approvedByFilter === null)
            throw new Error("The parameter 'approvedByFilter' cannot be null.");
        else if (approvedByFilter !== undefined)
            url_ += "ApprovedByFilter=" + encodeURIComponent("" + approvedByFilter) + "&"; 
        if (attachmentFilter === null)
            throw new Error("The parameter 'attachmentFilter' cannot be null.");
        else if (attachmentFilter !== undefined)
            url_ += "AttachmentFilter=" + encodeURIComponent("" + attachmentFilter) + "&"; 
        if (typeReceiveFilter === null)
            throw new Error("The parameter 'typeReceiveFilter' cannot be null.");
        else if (typeReceiveFilter !== undefined)
            url_ += "TypeReceiveFilter=" + encodeURIComponent("" + typeReceiveFilter) + "&"; 
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (noteFilter === null)
            throw new Error("The parameter 'noteFilter' cannot be null.");
        else if (noteFilter !== undefined)
            url_ += "NoteFilter=" + encodeURIComponent("" + noteFilter) + "&"; 
        if (priorityFilter === null)
            throw new Error("The parameter 'priorityFilter' cannot be null.");
        else if (priorityFilter !== undefined)
            url_ += "PriorityFilter=" + encodeURIComponent("" + priorityFilter) + "&"; 
        if (incommingDateFilter === null)
            throw new Error("The parameter 'incommingDateFilter' cannot be null.");
        else if (incommingDateFilter !== undefined)
            url_ += "IncommingDateFilter=" + encodeURIComponent(incommingDateFilter ? "" + incommingDateFilter.toJSON() : "") + "&"; 
        if (rangeFilter === null)
            throw new Error("The parameter 'rangeFilter' cannot be null.");
        else if (rangeFilter !== undefined)
            url_ += "RangeFilter=" + encodeURIComponent("" + rangeFilter) + "&"; 
        if (positionFilter === null)
            throw new Error("The parameter 'positionFilter' cannot be null.");
        else if (positionFilter !== undefined)
            url_ += "PositionFilter=" + encodeURIComponent("" + positionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentsesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentsesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentsesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllDocumentDetailWithId(id: number | undefined): Observable<DocumentDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAllDocumentDetailWithId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDocumentDetailWithId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDocumentDetailWithId(<any>response_);
                } catch (e) {
                    return <Observable<DocumentDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDocumentDetailWithId(response: HttpResponseBase): Observable<DocumentDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentDetailDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllActiveDocument(): Observable<PagedResultDtoOfDocumentsDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAllActiveDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActiveDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActiveDocument(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDocumentsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDocumentsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllActiveDocument(response: HttpResponseBase): Observable<PagedResultDtoOfDocumentsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDocumentsDto.fromJS(resultData200) : new PagedResultDtoOfDocumentsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDocumentsDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllDocumentDetailAsId(id: number | undefined): Observable<DocumentDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAllDocumentDetailAsId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDocumentDetailAsId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDocumentDetailAsId(<any>response_);
                } catch (e) {
                    return <Observable<DocumentDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDocumentDetailAsId(response: HttpResponseBase): Observable<DocumentDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentDetailDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getNextIncommingNumber(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetNextIncommingNumber";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextIncommingNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextIncommingNumber(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextIncommingNumber(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAllIncommingDocumentNotProcessed(): Observable<DocumentsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAllIncommingDocumentNotProcessed";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIncommingDocumentNotProcessed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIncommingDocumentNotProcessed(<any>response_);
                } catch (e) {
                    return <Observable<DocumentsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIncommingDocumentNotProcessed(response: HttpResponseBase): Observable<DocumentsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentsDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllIncommingDocumentNotTransfered_VanThu(): Observable<DocumentsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAllIncommingDocumentNotTransfered_VanThu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIncommingDocumentNotTransfered_VanThu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIncommingDocumentNotTransfered_VanThu(<any>response_);
                } catch (e) {
                    return <Observable<DocumentsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIncommingDocumentNotTransfered_VanThu(response: HttpResponseBase): Observable<DocumentsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentsDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getNumberOfAllDocumentType(): Observable<CounterDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetNumberOfAllDocumentType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNumberOfAllDocumentType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNumberOfAllDocumentType(<any>response_);
                } catch (e) {
                    return <Observable<CounterDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CounterDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNumberOfAllDocumentType(response: HttpResponseBase): Observable<CounterDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CounterDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CounterDto[]>(<any>null);
    }

    /**
     * @param documentId (optional) 
     * @return Success
     */
    getAllDocumentDetailByDocumentId(documentId: number | undefined): Observable<DocumentHandlingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAllDocumentDetailByDocumentId?";
        if (documentId === null)
            throw new Error("The parameter 'documentId' cannot be null.");
        else if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDocumentDetailByDocumentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDocumentDetailByDocumentId(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHandlingDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHandlingDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDocumentDetailByDocumentId(response: HttpResponseBase): Observable<DocumentHandlingDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentHandlingDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHandlingDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getListDocumentNeedToComplete(): Observable<Document_Waitting[]> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetListDocumentNeedToComplete";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListDocumentNeedToComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListDocumentNeedToComplete(<any>response_);
                } catch (e) {
                    return <Observable<Document_Waitting[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Document_Waitting[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListDocumentNeedToComplete(response: HttpResponseBase): Observable<Document_Waitting[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Document_Waitting.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document_Waitting[]>(<any>null);
    }

    /**
     * @param documentId (optional) 
     * @param type (optional) 
     * @return Success
     */
    updateStatusOfDocumentIntoTransfered(documentId: number | undefined, type: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Document/UpdateStatusOfDocumentIntoTransfered?";
        if (documentId === null)
            throw new Error("The parameter 'documentId' cannot be null.");
        else if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&"; 
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatusOfDocumentIntoTransfered(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatusOfDocumentIntoTransfered(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStatusOfDocumentIntoTransfered(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAndReturnId(body: DocumentsDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Document/CreateAndReturnId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAndReturnId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAndReturnId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAndReturnId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDocumentWaitingHandling(): Observable<DocumentsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAllDocumentWaitingHandling";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDocumentWaitingHandling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDocumentWaitingHandling(<any>response_);
                } catch (e) {
                    return <Observable<DocumentsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDocumentWaitingHandling(response: HttpResponseBase): Observable<DocumentsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentsDto[]>(<any>null);
    }
}

@Injectable()
export class DocumentDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param documentIdFilter (optional) 
     * @param maxDatehandleFilter (optional) 
     * @param minDatehandleFilter (optional) 
     * @param typehandleFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param statusFilter (optional) 
     * @param isStaredFilter (optional) 
     * @param priorityFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, documentIdFilter: number | undefined, maxDatehandleFilter: moment.Moment | undefined, minDatehandleFilter: moment.Moment | undefined, typehandleFilter: number | undefined, descriptionFilter: string | undefined, statusFilter: string | undefined, isStaredFilter: boolean | undefined, priorityFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDocumentDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentDetails/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (documentIdFilter === null)
            throw new Error("The parameter 'documentIdFilter' cannot be null.");
        else if (documentIdFilter !== undefined)
            url_ += "DocumentIdFilter=" + encodeURIComponent("" + documentIdFilter) + "&"; 
        if (maxDatehandleFilter === null)
            throw new Error("The parameter 'maxDatehandleFilter' cannot be null.");
        else if (maxDatehandleFilter !== undefined)
            url_ += "MaxDatehandleFilter=" + encodeURIComponent(maxDatehandleFilter ? "" + maxDatehandleFilter.toJSON() : "") + "&"; 
        if (minDatehandleFilter === null)
            throw new Error("The parameter 'minDatehandleFilter' cannot be null.");
        else if (minDatehandleFilter !== undefined)
            url_ += "MinDatehandleFilter=" + encodeURIComponent(minDatehandleFilter ? "" + minDatehandleFilter.toJSON() : "") + "&"; 
        if (typehandleFilter === null)
            throw new Error("The parameter 'typehandleFilter' cannot be null.");
        else if (typehandleFilter !== undefined)
            url_ += "TypehandleFilter=" + encodeURIComponent("" + typehandleFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (isStaredFilter === null)
            throw new Error("The parameter 'isStaredFilter' cannot be null.");
        else if (isStaredFilter !== undefined)
            url_ += "IsStaredFilter=" + encodeURIComponent("" + isStaredFilter) + "&"; 
        if (priorityFilter === null)
            throw new Error("The parameter 'priorityFilter' cannot be null.");
        else if (priorityFilter !== undefined)
            url_ += "PriorityFilter=" + encodeURIComponent("" + priorityFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDocumentDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDocumentDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDocumentDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetDocumentDetailForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetDocumentDetailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDocumentDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentDetailForView(id: number | undefined): Observable<GetDocumentDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentDetails/GetDocumentDetailForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentDetailForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentDetailForView(<any>response_);
                } catch (e) {
                    return <Observable<GetDocumentDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDocumentDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentDetailForView(response: HttpResponseBase): Observable<GetDocumentDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDocumentDetailForViewDto.fromJS(resultData200) : new GetDocumentDetailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentDetailForEdit(id: number | undefined): Observable<GetDocumentDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DocumentDetails/GetDocumentDetailForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDocumentDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDocumentDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentDetailForEdit(response: HttpResponseBase): Observable<GetDocumentDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDocumentDetailForEditOutput.fromJS(resultData200) : new GetDocumentDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentDetailForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDocumentDetailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentDetails/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param documentIdFilter (optional) 
     * @param maxDatehandleFilter (optional) 
     * @param minDatehandleFilter (optional) 
     * @param typehandleFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param statusFilter (optional) 
     * @param isStaredFilter (optional) 
     * @param priorityFilter (optional) 
     * @return Success
     */
    getDocumentDetailsToExcel(filter: string | undefined, documentIdFilter: number | undefined, maxDatehandleFilter: moment.Moment | undefined, minDatehandleFilter: moment.Moment | undefined, typehandleFilter: number | undefined, descriptionFilter: string | undefined, statusFilter: string | undefined, isStaredFilter: boolean | undefined, priorityFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentDetails/GetDocumentDetailsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (documentIdFilter === null)
            throw new Error("The parameter 'documentIdFilter' cannot be null.");
        else if (documentIdFilter !== undefined)
            url_ += "DocumentIdFilter=" + encodeURIComponent("" + documentIdFilter) + "&"; 
        if (maxDatehandleFilter === null)
            throw new Error("The parameter 'maxDatehandleFilter' cannot be null.");
        else if (maxDatehandleFilter !== undefined)
            url_ += "MaxDatehandleFilter=" + encodeURIComponent(maxDatehandleFilter ? "" + maxDatehandleFilter.toJSON() : "") + "&"; 
        if (minDatehandleFilter === null)
            throw new Error("The parameter 'minDatehandleFilter' cannot be null.");
        else if (minDatehandleFilter !== undefined)
            url_ += "MinDatehandleFilter=" + encodeURIComponent(minDatehandleFilter ? "" + minDatehandleFilter.toJSON() : "") + "&"; 
        if (typehandleFilter === null)
            throw new Error("The parameter 'typehandleFilter' cannot be null.");
        else if (typehandleFilter !== undefined)
            url_ += "TypehandleFilter=" + encodeURIComponent("" + typehandleFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (isStaredFilter === null)
            throw new Error("The parameter 'isStaredFilter' cannot be null.");
        else if (isStaredFilter !== undefined)
            url_ += "IsStaredFilter=" + encodeURIComponent("" + isStaredFilter) + "&"; 
        if (priorityFilter === null)
            throw new Error("The parameter 'priorityFilter' cannot be null.");
        else if (priorityFilter !== undefined)
            url_ += "PriorityFilter=" + encodeURIComponent("" + priorityFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentDetailsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentDetailsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentDetailsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class DocumentHandlingDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param groupFilter (optional) 
     * @param personFilter (optional) 
     * @param typeFilter (optional) 
     * @param superiosFilter (optional) 
     * @param personalCommentFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param maxDocumentHandlingIdFilter (optional) 
     * @param minDocumentHandlingIdFilter (optional) 
     * @param mainHandlingFilter (optional) 
     * @param coHandlingFilter (optional) 
     * @param toKnowFilter (optional) 
     * @param userIdFilter (optional) 
     * @param isHandledFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, groupFilter: string | undefined, personFilter: string | undefined, typeFilter: string | undefined, superiosFilter: string | undefined, personalCommentFilter: string | undefined, maxStartDateFilter: moment.Moment | undefined, minStartDateFilter: moment.Moment | undefined, maxEndDateFilter: moment.Moment | undefined, minEndDateFilter: moment.Moment | undefined, maxDocumentHandlingIdFilter: number | undefined, minDocumentHandlingIdFilter: number | undefined, mainHandlingFilter: number | undefined, coHandlingFilter: number | undefined, toKnowFilter: number | undefined, userIdFilter: number | undefined, isHandledFilter: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDocumentHandlingDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlingDetails/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (groupFilter === null)
            throw new Error("The parameter 'groupFilter' cannot be null.");
        else if (groupFilter !== undefined)
            url_ += "GroupFilter=" + encodeURIComponent("" + groupFilter) + "&"; 
        if (personFilter === null)
            throw new Error("The parameter 'personFilter' cannot be null.");
        else if (personFilter !== undefined)
            url_ += "PersonFilter=" + encodeURIComponent("" + personFilter) + "&"; 
        if (typeFilter === null)
            throw new Error("The parameter 'typeFilter' cannot be null.");
        else if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&"; 
        if (superiosFilter === null)
            throw new Error("The parameter 'superiosFilter' cannot be null.");
        else if (superiosFilter !== undefined)
            url_ += "SuperiosFilter=" + encodeURIComponent("" + superiosFilter) + "&"; 
        if (personalCommentFilter === null)
            throw new Error("The parameter 'personalCommentFilter' cannot be null.");
        else if (personalCommentFilter !== undefined)
            url_ += "PersonalCommentFilter=" + encodeURIComponent("" + personalCommentFilter) + "&"; 
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (maxDocumentHandlingIdFilter === null)
            throw new Error("The parameter 'maxDocumentHandlingIdFilter' cannot be null.");
        else if (maxDocumentHandlingIdFilter !== undefined)
            url_ += "MaxDocumentHandlingIdFilter=" + encodeURIComponent("" + maxDocumentHandlingIdFilter) + "&"; 
        if (minDocumentHandlingIdFilter === null)
            throw new Error("The parameter 'minDocumentHandlingIdFilter' cannot be null.");
        else if (minDocumentHandlingIdFilter !== undefined)
            url_ += "MinDocumentHandlingIdFilter=" + encodeURIComponent("" + minDocumentHandlingIdFilter) + "&"; 
        if (mainHandlingFilter === null)
            throw new Error("The parameter 'mainHandlingFilter' cannot be null.");
        else if (mainHandlingFilter !== undefined)
            url_ += "MainHandlingFilter=" + encodeURIComponent("" + mainHandlingFilter) + "&"; 
        if (coHandlingFilter === null)
            throw new Error("The parameter 'coHandlingFilter' cannot be null.");
        else if (coHandlingFilter !== undefined)
            url_ += "CoHandlingFilter=" + encodeURIComponent("" + coHandlingFilter) + "&"; 
        if (toKnowFilter === null)
            throw new Error("The parameter 'toKnowFilter' cannot be null.");
        else if (toKnowFilter !== undefined)
            url_ += "ToKnowFilter=" + encodeURIComponent("" + toKnowFilter) + "&"; 
        if (userIdFilter === null)
            throw new Error("The parameter 'userIdFilter' cannot be null.");
        else if (userIdFilter !== undefined)
            url_ += "UserIdFilter=" + encodeURIComponent("" + userIdFilter) + "&"; 
        if (isHandledFilter === null)
            throw new Error("The parameter 'isHandledFilter' cannot be null.");
        else if (isHandledFilter !== undefined)
            url_ += "IsHandledFilter=" + encodeURIComponent("" + isHandledFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDocumentHandlingDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDocumentHandlingDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDocumentHandlingDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetDocumentHandlingDetailForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetDocumentHandlingDetailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDocumentHandlingDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentHandlingDetailForEdit(id: number | undefined): Observable<GetDocumentHandlingDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlingDetails/GetDocumentHandlingDetailForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentHandlingDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentHandlingDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDocumentHandlingDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDocumentHandlingDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentHandlingDetailForEdit(response: HttpResponseBase): Observable<GetDocumentHandlingDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDocumentHandlingDetailForEditOutput.fromJS(resultData200) : new GetDocumentHandlingDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentHandlingDetailForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDocumentHandlingDetailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlingDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlingDetails/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAllDocumentHandlingDetailByUserId(userId: number | undefined): Observable<DocumentHandlingDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlingDetails/GetAllDocumentHandlingDetailByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDocumentHandlingDetailByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDocumentHandlingDetailByUserId(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHandlingDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHandlingDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDocumentHandlingDetailByUserId(response: HttpResponseBase): Observable<DocumentHandlingDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentHandlingDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHandlingDetailDto[]>(<any>null);
    }
}

@Injectable()
export class DocumentHandlingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxDocumentIdFilter (optional) 
     * @param minDocumentIdFilter (optional) 
     * @param handlerFilter (optional) 
     * @param maxHandlingDetailIdFilter (optional) 
     * @param minHandlingDetailIdFilter (optional) 
     * @param placeReceiveFilter (optional) 
     * @param contentFilter (optional) 
     * @param statusFilter (optional) 
     * @param commentFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxDocumentIdFilter: number | undefined, minDocumentIdFilter: number | undefined, handlerFilter: string | undefined, maxHandlingDetailIdFilter: number | undefined, minHandlingDetailIdFilter: number | undefined, placeReceiveFilter: string | undefined, contentFilter: string | undefined, statusFilter: string | undefined, commentFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDocumentHandlingForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlings/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxDocumentIdFilter === null)
            throw new Error("The parameter 'maxDocumentIdFilter' cannot be null.");
        else if (maxDocumentIdFilter !== undefined)
            url_ += "MaxDocumentIdFilter=" + encodeURIComponent("" + maxDocumentIdFilter) + "&"; 
        if (minDocumentIdFilter === null)
            throw new Error("The parameter 'minDocumentIdFilter' cannot be null.");
        else if (minDocumentIdFilter !== undefined)
            url_ += "MinDocumentIdFilter=" + encodeURIComponent("" + minDocumentIdFilter) + "&"; 
        if (handlerFilter === null)
            throw new Error("The parameter 'handlerFilter' cannot be null.");
        else if (handlerFilter !== undefined)
            url_ += "HandlerFilter=" + encodeURIComponent("" + handlerFilter) + "&"; 
        if (maxHandlingDetailIdFilter === null)
            throw new Error("The parameter 'maxHandlingDetailIdFilter' cannot be null.");
        else if (maxHandlingDetailIdFilter !== undefined)
            url_ += "MaxHandlingDetailIdFilter=" + encodeURIComponent("" + maxHandlingDetailIdFilter) + "&"; 
        if (minHandlingDetailIdFilter === null)
            throw new Error("The parameter 'minHandlingDetailIdFilter' cannot be null.");
        else if (minHandlingDetailIdFilter !== undefined)
            url_ += "MinHandlingDetailIdFilter=" + encodeURIComponent("" + minHandlingDetailIdFilter) + "&"; 
        if (placeReceiveFilter === null)
            throw new Error("The parameter 'placeReceiveFilter' cannot be null.");
        else if (placeReceiveFilter !== undefined)
            url_ += "PlaceReceiveFilter=" + encodeURIComponent("" + placeReceiveFilter) + "&"; 
        if (contentFilter === null)
            throw new Error("The parameter 'contentFilter' cannot be null.");
        else if (contentFilter !== undefined)
            url_ += "ContentFilter=" + encodeURIComponent("" + contentFilter) + "&"; 
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (commentFilter === null)
            throw new Error("The parameter 'commentFilter' cannot be null.");
        else if (commentFilter !== undefined)
            url_ += "CommentFilter=" + encodeURIComponent("" + commentFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDocumentHandlingForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDocumentHandlingForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDocumentHandlingForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetDocumentHandlingForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetDocumentHandlingForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDocumentHandlingForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentHandlingForView(id: number | undefined): Observable<GetDocumentHandlingForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlings/GetDocumentHandlingForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentHandlingForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentHandlingForView(<any>response_);
                } catch (e) {
                    return <Observable<GetDocumentHandlingForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDocumentHandlingForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentHandlingForView(response: HttpResponseBase): Observable<GetDocumentHandlingForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDocumentHandlingForViewDto.fromJS(resultData200) : new GetDocumentHandlingForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentHandlingForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentHandlingForEdit(id: number | undefined): Observable<GetDocumentHandlingForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlings/GetDocumentHandlingForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentHandlingForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentHandlingForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDocumentHandlingForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDocumentHandlingForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentHandlingForEdit(response: HttpResponseBase): Observable<GetDocumentHandlingForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDocumentHandlingForEditOutput.fromJS(resultData200) : new GetDocumentHandlingForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentHandlingForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDocumentHandlingDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlings/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlings/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxDocumentIdFilter (optional) 
     * @param minDocumentIdFilter (optional) 
     * @param handlerFilter (optional) 
     * @param maxHandlingDetailIdFilter (optional) 
     * @param minHandlingDetailIdFilter (optional) 
     * @param placeReceiveFilter (optional) 
     * @param maxKeywordIdFilter (optional) 
     * @param minKeywordIdFilter (optional) 
     * @param contentFilter (optional) 
     * @param statusFilter (optional) 
     * @param commentFilter (optional) 
     * @return Success
     */
    getDocumentHandlingsToExcel(filter: string | undefined, maxDocumentIdFilter: number | undefined, minDocumentIdFilter: number | undefined, handlerFilter: string | undefined, maxHandlingDetailIdFilter: number | undefined, minHandlingDetailIdFilter: number | undefined, placeReceiveFilter: string | undefined, maxKeywordIdFilter: number | undefined, minKeywordIdFilter: number | undefined, contentFilter: string | undefined, statusFilter: string | undefined, commentFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlings/GetDocumentHandlingsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxDocumentIdFilter === null)
            throw new Error("The parameter 'maxDocumentIdFilter' cannot be null.");
        else if (maxDocumentIdFilter !== undefined)
            url_ += "MaxDocumentIdFilter=" + encodeURIComponent("" + maxDocumentIdFilter) + "&"; 
        if (minDocumentIdFilter === null)
            throw new Error("The parameter 'minDocumentIdFilter' cannot be null.");
        else if (minDocumentIdFilter !== undefined)
            url_ += "MinDocumentIdFilter=" + encodeURIComponent("" + minDocumentIdFilter) + "&"; 
        if (handlerFilter === null)
            throw new Error("The parameter 'handlerFilter' cannot be null.");
        else if (handlerFilter !== undefined)
            url_ += "HandlerFilter=" + encodeURIComponent("" + handlerFilter) + "&"; 
        if (maxHandlingDetailIdFilter === null)
            throw new Error("The parameter 'maxHandlingDetailIdFilter' cannot be null.");
        else if (maxHandlingDetailIdFilter !== undefined)
            url_ += "MaxHandlingDetailIdFilter=" + encodeURIComponent("" + maxHandlingDetailIdFilter) + "&"; 
        if (minHandlingDetailIdFilter === null)
            throw new Error("The parameter 'minHandlingDetailIdFilter' cannot be null.");
        else if (minHandlingDetailIdFilter !== undefined)
            url_ += "MinHandlingDetailIdFilter=" + encodeURIComponent("" + minHandlingDetailIdFilter) + "&"; 
        if (placeReceiveFilter === null)
            throw new Error("The parameter 'placeReceiveFilter' cannot be null.");
        else if (placeReceiveFilter !== undefined)
            url_ += "PlaceReceiveFilter=" + encodeURIComponent("" + placeReceiveFilter) + "&"; 
        if (maxKeywordIdFilter === null)
            throw new Error("The parameter 'maxKeywordIdFilter' cannot be null.");
        else if (maxKeywordIdFilter !== undefined)
            url_ += "MaxKeywordIdFilter=" + encodeURIComponent("" + maxKeywordIdFilter) + "&"; 
        if (minKeywordIdFilter === null)
            throw new Error("The parameter 'minKeywordIdFilter' cannot be null.");
        else if (minKeywordIdFilter !== undefined)
            url_ += "MinKeywordIdFilter=" + encodeURIComponent("" + minKeywordIdFilter) + "&"; 
        if (contentFilter === null)
            throw new Error("The parameter 'contentFilter' cannot be null.");
        else if (contentFilter !== undefined)
            url_ += "ContentFilter=" + encodeURIComponent("" + contentFilter) + "&"; 
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (commentFilter === null)
            throw new Error("The parameter 'commentFilter' cannot be null.");
        else if (commentFilter !== undefined)
            url_ += "CommentFilter=" + encodeURIComponent("" + commentFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentHandlingsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentHandlingsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentHandlingsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLeaderTypes(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlings/GetLeaderTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaderTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaderTypes(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaderTypes(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getLeaderList(): Observable<HandlingUser[]> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlings/GetLeaderList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaderList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaderList(<any>response_);
                } catch (e) {
                    return <Observable<HandlingUser[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandlingUser[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaderList(response: HttpResponseBase): Observable<HandlingUser[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HandlingUser.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandlingUser[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllProcesHanding(): Observable<GetDataAndColumnConfig_ProcesHanding> {
        let url_ = this.baseUrl + "/api/services/app/DocumentHandlings/GetAllProcesHanding";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProcesHanding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProcesHanding(<any>response_);
                } catch (e) {
                    return <Observable<GetDataAndColumnConfig_ProcesHanding>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDataAndColumnConfig_ProcesHanding>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProcesHanding(response: HttpResponseBase): Observable<GetDataAndColumnConfig_ProcesHanding> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDataAndColumnConfig_ProcesHanding.fromJS(resultData200) : new GetDataAndColumnConfig_ProcesHanding();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDataAndColumnConfig_ProcesHanding>(<any>null);
    }
}

@Injectable()
export class DocumentStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param valueFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, keyFilter: string | undefined, valueFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDocumentStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentStatuses/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter === null)
            throw new Error("The parameter 'keyFilter' cannot be null.");
        else if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (valueFilter === null)
            throw new Error("The parameter 'valueFilter' cannot be null.");
        else if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDocumentStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDocumentStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDocumentStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetDocumentStatusForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetDocumentStatusForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDocumentStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentStatusForView(id: number | undefined): Observable<GetDocumentStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentStatuses/GetDocumentStatusForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentStatusForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentStatusForView(<any>response_);
                } catch (e) {
                    return <Observable<GetDocumentStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDocumentStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentStatusForView(response: HttpResponseBase): Observable<GetDocumentStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDocumentStatusForViewDto.fromJS(resultData200) : new GetDocumentStatusForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentStatusForEdit(id: number | undefined): Observable<GetDocumentStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DocumentStatuses/GetDocumentStatusForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDocumentStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDocumentStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentStatusForEdit(response: HttpResponseBase): Observable<GetDocumentStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDocumentStatusForEditOutput.fromJS(resultData200) : new GetDocumentStatusForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentStatusForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDocumentStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentStatuses/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DocumentTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param typeNameFilter (optional) 
     * @param signalFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, typeNameFilter: string | undefined, signalFilter: string | undefined, isActiveFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDocumentTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (typeNameFilter === null)
            throw new Error("The parameter 'typeNameFilter' cannot be null.");
        else if (typeNameFilter !== undefined)
            url_ += "TypeNameFilter=" + encodeURIComponent("" + typeNameFilter) + "&"; 
        if (signalFilter === null)
            throw new Error("The parameter 'signalFilter' cannot be null.");
        else if (signalFilter !== undefined)
            url_ += "SignalFilter=" + encodeURIComponent("" + signalFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDocumentTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDocumentTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDocumentTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetDocumentTypeForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetDocumentTypeForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDocumentTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentTypeForView(id: number | undefined): Observable<GetDocumentTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/GetDocumentTypeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetDocumentTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDocumentTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentTypeForView(response: HttpResponseBase): Observable<GetDocumentTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDocumentTypeForViewDto.fromJS(resultData200) : new GetDocumentTypeForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentTypeForEdit(id: number | undefined): Observable<GetDocumentTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/GetDocumentTypeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDocumentTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDocumentTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentTypeForEdit(response: HttpResponseBase): Observable<GetDocumentTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDocumentTypeForEditOutput.fromJS(resultData200) : new GetDocumentTypeForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentTypeForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDocumentTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param typeNameFilter (optional) 
     * @param signalFilter (optional) 
     * @param isActiveFilter (optional) 
     * @return Success
     */
    getDocumentTypesToExcel(filter: string | undefined, typeNameFilter: string | undefined, signalFilter: string | undefined, isActiveFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/GetDocumentTypesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (typeNameFilter === null)
            throw new Error("The parameter 'typeNameFilter' cannot be null.");
        else if (typeNameFilter !== undefined)
            url_ += "TypeNameFilter=" + encodeURIComponent("" + typeNameFilter) + "&"; 
        if (signalFilter === null)
            throw new Error("The parameter 'signalFilter' cannot be null.");
        else if (signalFilter !== undefined)
            url_ += "SignalFilter=" + encodeURIComponent("" + signalFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDocumentType(): Observable<DocumentTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/GetAllDocumentType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDocumentType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDocumentType(<any>response_);
                } catch (e) {
                    return <Observable<DocumentTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDocumentType(response: HttpResponseBase): Observable<DocumentTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeDto[]>(<any>null);
    }
}

@Injectable()
export class DynamicActionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDynamicActionForView(id: number | undefined): Observable<GetDynamicActionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicActions/GetDynamicActionForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicActionForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicActionForView(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicActionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicActionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicActionForView(response: HttpResponseBase): Observable<GetDynamicActionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDynamicActionForViewDto.fromJS(resultData200) : new GetDynamicActionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicActionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDynamicActionForEdit(id: number | undefined): Observable<GetDynamicActionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicActions/GetDynamicActionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicActionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicActionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicActionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicActionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicActionForEdit(response: HttpResponseBase): Observable<GetDynamicActionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDynamicActionForEditOutput.fromJS(resultData200) : new GetDynamicActionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicActionForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDynamicActionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicActions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicActions/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param labelId (optional) 
     * @return Success
     */
    getDynamicActionByLabelId(labelId: number | undefined): Observable<DynamicActionDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicActions/GetDynamicActionByLabelId?";
        if (labelId === null)
            throw new Error("The parameter 'labelId' cannot be null.");
        else if (labelId !== undefined)
            url_ += "labelId=" + encodeURIComponent("" + labelId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicActionByLabelId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicActionByLabelId(<any>response_);
                } catch (e) {
                    return <Observable<DynamicActionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicActionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicActionByLabelId(response: HttpResponseBase): Observable<DynamicActionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DynamicActionDto.fromJS(resultData200) : new DynamicActionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicActionDto>(<any>null);
    }

    /**
     * @param labelId (optional) 
     * @param roleId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getAllDynamicActionByLabelId(labelId: number | undefined, roleId: number | undefined, tenantId: number | undefined): Observable<CreateOrEditDynamicActionDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicActions/GetAllDynamicActionByLabelId?";
        if (labelId === null)
            throw new Error("The parameter 'labelId' cannot be null.");
        else if (labelId !== undefined)
            url_ += "labelId=" + encodeURIComponent("" + labelId) + "&"; 
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDynamicActionByLabelId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDynamicActionByLabelId(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditDynamicActionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditDynamicActionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDynamicActionByLabelId(response: HttpResponseBase): Observable<CreateOrEditDynamicActionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateOrEditDynamicActionDto.fromJS(resultData200) : new CreateOrEditDynamicActionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditDynamicActionDto>(<any>null);
    }
}

@Injectable()
export class DynamicDatasourceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    getDynamicDatasourceByType(type: number | undefined): Observable<DynamicDatasourceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicDatasource/GetDynamicDatasourceByType?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicDatasourceByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicDatasourceByType(<any>response_);
                } catch (e) {
                    return <Observable<DynamicDatasourceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicDatasourceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicDatasourceByType(response: HttpResponseBase): Observable<DynamicDatasourceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DynamicDatasourceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicDatasourceDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTypeFilter (optional) 
     * @param minTypeFilter (optional) 
     * @param maxObjectIdFilter (optional) 
     * @param minObjectIdFilter (optional) 
     * @param maxDynamicFieldIdFilter (optional) 
     * @param minDynamicFieldIdFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxTypeFilter: number | undefined, minTypeFilter: number | undefined, maxObjectIdFilter: number | undefined, minObjectIdFilter: number | undefined, maxDynamicFieldIdFilter: number | undefined, minDynamicFieldIdFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, isActiveFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDynamicDatasourceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicDatasource/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTypeFilter === null)
            throw new Error("The parameter 'maxTypeFilter' cannot be null.");
        else if (maxTypeFilter !== undefined)
            url_ += "MaxTypeFilter=" + encodeURIComponent("" + maxTypeFilter) + "&"; 
        if (minTypeFilter === null)
            throw new Error("The parameter 'minTypeFilter' cannot be null.");
        else if (minTypeFilter !== undefined)
            url_ += "MinTypeFilter=" + encodeURIComponent("" + minTypeFilter) + "&"; 
        if (maxObjectIdFilter === null)
            throw new Error("The parameter 'maxObjectIdFilter' cannot be null.");
        else if (maxObjectIdFilter !== undefined)
            url_ += "MaxObjectIdFilter=" + encodeURIComponent("" + maxObjectIdFilter) + "&"; 
        if (minObjectIdFilter === null)
            throw new Error("The parameter 'minObjectIdFilter' cannot be null.");
        else if (minObjectIdFilter !== undefined)
            url_ += "MinObjectIdFilter=" + encodeURIComponent("" + minObjectIdFilter) + "&"; 
        if (maxDynamicFieldIdFilter === null)
            throw new Error("The parameter 'maxDynamicFieldIdFilter' cannot be null.");
        else if (maxDynamicFieldIdFilter !== undefined)
            url_ += "MaxDynamicFieldIdFilter=" + encodeURIComponent("" + maxDynamicFieldIdFilter) + "&"; 
        if (minDynamicFieldIdFilter === null)
            throw new Error("The parameter 'minDynamicFieldIdFilter' cannot be null.");
        else if (minDynamicFieldIdFilter !== undefined)
            url_ += "MinDynamicFieldIdFilter=" + encodeURIComponent("" + minDynamicFieldIdFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDynamicDatasourceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDynamicDatasourceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDynamicDatasourceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetDynamicDatasourceForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetDynamicDatasourceForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDynamicDatasourceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDynamicDatasourceForView(id: number | undefined): Observable<GetDynamicDatasourceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicDatasource/GetDynamicDatasourceForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicDatasourceForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicDatasourceForView(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicDatasourceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicDatasourceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicDatasourceForView(response: HttpResponseBase): Observable<GetDynamicDatasourceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDynamicDatasourceForViewDto.fromJS(resultData200) : new GetDynamicDatasourceForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicDatasourceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDynamicDatasourceForEdit(id: number | undefined): Observable<GetDynamicDatasourceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicDatasource/GetDynamicDatasourceForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicDatasourceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicDatasourceForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicDatasourceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicDatasourceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicDatasourceForEdit(response: HttpResponseBase): Observable<GetDynamicDatasourceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDynamicDatasourceForEditOutput.fromJS(resultData200) : new GetDynamicDatasourceForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicDatasourceForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDynamicDatasourceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicDatasource/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicDatasource/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTypeFilter (optional) 
     * @param minTypeFilter (optional) 
     * @param maxObjectIdFilter (optional) 
     * @param minObjectIdFilter (optional) 
     * @param maxDynamicFieldIdFilter (optional) 
     * @param minDynamicFieldIdFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param isActiveFilter (optional) 
     * @return Success
     */
    getDynamicDatasourceToExcel(filter: string | undefined, maxTypeFilter: number | undefined, minTypeFilter: number | undefined, maxObjectIdFilter: number | undefined, minObjectIdFilter: number | undefined, maxDynamicFieldIdFilter: number | undefined, minDynamicFieldIdFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, isActiveFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicDatasource/GetDynamicDatasourceToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTypeFilter === null)
            throw new Error("The parameter 'maxTypeFilter' cannot be null.");
        else if (maxTypeFilter !== undefined)
            url_ += "MaxTypeFilter=" + encodeURIComponent("" + maxTypeFilter) + "&"; 
        if (minTypeFilter === null)
            throw new Error("The parameter 'minTypeFilter' cannot be null.");
        else if (minTypeFilter !== undefined)
            url_ += "MinTypeFilter=" + encodeURIComponent("" + minTypeFilter) + "&"; 
        if (maxObjectIdFilter === null)
            throw new Error("The parameter 'maxObjectIdFilter' cannot be null.");
        else if (maxObjectIdFilter !== undefined)
            url_ += "MaxObjectIdFilter=" + encodeURIComponent("" + maxObjectIdFilter) + "&"; 
        if (minObjectIdFilter === null)
            throw new Error("The parameter 'minObjectIdFilter' cannot be null.");
        else if (minObjectIdFilter !== undefined)
            url_ += "MinObjectIdFilter=" + encodeURIComponent("" + minObjectIdFilter) + "&"; 
        if (maxDynamicFieldIdFilter === null)
            throw new Error("The parameter 'maxDynamicFieldIdFilter' cannot be null.");
        else if (maxDynamicFieldIdFilter !== undefined)
            url_ += "MaxDynamicFieldIdFilter=" + encodeURIComponent("" + maxDynamicFieldIdFilter) + "&"; 
        if (minDynamicFieldIdFilter === null)
            throw new Error("The parameter 'minDynamicFieldIdFilter' cannot be null.");
        else if (minDynamicFieldIdFilter !== undefined)
            url_ += "MinDynamicFieldIdFilter=" + encodeURIComponent("" + minDynamicFieldIdFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicDatasourceToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicDatasourceToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicDatasourceToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class DynamicFieldsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllDynamicFieldDistinct(): Observable<DynamicFieldDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicFields/GetAllDynamicFieldDistinct";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDynamicFieldDistinct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDynamicFieldDistinct(<any>response_);
                } catch (e) {
                    return <Observable<DynamicFieldDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicFieldDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDynamicFieldDistinct(response: HttpResponseBase): Observable<DynamicFieldDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DynamicFieldDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicFieldDto[]>(<any>null);
    }

    /**
     * @param moduleId (optional) 
     * @return Success
     */
    getDynamicFieldByModuleId(moduleId: number | undefined): Observable<DynamicFieldDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicFields/GetDynamicFieldByModuleId?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicFieldByModuleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicFieldByModuleId(<any>response_);
                } catch (e) {
                    return <Observable<DynamicFieldDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicFieldDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicFieldByModuleId(response: HttpResponseBase): Observable<DynamicFieldDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DynamicFieldDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicFieldDto[]>(<any>null);
    }

    /**
     * @param link (optional) 
     * @param objectId (optional) 
     * @return Success
     */
    getDynamicFields(link: string | undefined, objectId: number | undefined): Observable<DynamicFieldListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicFields/GetDynamicFields?";
        if (link === null)
            throw new Error("The parameter 'link' cannot be null.");
        else if (link !== undefined)
            url_ += "Link=" + encodeURIComponent("" + link) + "&"; 
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicFields(<any>response_);
                } catch (e) {
                    return <Observable<DynamicFieldListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicFieldListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicFields(response: HttpResponseBase): Observable<DynamicFieldListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DynamicFieldListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicFieldListDto[]>(<any>null);
    }

    /**
     * @param dynamicFieldId (optional) 
     * @param objectId (optional) 
     * @param parameters (optional) 
     * @return Success
     */
    getDataSourceDynamic(dynamicFieldId: number | undefined, objectId: number | undefined, parameters: string | undefined): Observable<GetDataSourceDynamicDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicFields/GetDataSourceDynamic?";
        if (dynamicFieldId === null)
            throw new Error("The parameter 'dynamicFieldId' cannot be null.");
        else if (dynamicFieldId !== undefined)
            url_ += "DynamicFieldId=" + encodeURIComponent("" + dynamicFieldId) + "&"; 
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&"; 
        if (parameters === null)
            throw new Error("The parameter 'parameters' cannot be null.");
        else if (parameters !== undefined)
            url_ += "Parameters=" + encodeURIComponent("" + parameters) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataSourceDynamic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataSourceDynamic(<any>response_);
                } catch (e) {
                    return <Observable<GetDataSourceDynamicDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDataSourceDynamicDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataSourceDynamic(response: HttpResponseBase): Observable<GetDataSourceDynamicDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetDataSourceDynamicDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDataSourceDynamicDto[]>(<any>null);
    }

    /**
     * @param moduleId (optional) 
     * @return Success
     */
    getCbbField(moduleId: number | undefined): Observable<DynamicFieldDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicFields/GetCbbField?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCbbField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCbbField(<any>response_);
                } catch (e) {
                    return <Observable<DynamicFieldDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicFieldDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCbbField(response: HttpResponseBase): Observable<DynamicFieldDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DynamicFieldDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicFieldDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDynamicFieldForModule(body: CreateOrEditDynamicFieldDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicFields/CreateDynamicFieldForModule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDynamicFieldForModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDynamicFieldForModule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDynamicFieldForModule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertUpdateDynamicFields(body: DynamicValueDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicFields/InsertUpdateDynamicFields";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateDynamicFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateDynamicFields(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUpdateDynamicFields(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxModuleIdFilter (optional) 
     * @param minModuleIdFilter (optional) 
     * @param tableNameFilter (optional) 
     * @param nameFilter (optional) 
     * @param maxTypeFieldFilter (optional) 
     * @param minTypeFieldFilter (optional) 
     * @param maxWidthFilter (optional) 
     * @param minWidthFilter (optional) 
     * @param nameDescriptionFilter (optional) 
     * @param maxDepartmentIdFilter (optional) 
     * @param minDepartmentIdFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param maxWidthDescriptionFilter (optional) 
     * @param minWidthDescriptionFilter (optional) 
     * @param classAttachFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxModuleIdFilter: number | undefined, minModuleIdFilter: number | undefined, tableNameFilter: string | undefined, nameFilter: string | undefined, maxTypeFieldFilter: number | undefined, minTypeFieldFilter: number | undefined, maxWidthFilter: number | undefined, minWidthFilter: number | undefined, nameDescriptionFilter: string | undefined, maxDepartmentIdFilter: number | undefined, minDepartmentIdFilter: number | undefined, isActiveFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, maxWidthDescriptionFilter: number | undefined, minWidthDescriptionFilter: number | undefined, classAttachFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDynamicFieldForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicFields/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxModuleIdFilter === null)
            throw new Error("The parameter 'maxModuleIdFilter' cannot be null.");
        else if (maxModuleIdFilter !== undefined)
            url_ += "MaxModuleIdFilter=" + encodeURIComponent("" + maxModuleIdFilter) + "&"; 
        if (minModuleIdFilter === null)
            throw new Error("The parameter 'minModuleIdFilter' cannot be null.");
        else if (minModuleIdFilter !== undefined)
            url_ += "MinModuleIdFilter=" + encodeURIComponent("" + minModuleIdFilter) + "&"; 
        if (tableNameFilter === null)
            throw new Error("The parameter 'tableNameFilter' cannot be null.");
        else if (tableNameFilter !== undefined)
            url_ += "TableNameFilter=" + encodeURIComponent("" + tableNameFilter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (maxTypeFieldFilter === null)
            throw new Error("The parameter 'maxTypeFieldFilter' cannot be null.");
        else if (maxTypeFieldFilter !== undefined)
            url_ += "MaxTypeFieldFilter=" + encodeURIComponent("" + maxTypeFieldFilter) + "&"; 
        if (minTypeFieldFilter === null)
            throw new Error("The parameter 'minTypeFieldFilter' cannot be null.");
        else if (minTypeFieldFilter !== undefined)
            url_ += "MinTypeFieldFilter=" + encodeURIComponent("" + minTypeFieldFilter) + "&"; 
        if (maxWidthFilter === null)
            throw new Error("The parameter 'maxWidthFilter' cannot be null.");
        else if (maxWidthFilter !== undefined)
            url_ += "MaxWidthFilter=" + encodeURIComponent("" + maxWidthFilter) + "&"; 
        if (minWidthFilter === null)
            throw new Error("The parameter 'minWidthFilter' cannot be null.");
        else if (minWidthFilter !== undefined)
            url_ += "MinWidthFilter=" + encodeURIComponent("" + minWidthFilter) + "&"; 
        if (nameDescriptionFilter === null)
            throw new Error("The parameter 'nameDescriptionFilter' cannot be null.");
        else if (nameDescriptionFilter !== undefined)
            url_ += "NameDescriptionFilter=" + encodeURIComponent("" + nameDescriptionFilter) + "&"; 
        if (maxDepartmentIdFilter === null)
            throw new Error("The parameter 'maxDepartmentIdFilter' cannot be null.");
        else if (maxDepartmentIdFilter !== undefined)
            url_ += "MaxDepartmentIdFilter=" + encodeURIComponent("" + maxDepartmentIdFilter) + "&"; 
        if (minDepartmentIdFilter === null)
            throw new Error("The parameter 'minDepartmentIdFilter' cannot be null.");
        else if (minDepartmentIdFilter !== undefined)
            url_ += "MinDepartmentIdFilter=" + encodeURIComponent("" + minDepartmentIdFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (maxWidthDescriptionFilter === null)
            throw new Error("The parameter 'maxWidthDescriptionFilter' cannot be null.");
        else if (maxWidthDescriptionFilter !== undefined)
            url_ += "MaxWidthDescriptionFilter=" + encodeURIComponent("" + maxWidthDescriptionFilter) + "&"; 
        if (minWidthDescriptionFilter === null)
            throw new Error("The parameter 'minWidthDescriptionFilter' cannot be null.");
        else if (minWidthDescriptionFilter !== undefined)
            url_ += "MinWidthDescriptionFilter=" + encodeURIComponent("" + minWidthDescriptionFilter) + "&"; 
        if (classAttachFilter === null)
            throw new Error("The parameter 'classAttachFilter' cannot be null.");
        else if (classAttachFilter !== undefined)
            url_ += "ClassAttachFilter=" + encodeURIComponent("" + classAttachFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDynamicFieldForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDynamicFieldForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDynamicFieldForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetDynamicFieldForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetDynamicFieldForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDynamicFieldForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDynamicFieldForView(id: number | undefined): Observable<GetDynamicFieldForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicFields/GetDynamicFieldForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicFieldForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicFieldForView(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicFieldForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicFieldForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicFieldForView(response: HttpResponseBase): Observable<GetDynamicFieldForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDynamicFieldForViewDto.fromJS(resultData200) : new GetDynamicFieldForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicFieldForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDynamicFieldForEdit(id: number | undefined): Observable<GetDynamicFieldForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicFields/GetDynamicFieldForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicFieldForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicFieldForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicFieldForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicFieldForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicFieldForEdit(response: HttpResponseBase): Observable<GetDynamicFieldForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDynamicFieldForEditOutput.fromJS(resultData200) : new GetDynamicFieldForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicFieldForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDynamicFieldDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicFields/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicFields/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DynamicValuesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxObjectIdFilter (optional) 
     * @param minObjectIdFilter (optional) 
     * @param keyFilter (optional) 
     * @param maxDynamicFieldIdFilter (optional) 
     * @param minDynamicFieldIdFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param valueFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxObjectIdFilter: number | undefined, minObjectIdFilter: number | undefined, keyFilter: string | undefined, maxDynamicFieldIdFilter: number | undefined, minDynamicFieldIdFilter: number | undefined, isActiveFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, valueFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDynamicValueForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicValues/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxObjectIdFilter === null)
            throw new Error("The parameter 'maxObjectIdFilter' cannot be null.");
        else if (maxObjectIdFilter !== undefined)
            url_ += "MaxObjectIdFilter=" + encodeURIComponent("" + maxObjectIdFilter) + "&"; 
        if (minObjectIdFilter === null)
            throw new Error("The parameter 'minObjectIdFilter' cannot be null.");
        else if (minObjectIdFilter !== undefined)
            url_ += "MinObjectIdFilter=" + encodeURIComponent("" + minObjectIdFilter) + "&"; 
        if (keyFilter === null)
            throw new Error("The parameter 'keyFilter' cannot be null.");
        else if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (maxDynamicFieldIdFilter === null)
            throw new Error("The parameter 'maxDynamicFieldIdFilter' cannot be null.");
        else if (maxDynamicFieldIdFilter !== undefined)
            url_ += "MaxDynamicFieldIdFilter=" + encodeURIComponent("" + maxDynamicFieldIdFilter) + "&"; 
        if (minDynamicFieldIdFilter === null)
            throw new Error("The parameter 'minDynamicFieldIdFilter' cannot be null.");
        else if (minDynamicFieldIdFilter !== undefined)
            url_ += "MinDynamicFieldIdFilter=" + encodeURIComponent("" + minDynamicFieldIdFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (valueFilter === null)
            throw new Error("The parameter 'valueFilter' cannot be null.");
        else if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDynamicValueForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDynamicValueForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDynamicValueForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetDynamicValueForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetDynamicValueForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDynamicValueForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDynamicValueForView(id: number | undefined): Observable<GetDynamicValueForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicValues/GetDynamicValueForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicValueForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicValueForView(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicValueForView(response: HttpResponseBase): Observable<GetDynamicValueForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDynamicValueForViewDto.fromJS(resultData200) : new GetDynamicValueForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDynamicValueForEdit(id: number | undefined): Observable<GetDynamicValueForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicValues/GetDynamicValueForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicValueForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicValueForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDynamicValueForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDynamicValueForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicValueForEdit(response: HttpResponseBase): Observable<GetDynamicValueForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDynamicValueForEditOutput.fromJS(resultData200) : new GetDynamicValueForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDynamicValueForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDynamicValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicValues/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicValues/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEditionListDto.fromJS(resultData200) : new ListResultDtoOfEditionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEdition(body: CreateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEdition(body: UpdateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(body: MoveTenantsToAnotherEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | undefined, addAllItem: boolean | undefined, onlyFreeItems: boolean | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId === null)
            throw new Error("The parameter 'selectedEditionId' cannot be null.");
        else if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem === null)
            throw new Error("The parameter 'addAllItem' cannot be null.");
        else if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequest(body: CreateFriendshipRequestInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(body: CreateFriendshipRequestByUserNameInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blockUser(body: BlockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unblockUser(body: UnblockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptFriendshipRequest(body: AcceptFriendshipRequestInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HardDatasourcesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param valueFilter (optional) 
     * @param maxDynamicDatasourceIdFilter (optional) 
     * @param minDynamicDatasourceIdFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, keyFilter: string | undefined, valueFilter: string | undefined, maxDynamicDatasourceIdFilter: number | undefined, minDynamicDatasourceIdFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, isActiveFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetHardDatasourceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/HardDatasources/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter === null)
            throw new Error("The parameter 'keyFilter' cannot be null.");
        else if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (valueFilter === null)
            throw new Error("The parameter 'valueFilter' cannot be null.");
        else if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (maxDynamicDatasourceIdFilter === null)
            throw new Error("The parameter 'maxDynamicDatasourceIdFilter' cannot be null.");
        else if (maxDynamicDatasourceIdFilter !== undefined)
            url_ += "MaxDynamicDatasourceIdFilter=" + encodeURIComponent("" + maxDynamicDatasourceIdFilter) + "&"; 
        if (minDynamicDatasourceIdFilter === null)
            throw new Error("The parameter 'minDynamicDatasourceIdFilter' cannot be null.");
        else if (minDynamicDatasourceIdFilter !== undefined)
            url_ += "MinDynamicDatasourceIdFilter=" + encodeURIComponent("" + minDynamicDatasourceIdFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetHardDatasourceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetHardDatasourceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetHardDatasourceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetHardDatasourceForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetHardDatasourceForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetHardDatasourceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHardDatasourceForView(id: number | undefined): Observable<GetHardDatasourceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/HardDatasources/GetHardDatasourceForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHardDatasourceForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHardDatasourceForView(<any>response_);
                } catch (e) {
                    return <Observable<GetHardDatasourceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetHardDatasourceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHardDatasourceForView(response: HttpResponseBase): Observable<GetHardDatasourceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetHardDatasourceForViewDto.fromJS(resultData200) : new GetHardDatasourceForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetHardDatasourceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHardDatasourceForEdit(id: number | undefined): Observable<GetHardDatasourceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/HardDatasources/GetHardDatasourceForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHardDatasourceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHardDatasourceForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetHardDatasourceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetHardDatasourceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetHardDatasourceForEdit(response: HttpResponseBase): Observable<GetHardDatasourceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetHardDatasourceForEditOutput.fromJS(resultData200) : new GetHardDatasourceForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetHardDatasourceForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditHardDatasourceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HardDatasources/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HardDatasources/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param valueFilter (optional) 
     * @param maxDynamicDatasourceIdFilter (optional) 
     * @param minDynamicDatasourceIdFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param isActiveFilter (optional) 
     * @return Success
     */
    getHardDatasourcesToExcel(filter: string | undefined, keyFilter: string | undefined, valueFilter: string | undefined, maxDynamicDatasourceIdFilter: number | undefined, minDynamicDatasourceIdFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, isActiveFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/HardDatasources/GetHardDatasourcesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter === null)
            throw new Error("The parameter 'keyFilter' cannot be null.");
        else if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (valueFilter === null)
            throw new Error("The parameter 'valueFilter' cannot be null.");
        else if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (maxDynamicDatasourceIdFilter === null)
            throw new Error("The parameter 'maxDynamicDatasourceIdFilter' cannot be null.");
        else if (maxDynamicDatasourceIdFilter !== undefined)
            url_ += "MaxDynamicDatasourceIdFilter=" + encodeURIComponent("" + maxDynamicDatasourceIdFilter) + "&"; 
        if (minDynamicDatasourceIdFilter === null)
            throw new Error("The parameter 'minDynamicDatasourceIdFilter' cannot be null.");
        else if (minDynamicDatasourceIdFilter !== undefined)
            url_ += "MinDynamicDatasourceIdFilter=" + encodeURIComponent("" + minDynamicDatasourceIdFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHardDatasourcesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHardDatasourcesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHardDatasourcesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class HistoryUploadsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHistoryUploads(): Observable<GetDataAndColumnConfig_HistoryUploads> {
        let url_ = this.baseUrl + "/api/services/app/HistoryUploads/GetAllHistoryUploads";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHistoryUploads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHistoryUploads(<any>response_);
                } catch (e) {
                    return <Observable<GetDataAndColumnConfig_HistoryUploads>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDataAndColumnConfig_HistoryUploads>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHistoryUploads(response: HttpResponseBase): Observable<GetDataAndColumnConfig_HistoryUploads> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDataAndColumnConfig_HistoryUploads.fromJS(resultData200) : new GetDataAndColumnConfig_HistoryUploads();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDataAndColumnConfig_HistoryUploads>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param fileFilter (optional) 
     * @param maxVersionFilter (optional) 
     * @param minVersionFilter (optional) 
     * @param maxdocumentIDFilter (optional) 
     * @param mindocumentIDFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, fileFilter: string | undefined, maxVersionFilter: number | undefined, minVersionFilter: number | undefined, maxdocumentIDFilter: number | undefined, mindocumentIDFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetHistoryUploadForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/HistoryUploads/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (fileFilter === null)
            throw new Error("The parameter 'fileFilter' cannot be null.");
        else if (fileFilter !== undefined)
            url_ += "FileFilter=" + encodeURIComponent("" + fileFilter) + "&"; 
        if (maxVersionFilter === null)
            throw new Error("The parameter 'maxVersionFilter' cannot be null.");
        else if (maxVersionFilter !== undefined)
            url_ += "MaxVersionFilter=" + encodeURIComponent("" + maxVersionFilter) + "&"; 
        if (minVersionFilter === null)
            throw new Error("The parameter 'minVersionFilter' cannot be null.");
        else if (minVersionFilter !== undefined)
            url_ += "MinVersionFilter=" + encodeURIComponent("" + minVersionFilter) + "&"; 
        if (maxdocumentIDFilter === null)
            throw new Error("The parameter 'maxdocumentIDFilter' cannot be null.");
        else if (maxdocumentIDFilter !== undefined)
            url_ += "MaxdocumentIDFilter=" + encodeURIComponent("" + maxdocumentIDFilter) + "&"; 
        if (mindocumentIDFilter === null)
            throw new Error("The parameter 'mindocumentIDFilter' cannot be null.");
        else if (mindocumentIDFilter !== undefined)
            url_ += "MindocumentIDFilter=" + encodeURIComponent("" + mindocumentIDFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetHistoryUploadForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetHistoryUploadForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetHistoryUploadForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetHistoryUploadForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetHistoryUploadForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetHistoryUploadForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHistoryUploadForEdit(id: number | undefined): Observable<GetHistoryUploadForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/HistoryUploads/GetHistoryUploadForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistoryUploadForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistoryUploadForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetHistoryUploadForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetHistoryUploadForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetHistoryUploadForEdit(response: HttpResponseBase): Observable<GetHistoryUploadForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetHistoryUploadForEditOutput.fromJS(resultData200) : new GetHistoryUploadForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetHistoryUploadForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditHistoryUploadDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HistoryUploads/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HistoryUploads/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param documentID (optional) 
     * @return Success
     */
    getListAsyncById(documentID: number | undefined): Observable<HistoryUploadDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HistoryUploads/GetListAsyncById?";
        if (documentID === null)
            throw new Error("The parameter 'documentID' cannot be null.");
        else if (documentID !== undefined)
            url_ += "documentID=" + encodeURIComponent("" + documentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListAsyncById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListAsyncById(<any>response_);
                } catch (e) {
                    return <Observable<HistoryUploadDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HistoryUploadDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListAsyncById(response: HttpResponseBase): Observable<HistoryUploadDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HistoryUploadDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HistoryUploadDto[]>(<any>null);
    }

    /**
     * @param documentID (optional) 
     * @return Success
     */
    getList(documentID: number | undefined): Observable<HistoryUploadDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HistoryUploads/GetList?";
        if (documentID === null)
            throw new Error("The parameter 'documentID' cannot be null.");
        else if (documentID !== undefined)
            url_ += "documentID=" + encodeURIComponent("" + documentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<HistoryUploadDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HistoryUploadDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<HistoryUploadDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HistoryUploadDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HistoryUploadDto[]>(<any>null);
    }
}

@Injectable()
export class HopDongsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param hoTenNhanVienFilter (optional) 
     * @param viTriCongViecCodeFilter (optional) 
     * @param maxNgayKyFilter (optional) 
     * @param minNgayKyFilter (optional) 
     * @param maxDonViCongTacIDFilter (optional) 
     * @param minDonViCongTacIDFilter (optional) 
     * @param tenHopDongFilter (optional) 
     * @param loaiHopDongCodeFilter (optional) 
     * @param hinhThucLamViecCodeFilter (optional) 
     * @param maxNgayCoHieuLucFilter (optional) 
     * @param minNgayCoHieuLucFilter (optional) 
     * @param maxNgayHetHanFilter (optional) 
     * @param minNgayHetHanFilter (optional) 
     * @param maxLuongCoBanFilter (optional) 
     * @param minLuongCoBanFilter (optional) 
     * @param maxLuongDongBaoHiemFilter (optional) 
     * @param minLuongDongBaoHiemFilter (optional) 
     * @param chucDanhFilter (optional) 
     * @param trichYeuFilter (optional) 
     * @param rECORD_STATUSFilter (optional) 
     * @param maxMARKER_IDFilter (optional) 
     * @param minMARKER_IDFilter (optional) 
     * @param aUTH_STATUSFilter (optional) 
     * @param maxCHECKER_IDFilter (optional) 
     * @param minCHECKER_IDFilter (optional) 
     * @param maxAPPROVE_DTFilter (optional) 
     * @param minAPPROVE_DTFilter (optional) 
     * @param thoiHanHopDongFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, hoTenNhanVienFilter: string | undefined, viTriCongViecCodeFilter: string | undefined, maxNgayKyFilter: moment.Moment | undefined, minNgayKyFilter: moment.Moment | undefined, maxDonViCongTacIDFilter: number | undefined, minDonViCongTacIDFilter: number | undefined, tenHopDongFilter: string | undefined, loaiHopDongCodeFilter: string | undefined, hinhThucLamViecCodeFilter: string | undefined, maxNgayCoHieuLucFilter: moment.Moment | undefined, minNgayCoHieuLucFilter: moment.Moment | undefined, maxNgayHetHanFilter: moment.Moment | undefined, minNgayHetHanFilter: moment.Moment | undefined, maxLuongCoBanFilter: number | undefined, minLuongCoBanFilter: number | undefined, maxLuongDongBaoHiemFilter: number | undefined, minLuongDongBaoHiemFilter: number | undefined, chucDanhFilter: string | undefined, trichYeuFilter: string | undefined, rECORD_STATUSFilter: string | undefined, maxMARKER_IDFilter: number | undefined, minMARKER_IDFilter: number | undefined, aUTH_STATUSFilter: string | undefined, maxCHECKER_IDFilter: number | undefined, minCHECKER_IDFilter: number | undefined, maxAPPROVE_DTFilter: moment.Moment | undefined, minAPPROVE_DTFilter: moment.Moment | undefined, thoiHanHopDongFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetHopDongForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/HopDongs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (hoTenNhanVienFilter === null)
            throw new Error("The parameter 'hoTenNhanVienFilter' cannot be null.");
        else if (hoTenNhanVienFilter !== undefined)
            url_ += "HoTenNhanVienFilter=" + encodeURIComponent("" + hoTenNhanVienFilter) + "&"; 
        if (viTriCongViecCodeFilter === null)
            throw new Error("The parameter 'viTriCongViecCodeFilter' cannot be null.");
        else if (viTriCongViecCodeFilter !== undefined)
            url_ += "ViTriCongViecCodeFilter=" + encodeURIComponent("" + viTriCongViecCodeFilter) + "&"; 
        if (maxNgayKyFilter === null)
            throw new Error("The parameter 'maxNgayKyFilter' cannot be null.");
        else if (maxNgayKyFilter !== undefined)
            url_ += "MaxNgayKyFilter=" + encodeURIComponent(maxNgayKyFilter ? "" + maxNgayKyFilter.toJSON() : "") + "&"; 
        if (minNgayKyFilter === null)
            throw new Error("The parameter 'minNgayKyFilter' cannot be null.");
        else if (minNgayKyFilter !== undefined)
            url_ += "MinNgayKyFilter=" + encodeURIComponent(minNgayKyFilter ? "" + minNgayKyFilter.toJSON() : "") + "&"; 
        if (maxDonViCongTacIDFilter === null)
            throw new Error("The parameter 'maxDonViCongTacIDFilter' cannot be null.");
        else if (maxDonViCongTacIDFilter !== undefined)
            url_ += "MaxDonViCongTacIDFilter=" + encodeURIComponent("" + maxDonViCongTacIDFilter) + "&"; 
        if (minDonViCongTacIDFilter === null)
            throw new Error("The parameter 'minDonViCongTacIDFilter' cannot be null.");
        else if (minDonViCongTacIDFilter !== undefined)
            url_ += "MinDonViCongTacIDFilter=" + encodeURIComponent("" + minDonViCongTacIDFilter) + "&"; 
        if (tenHopDongFilter === null)
            throw new Error("The parameter 'tenHopDongFilter' cannot be null.");
        else if (tenHopDongFilter !== undefined)
            url_ += "TenHopDongFilter=" + encodeURIComponent("" + tenHopDongFilter) + "&"; 
        if (loaiHopDongCodeFilter === null)
            throw new Error("The parameter 'loaiHopDongCodeFilter' cannot be null.");
        else if (loaiHopDongCodeFilter !== undefined)
            url_ += "LoaiHopDongCodeFilter=" + encodeURIComponent("" + loaiHopDongCodeFilter) + "&"; 
        if (hinhThucLamViecCodeFilter === null)
            throw new Error("The parameter 'hinhThucLamViecCodeFilter' cannot be null.");
        else if (hinhThucLamViecCodeFilter !== undefined)
            url_ += "HinhThucLamViecCodeFilter=" + encodeURIComponent("" + hinhThucLamViecCodeFilter) + "&"; 
        if (maxNgayCoHieuLucFilter === null)
            throw new Error("The parameter 'maxNgayCoHieuLucFilter' cannot be null.");
        else if (maxNgayCoHieuLucFilter !== undefined)
            url_ += "MaxNgayCoHieuLucFilter=" + encodeURIComponent(maxNgayCoHieuLucFilter ? "" + maxNgayCoHieuLucFilter.toJSON() : "") + "&"; 
        if (minNgayCoHieuLucFilter === null)
            throw new Error("The parameter 'minNgayCoHieuLucFilter' cannot be null.");
        else if (minNgayCoHieuLucFilter !== undefined)
            url_ += "MinNgayCoHieuLucFilter=" + encodeURIComponent(minNgayCoHieuLucFilter ? "" + minNgayCoHieuLucFilter.toJSON() : "") + "&"; 
        if (maxNgayHetHanFilter === null)
            throw new Error("The parameter 'maxNgayHetHanFilter' cannot be null.");
        else if (maxNgayHetHanFilter !== undefined)
            url_ += "MaxNgayHetHanFilter=" + encodeURIComponent(maxNgayHetHanFilter ? "" + maxNgayHetHanFilter.toJSON() : "") + "&"; 
        if (minNgayHetHanFilter === null)
            throw new Error("The parameter 'minNgayHetHanFilter' cannot be null.");
        else if (minNgayHetHanFilter !== undefined)
            url_ += "MinNgayHetHanFilter=" + encodeURIComponent(minNgayHetHanFilter ? "" + minNgayHetHanFilter.toJSON() : "") + "&"; 
        if (maxLuongCoBanFilter === null)
            throw new Error("The parameter 'maxLuongCoBanFilter' cannot be null.");
        else if (maxLuongCoBanFilter !== undefined)
            url_ += "MaxLuongCoBanFilter=" + encodeURIComponent("" + maxLuongCoBanFilter) + "&"; 
        if (minLuongCoBanFilter === null)
            throw new Error("The parameter 'minLuongCoBanFilter' cannot be null.");
        else if (minLuongCoBanFilter !== undefined)
            url_ += "MinLuongCoBanFilter=" + encodeURIComponent("" + minLuongCoBanFilter) + "&"; 
        if (maxLuongDongBaoHiemFilter === null)
            throw new Error("The parameter 'maxLuongDongBaoHiemFilter' cannot be null.");
        else if (maxLuongDongBaoHiemFilter !== undefined)
            url_ += "MaxLuongDongBaoHiemFilter=" + encodeURIComponent("" + maxLuongDongBaoHiemFilter) + "&"; 
        if (minLuongDongBaoHiemFilter === null)
            throw new Error("The parameter 'minLuongDongBaoHiemFilter' cannot be null.");
        else if (minLuongDongBaoHiemFilter !== undefined)
            url_ += "MinLuongDongBaoHiemFilter=" + encodeURIComponent("" + minLuongDongBaoHiemFilter) + "&"; 
        if (chucDanhFilter === null)
            throw new Error("The parameter 'chucDanhFilter' cannot be null.");
        else if (chucDanhFilter !== undefined)
            url_ += "ChucDanhFilter=" + encodeURIComponent("" + chucDanhFilter) + "&"; 
        if (trichYeuFilter === null)
            throw new Error("The parameter 'trichYeuFilter' cannot be null.");
        else if (trichYeuFilter !== undefined)
            url_ += "TrichYeuFilter=" + encodeURIComponent("" + trichYeuFilter) + "&"; 
        if (rECORD_STATUSFilter === null)
            throw new Error("The parameter 'rECORD_STATUSFilter' cannot be null.");
        else if (rECORD_STATUSFilter !== undefined)
            url_ += "RECORD_STATUSFilter=" + encodeURIComponent("" + rECORD_STATUSFilter) + "&"; 
        if (maxMARKER_IDFilter === null)
            throw new Error("The parameter 'maxMARKER_IDFilter' cannot be null.");
        else if (maxMARKER_IDFilter !== undefined)
            url_ += "MaxMARKER_IDFilter=" + encodeURIComponent("" + maxMARKER_IDFilter) + "&"; 
        if (minMARKER_IDFilter === null)
            throw new Error("The parameter 'minMARKER_IDFilter' cannot be null.");
        else if (minMARKER_IDFilter !== undefined)
            url_ += "MinMARKER_IDFilter=" + encodeURIComponent("" + minMARKER_IDFilter) + "&"; 
        if (aUTH_STATUSFilter === null)
            throw new Error("The parameter 'aUTH_STATUSFilter' cannot be null.");
        else if (aUTH_STATUSFilter !== undefined)
            url_ += "AUTH_STATUSFilter=" + encodeURIComponent("" + aUTH_STATUSFilter) + "&"; 
        if (maxCHECKER_IDFilter === null)
            throw new Error("The parameter 'maxCHECKER_IDFilter' cannot be null.");
        else if (maxCHECKER_IDFilter !== undefined)
            url_ += "MaxCHECKER_IDFilter=" + encodeURIComponent("" + maxCHECKER_IDFilter) + "&"; 
        if (minCHECKER_IDFilter === null)
            throw new Error("The parameter 'minCHECKER_IDFilter' cannot be null.");
        else if (minCHECKER_IDFilter !== undefined)
            url_ += "MinCHECKER_IDFilter=" + encodeURIComponent("" + minCHECKER_IDFilter) + "&"; 
        if (maxAPPROVE_DTFilter === null)
            throw new Error("The parameter 'maxAPPROVE_DTFilter' cannot be null.");
        else if (maxAPPROVE_DTFilter !== undefined)
            url_ += "MaxAPPROVE_DTFilter=" + encodeURIComponent(maxAPPROVE_DTFilter ? "" + maxAPPROVE_DTFilter.toJSON() : "") + "&"; 
        if (minAPPROVE_DTFilter === null)
            throw new Error("The parameter 'minAPPROVE_DTFilter' cannot be null.");
        else if (minAPPROVE_DTFilter !== undefined)
            url_ += "MinAPPROVE_DTFilter=" + encodeURIComponent(minAPPROVE_DTFilter ? "" + minAPPROVE_DTFilter.toJSON() : "") + "&"; 
        if (thoiHanHopDongFilter === null)
            throw new Error("The parameter 'thoiHanHopDongFilter' cannot be null.");
        else if (thoiHanHopDongFilter !== undefined)
            url_ += "ThoiHanHopDongFilter=" + encodeURIComponent("" + thoiHanHopDongFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetHopDongForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetHopDongForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetHopDongForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetHopDongForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetHopDongForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetHopDongForViewDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllHopDong(): Observable<HopDongDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HopDongs/GetAllHopDong";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHopDong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHopDong(<any>response_);
                } catch (e) {
                    return <Observable<HopDongDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HopDongDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHopDong(response: HttpResponseBase): Observable<HopDongDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HopDongDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HopDongDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHDForEdit(id: number | undefined): Observable<CreateOrEditHopDongDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HopDongs/GetHDForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHDForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHDForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditHopDongDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditHopDongDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHDForEdit(response: HttpResponseBase): Observable<CreateOrEditHopDongDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CreateOrEditHopDongDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditHopDongDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getListItemSearch(): Observable<GetHopDongForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/HopDongs/GetListItemSearch";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListItemSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListItemSearch(<any>response_);
                } catch (e) {
                    return <Observable<GetHopDongForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetHopDongForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetListItemSearch(response: HttpResponseBase): Observable<GetHopDongForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetHopDongForEditOutput.fromJS(resultData200) : new GetHopDongForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetHopDongForEditOutput>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getInFoLHD(name: string | undefined): Observable<TruongGiaoDichDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HopDongs/GetInFoLHD?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInFoLHD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInFoLHD(<any>response_);
                } catch (e) {
                    return <Observable<TruongGiaoDichDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TruongGiaoDichDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInFoLHD(response: HttpResponseBase): Observable<TruongGiaoDichDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TruongGiaoDichDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TruongGiaoDichDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHopDongForView(id: number | undefined): Observable<GetHopDongForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/HopDongs/GetHopDongForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHopDongForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHopDongForView(<any>response_);
                } catch (e) {
                    return <Observable<GetHopDongForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetHopDongForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHopDongForView(response: HttpResponseBase): Observable<GetHopDongForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetHopDongForViewDto.fromJS(resultData200) : new GetHopDongForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetHopDongForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHopDongForEdit(id: number | undefined): Observable<GetHopDongForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/HopDongs/GetHopDongForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHopDongForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHopDongForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetHopDongForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetHopDongForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetHopDongForEdit(response: HttpResponseBase): Observable<GetHopDongForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetHopDongForEditOutput.fromJS(resultData200) : new GetHopDongForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetHopDongForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditHopDongInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/HopDongs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HopDongs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param hoTenNhanVienFilter (optional) 
     * @param viTriCongViecCodeFilter (optional) 
     * @param maxNgayKyFilter (optional) 
     * @param minNgayKyFilter (optional) 
     * @param maxDonViCongTacIDFilter (optional) 
     * @param minDonViCongTacIDFilter (optional) 
     * @param tenHopDongFilter (optional) 
     * @param loaiHopDongCodeFilter (optional) 
     * @param hinhThucLamViecCodeFilter (optional) 
     * @param maxNgayCoHieuLucFilter (optional) 
     * @param minNgayCoHieuLucFilter (optional) 
     * @param maxNgayHetHanFilter (optional) 
     * @param minNgayHetHanFilter (optional) 
     * @param maxLuongCoBanFilter (optional) 
     * @param minLuongCoBanFilter (optional) 
     * @param maxLuongDongBaoHiemFilter (optional) 
     * @param minLuongDongBaoHiemFilter (optional) 
     * @param chucDanhFilter (optional) 
     * @param trichYeuFilter (optional) 
     * @param rECORD_STATUSFilter (optional) 
     * @param maxMARKER_IDFilter (optional) 
     * @param minMARKER_IDFilter (optional) 
     * @param aUTH_STATUSFilter (optional) 
     * @param maxCHECKER_IDFilter (optional) 
     * @param minCHECKER_IDFilter (optional) 
     * @param maxAPPROVE_DTFilter (optional) 
     * @param minAPPROVE_DTFilter (optional) 
     * @param thoiHanHopDongFilter (optional) 
     * @return Success
     */
    getHopDongsToExcel(filter: string | undefined, hoTenNhanVienFilter: string | undefined, viTriCongViecCodeFilter: string | undefined, maxNgayKyFilter: moment.Moment | undefined, minNgayKyFilter: moment.Moment | undefined, maxDonViCongTacIDFilter: number | undefined, minDonViCongTacIDFilter: number | undefined, tenHopDongFilter: string | undefined, loaiHopDongCodeFilter: string | undefined, hinhThucLamViecCodeFilter: string | undefined, maxNgayCoHieuLucFilter: moment.Moment | undefined, minNgayCoHieuLucFilter: moment.Moment | undefined, maxNgayHetHanFilter: moment.Moment | undefined, minNgayHetHanFilter: moment.Moment | undefined, maxLuongCoBanFilter: number | undefined, minLuongCoBanFilter: number | undefined, maxLuongDongBaoHiemFilter: number | undefined, minLuongDongBaoHiemFilter: number | undefined, chucDanhFilter: string | undefined, trichYeuFilter: string | undefined, rECORD_STATUSFilter: string | undefined, maxMARKER_IDFilter: number | undefined, minMARKER_IDFilter: number | undefined, aUTH_STATUSFilter: string | undefined, maxCHECKER_IDFilter: number | undefined, minCHECKER_IDFilter: number | undefined, maxAPPROVE_DTFilter: moment.Moment | undefined, minAPPROVE_DTFilter: moment.Moment | undefined, thoiHanHopDongFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/HopDongs/GetHopDongsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (hoTenNhanVienFilter === null)
            throw new Error("The parameter 'hoTenNhanVienFilter' cannot be null.");
        else if (hoTenNhanVienFilter !== undefined)
            url_ += "HoTenNhanVienFilter=" + encodeURIComponent("" + hoTenNhanVienFilter) + "&"; 
        if (viTriCongViecCodeFilter === null)
            throw new Error("The parameter 'viTriCongViecCodeFilter' cannot be null.");
        else if (viTriCongViecCodeFilter !== undefined)
            url_ += "ViTriCongViecCodeFilter=" + encodeURIComponent("" + viTriCongViecCodeFilter) + "&"; 
        if (maxNgayKyFilter === null)
            throw new Error("The parameter 'maxNgayKyFilter' cannot be null.");
        else if (maxNgayKyFilter !== undefined)
            url_ += "MaxNgayKyFilter=" + encodeURIComponent(maxNgayKyFilter ? "" + maxNgayKyFilter.toJSON() : "") + "&"; 
        if (minNgayKyFilter === null)
            throw new Error("The parameter 'minNgayKyFilter' cannot be null.");
        else if (minNgayKyFilter !== undefined)
            url_ += "MinNgayKyFilter=" + encodeURIComponent(minNgayKyFilter ? "" + minNgayKyFilter.toJSON() : "") + "&"; 
        if (maxDonViCongTacIDFilter === null)
            throw new Error("The parameter 'maxDonViCongTacIDFilter' cannot be null.");
        else if (maxDonViCongTacIDFilter !== undefined)
            url_ += "MaxDonViCongTacIDFilter=" + encodeURIComponent("" + maxDonViCongTacIDFilter) + "&"; 
        if (minDonViCongTacIDFilter === null)
            throw new Error("The parameter 'minDonViCongTacIDFilter' cannot be null.");
        else if (minDonViCongTacIDFilter !== undefined)
            url_ += "MinDonViCongTacIDFilter=" + encodeURIComponent("" + minDonViCongTacIDFilter) + "&"; 
        if (tenHopDongFilter === null)
            throw new Error("The parameter 'tenHopDongFilter' cannot be null.");
        else if (tenHopDongFilter !== undefined)
            url_ += "TenHopDongFilter=" + encodeURIComponent("" + tenHopDongFilter) + "&"; 
        if (loaiHopDongCodeFilter === null)
            throw new Error("The parameter 'loaiHopDongCodeFilter' cannot be null.");
        else if (loaiHopDongCodeFilter !== undefined)
            url_ += "LoaiHopDongCodeFilter=" + encodeURIComponent("" + loaiHopDongCodeFilter) + "&"; 
        if (hinhThucLamViecCodeFilter === null)
            throw new Error("The parameter 'hinhThucLamViecCodeFilter' cannot be null.");
        else if (hinhThucLamViecCodeFilter !== undefined)
            url_ += "HinhThucLamViecCodeFilter=" + encodeURIComponent("" + hinhThucLamViecCodeFilter) + "&"; 
        if (maxNgayCoHieuLucFilter === null)
            throw new Error("The parameter 'maxNgayCoHieuLucFilter' cannot be null.");
        else if (maxNgayCoHieuLucFilter !== undefined)
            url_ += "MaxNgayCoHieuLucFilter=" + encodeURIComponent(maxNgayCoHieuLucFilter ? "" + maxNgayCoHieuLucFilter.toJSON() : "") + "&"; 
        if (minNgayCoHieuLucFilter === null)
            throw new Error("The parameter 'minNgayCoHieuLucFilter' cannot be null.");
        else if (minNgayCoHieuLucFilter !== undefined)
            url_ += "MinNgayCoHieuLucFilter=" + encodeURIComponent(minNgayCoHieuLucFilter ? "" + minNgayCoHieuLucFilter.toJSON() : "") + "&"; 
        if (maxNgayHetHanFilter === null)
            throw new Error("The parameter 'maxNgayHetHanFilter' cannot be null.");
        else if (maxNgayHetHanFilter !== undefined)
            url_ += "MaxNgayHetHanFilter=" + encodeURIComponent(maxNgayHetHanFilter ? "" + maxNgayHetHanFilter.toJSON() : "") + "&"; 
        if (minNgayHetHanFilter === null)
            throw new Error("The parameter 'minNgayHetHanFilter' cannot be null.");
        else if (minNgayHetHanFilter !== undefined)
            url_ += "MinNgayHetHanFilter=" + encodeURIComponent(minNgayHetHanFilter ? "" + minNgayHetHanFilter.toJSON() : "") + "&"; 
        if (maxLuongCoBanFilter === null)
            throw new Error("The parameter 'maxLuongCoBanFilter' cannot be null.");
        else if (maxLuongCoBanFilter !== undefined)
            url_ += "MaxLuongCoBanFilter=" + encodeURIComponent("" + maxLuongCoBanFilter) + "&"; 
        if (minLuongCoBanFilter === null)
            throw new Error("The parameter 'minLuongCoBanFilter' cannot be null.");
        else if (minLuongCoBanFilter !== undefined)
            url_ += "MinLuongCoBanFilter=" + encodeURIComponent("" + minLuongCoBanFilter) + "&"; 
        if (maxLuongDongBaoHiemFilter === null)
            throw new Error("The parameter 'maxLuongDongBaoHiemFilter' cannot be null.");
        else if (maxLuongDongBaoHiemFilter !== undefined)
            url_ += "MaxLuongDongBaoHiemFilter=" + encodeURIComponent("" + maxLuongDongBaoHiemFilter) + "&"; 
        if (minLuongDongBaoHiemFilter === null)
            throw new Error("The parameter 'minLuongDongBaoHiemFilter' cannot be null.");
        else if (minLuongDongBaoHiemFilter !== undefined)
            url_ += "MinLuongDongBaoHiemFilter=" + encodeURIComponent("" + minLuongDongBaoHiemFilter) + "&"; 
        if (chucDanhFilter === null)
            throw new Error("The parameter 'chucDanhFilter' cannot be null.");
        else if (chucDanhFilter !== undefined)
            url_ += "ChucDanhFilter=" + encodeURIComponent("" + chucDanhFilter) + "&"; 
        if (trichYeuFilter === null)
            throw new Error("The parameter 'trichYeuFilter' cannot be null.");
        else if (trichYeuFilter !== undefined)
            url_ += "TrichYeuFilter=" + encodeURIComponent("" + trichYeuFilter) + "&"; 
        if (rECORD_STATUSFilter === null)
            throw new Error("The parameter 'rECORD_STATUSFilter' cannot be null.");
        else if (rECORD_STATUSFilter !== undefined)
            url_ += "RECORD_STATUSFilter=" + encodeURIComponent("" + rECORD_STATUSFilter) + "&"; 
        if (maxMARKER_IDFilter === null)
            throw new Error("The parameter 'maxMARKER_IDFilter' cannot be null.");
        else if (maxMARKER_IDFilter !== undefined)
            url_ += "MaxMARKER_IDFilter=" + encodeURIComponent("" + maxMARKER_IDFilter) + "&"; 
        if (minMARKER_IDFilter === null)
            throw new Error("The parameter 'minMARKER_IDFilter' cannot be null.");
        else if (minMARKER_IDFilter !== undefined)
            url_ += "MinMARKER_IDFilter=" + encodeURIComponent("" + minMARKER_IDFilter) + "&"; 
        if (aUTH_STATUSFilter === null)
            throw new Error("The parameter 'aUTH_STATUSFilter' cannot be null.");
        else if (aUTH_STATUSFilter !== undefined)
            url_ += "AUTH_STATUSFilter=" + encodeURIComponent("" + aUTH_STATUSFilter) + "&"; 
        if (maxCHECKER_IDFilter === null)
            throw new Error("The parameter 'maxCHECKER_IDFilter' cannot be null.");
        else if (maxCHECKER_IDFilter !== undefined)
            url_ += "MaxCHECKER_IDFilter=" + encodeURIComponent("" + maxCHECKER_IDFilter) + "&"; 
        if (minCHECKER_IDFilter === null)
            throw new Error("The parameter 'minCHECKER_IDFilter' cannot be null.");
        else if (minCHECKER_IDFilter !== undefined)
            url_ += "MinCHECKER_IDFilter=" + encodeURIComponent("" + minCHECKER_IDFilter) + "&"; 
        if (maxAPPROVE_DTFilter === null)
            throw new Error("The parameter 'maxAPPROVE_DTFilter' cannot be null.");
        else if (maxAPPROVE_DTFilter !== undefined)
            url_ += "MaxAPPROVE_DTFilter=" + encodeURIComponent(maxAPPROVE_DTFilter ? "" + maxAPPROVE_DTFilter.toJSON() : "") + "&"; 
        if (minAPPROVE_DTFilter === null)
            throw new Error("The parameter 'minAPPROVE_DTFilter' cannot be null.");
        else if (minAPPROVE_DTFilter !== undefined)
            url_ += "MinAPPROVE_DTFilter=" + encodeURIComponent(minAPPROVE_DTFilter ? "" + minAPPROVE_DTFilter.toJSON() : "") + "&"; 
        if (thoiHanHopDongFilter === null)
            throw new Error("The parameter 'thoiHanHopDongFilter' cannot be null.");
        else if (thoiHanHopDongFilter !== undefined)
            url_ += "ThoiHanHopDongFilter=" + encodeURIComponent("" + thoiHanHopDongFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHopDongsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHopDongsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHopDongsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class HoSosServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHoSoForViewNghiPhep(id: string | undefined): Observable<HoSoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetHoSoForViewNghiPhep?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHoSoForViewNghiPhep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHoSoForViewNghiPhep(<any>response_);
                } catch (e) {
                    return <Observable<HoSoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HoSoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHoSoForViewNghiPhep(response: HttpResponseBase): Observable<HoSoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HoSoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HoSoDto[]>(<any>null);
    }

    /**
     * @param cmnd (optional) 
     * @return Success
     */
    checkCMND(cmnd: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/CheckCMND?";
        if (cmnd === null)
            throw new Error("The parameter 'cmnd' cannot be null.");
        else if (cmnd !== undefined)
            url_ += "cmnd=" + encodeURIComponent("" + cmnd) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCMND(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCMND(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckCMND(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCMND(): Observable<HoSoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetAllCMND";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCMND(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCMND(<any>response_);
                } catch (e) {
                    return <Observable<HoSoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HoSoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCMND(response: HttpResponseBase): Observable<HoSoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HoSoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HoSoDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCMND1(): Observable<OrganizationUnit[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetAllCMND1";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCMND1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCMND1(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnit[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnit[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCMND1(response: HttpResponseBase): Observable<OrganizationUnit[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationUnit.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnit[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUnit(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetAllUnit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUnit(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUnit(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPB(): Observable<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetAllPB";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPB(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPB(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPB(response: HttpResponseBase): Observable<OrganizationUnitDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationUnitDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto[]>(<any>null);
    }

    /**
     * @param tenCty (optional) 
     * @return Success
     */
    getListNhanVienToCty(tenCty: string | undefined): Observable<CreateOrEditHoSoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetListNhanVienToCty?";
        if (tenCty === null)
            throw new Error("The parameter 'tenCty' cannot be null.");
        else if (tenCty !== undefined)
            url_ += "TenCty=" + encodeURIComponent("" + tenCty) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListNhanVienToCty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListNhanVienToCty(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditHoSoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditHoSoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListNhanVienToCty(response: HttpResponseBase): Observable<CreateOrEditHoSoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CreateOrEditHoSoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditHoSoDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTHHD(): Observable<TruongGiaoDichDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetAllTHHD";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTHHD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTHHD(<any>response_);
                } catch (e) {
                    return <Observable<TruongGiaoDichDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TruongGiaoDichDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTHHD(response: HttpResponseBase): Observable<TruongGiaoDichDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TruongGiaoDichDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TruongGiaoDichDto[]>(<any>null);
    }

    /**
     * @param parentID (optional) 
     * @return Success
     */
    getAllCongViec(parentID: number | undefined): Observable<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetAllCongViec?";
        if (parentID === null)
            throw new Error("The parameter 'parentID' cannot be null.");
        else if (parentID !== undefined)
            url_ += "parentID=" + encodeURIComponent("" + parentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCongViec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCongViec(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCongViec(response: HttpResponseBase): Observable<OrganizationUnitDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationUnitDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto[]>(<any>null);
    }

    /**
     * @param phongbanID (optional) 
     * @param phongbanGD (optional) 
     * @return Success
     */
    getAllUserPhongBan(phongbanID: number | undefined, phongbanGD: number | undefined): Observable<HoSoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetAllUserPhongBan?";
        if (phongbanID === null)
            throw new Error("The parameter 'phongbanID' cannot be null.");
        else if (phongbanID !== undefined)
            url_ += "phongbanID=" + encodeURIComponent("" + phongbanID) + "&"; 
        if (phongbanGD === null)
            throw new Error("The parameter 'phongbanGD' cannot be null.");
        else if (phongbanGD !== undefined)
            url_ += "phongbanGD=" + encodeURIComponent("" + phongbanGD) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserPhongBan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserPhongBan(<any>response_);
                } catch (e) {
                    return <Observable<HoSoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HoSoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserPhongBan(response: HttpResponseBase): Observable<HoSoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HoSoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HoSoDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllHoSo(): Observable<HoSoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetAllHoSo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHoSo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHoSo(<any>response_);
                } catch (e) {
                    return <Observable<HoSoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HoSoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHoSo(response: HttpResponseBase): Observable<HoSoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HoSoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HoSoDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenCtyFilter (optional) 
     * @param hopDongHienTaiFilter (optional) 
     * @param soHDFilter (optional) 
     * @param donViCongTacNameFilter (optional) 
     * @param choNgoiFilter (optional) 
     * @param maxNoiDaoTaoIDFilter (optional) 
     * @param minNoiDaoTaoIDFilter (optional) 
     * @param maxLoaiHopDongIDFilter (optional) 
     * @param minLoaiHopDongIDFilter (optional) 
     * @param maSoNoiKCBFilter (optional) 
     * @param maxNoiDangKyKCBIDFilter (optional) 
     * @param minNoiDangKyKCBIDFilter (optional) 
     * @param maxNgayHetHanBHYTFilter (optional) 
     * @param minNgayHetHanBHYTFilter (optional) 
     * @param soTheBHYTFilter (optional) 
     * @param maTinhCapFilter (optional) 
     * @param maSoBHXHFilter (optional) 
     * @param soSoBHXHFilter (optional) 
     * @param maxTyLeDongBHFilter (optional) 
     * @param minTyLeDongBHFilter (optional) 
     * @param maxNgayThamGiaBHFilter (optional) 
     * @param minNgayThamGiaBHFilter (optional) 
     * @param thamGiaCongDoanFilter (optional) 
     * @param nganHangCodeFilter (optional) 
     * @param tkNganHangFilter (optional) 
     * @param donViSoCongChuanCodeFilter (optional) 
     * @param soCongChuanFilter (optional) 
     * @param luongDongBHFilter (optional) 
     * @param luongCoBanFilter (optional) 
     * @param bacLuongCodeFilter (optional) 
     * @param maxSoNgayPhepFilter (optional) 
     * @param minSoNgayPhepFilter (optional) 
     * @param maxNgayChinhThucFilter (optional) 
     * @param minNgayChinhThucFilter (optional) 
     * @param maxNgayThuViecFilter (optional) 
     * @param minNgayThuViecFilter (optional) 
     * @param maxNgayTapSuFilter (optional) 
     * @param minNgayTapSuFilter (optional) 
     * @param soSoQLLaoDongFilter (optional) 
     * @param diaDiemLamViecCodeFilter (optional) 
     * @param quanLyGianTiepFilter (optional) 
     * @param quanLyTrucTiepFilter (optional) 
     * @param trangThaiLamViecCodeFilter (optional) 
     * @param bacFilter (optional) 
     * @param capFilter (optional) 
     * @param chucDanhFilter (optional) 
     * @param maChamCongFilter (optional) 
     * @param diaChiLHKCFilter (optional) 
     * @param emailLHKCFilter (optional) 
     * @param dtDiDongLHKCFilter (optional) 
     * @param dtNhaRiengLHKCFilter (optional) 
     * @param quanHeLHKCFilter (optional) 
     * @param hoVaTenLHKCFilter (optional) 
     * @param diaChiHNFilter (optional) 
     * @param maxTinhThanhIDHNFilter (optional) 
     * @param minTinhThanhIDHNFilter (optional) 
     * @param quocGiaHNFilter (optional) 
     * @param laChuHoFilter (optional) 
     * @param maSoHoGiaDinhFilter (optional) 
     * @param soSoHoKhauFilter (optional) 
     * @param diaChiHKTTFilter (optional) 
     * @param maxTinhThanhIDHKTTFilter (optional) 
     * @param minTinhThanhIDHKTTFilter (optional) 
     * @param quocGiaHKTTFilter (optional) 
     * @param facebookFilter (optional) 
     * @param skypeFilter (optional) 
     * @param noiSinhFilter (optional) 
     * @param maxTinhThanhIDFilter (optional) 
     * @param minTinhThanhIDFilter (optional) 
     * @param nguyenQuanFilter (optional) 
     * @param emailKhacFilter (optional) 
     * @param emailCoQuanFilter (optional) 
     * @param emailCaNhanFilter (optional) 
     * @param dtKhacFilter (optional) 
     * @param dtNhaRiengFilter (optional) 
     * @param dtCoQuanFilter (optional) 
     * @param dtDiDongFilter (optional) 
     * @param tepDinhKemFilter (optional) 
     * @param tinhTrangHonNhanCodeFilter (optional) 
     * @param xepLoaiCodeFilter (optional) 
     * @param maxNamTotNghiepFilter (optional) 
     * @param minNamTotNghiepFilter (optional) 
     * @param chuyenNganhFilter (optional) 
     * @param khoaFilter (optional) 
     * @param trinhDoDaoTaoCodeFilter (optional) 
     * @param trinhDoVanHoaFilter (optional) 
     * @param maxNgayHetHanFilter (optional) 
     * @param minNgayHetHanFilter (optional) 
     * @param noiCapFilter (optional) 
     * @param maxNgayCapFilter (optional) 
     * @param minNgayCapFilter (optional) 
     * @param soCMNDFilter (optional) 
     * @param quocTichFilter (optional) 
     * @param tonGiaoFilter (optional) 
     * @param danTocFilter (optional) 
     * @param viTriCongViecCodeFilter (optional) 
     * @param maxDonViCongTacIDFilter (optional) 
     * @param minDonViCongTacIDFilter (optional) 
     * @param mSTCaNhanFilter (optional) 
     * @param maxNgaySinhFilter (optional) 
     * @param minNgaySinhFilter (optional) 
     * @param gioiTinhCodeFilter (optional) 
     * @param anhDaiDienFilter (optional) 
     * @param hoVaTenFilter (optional) 
     * @param maNhanVienFilter (optional) 
     * @param chiNhanhFilter (optional) 
     * @param dVTFilter (optional) 
     * @param maxNgayKyHDKTHFilter (optional) 
     * @param minNgayKyHDKTHFilter (optional) 
     * @param maxNgayKyHD36THFilter (optional) 
     * @param minNgayKyHD36THFilter (optional) 
     * @param maxNgayKyHD12THFilter (optional) 
     * @param minNgayKyHD12THFilter (optional) 
     * @param maxNgayKyHDTVFilter (optional) 
     * @param minNgayKyHDTVFilter (optional) 
     * @param maxNgayKYHDCTVFilter (optional) 
     * @param minNgayKYHDCTVFilter (optional) 
     * @param maxNgayKyHDKVFilter (optional) 
     * @param minNgayKyHDKVFilter (optional) 
     * @param maxNgayKYHDTTFilter (optional) 
     * @param minNgayKYHDTTFilter (optional) 
     * @param maxNgayKyHDFilter (optional) 
     * @param minNgayKyHDFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, tenCtyFilter: string | undefined, hopDongHienTaiFilter: string | undefined, soHDFilter: string | undefined, donViCongTacNameFilter: string | undefined, choNgoiFilter: string | undefined, maxNoiDaoTaoIDFilter: number | undefined, minNoiDaoTaoIDFilter: number | undefined, maxLoaiHopDongIDFilter: number | undefined, minLoaiHopDongIDFilter: number | undefined, maSoNoiKCBFilter: string | undefined, maxNoiDangKyKCBIDFilter: number | undefined, minNoiDangKyKCBIDFilter: number | undefined, maxNgayHetHanBHYTFilter: moment.Moment | undefined, minNgayHetHanBHYTFilter: moment.Moment | undefined, soTheBHYTFilter: string | undefined, maTinhCapFilter: string | undefined, maSoBHXHFilter: string | undefined, soSoBHXHFilter: string | undefined, maxTyLeDongBHFilter: number | undefined, minTyLeDongBHFilter: number | undefined, maxNgayThamGiaBHFilter: moment.Moment | undefined, minNgayThamGiaBHFilter: moment.Moment | undefined, thamGiaCongDoanFilter: number | undefined, nganHangCodeFilter: string | undefined, tkNganHangFilter: string | undefined, donViSoCongChuanCodeFilter: string | undefined, soCongChuanFilter: string | undefined, luongDongBHFilter: string | undefined, luongCoBanFilter: string | undefined, bacLuongCodeFilter: string | undefined, maxSoNgayPhepFilter: number | undefined, minSoNgayPhepFilter: number | undefined, maxNgayChinhThucFilter: moment.Moment | undefined, minNgayChinhThucFilter: moment.Moment | undefined, maxNgayThuViecFilter: moment.Moment | undefined, minNgayThuViecFilter: moment.Moment | undefined, maxNgayTapSuFilter: moment.Moment | undefined, minNgayTapSuFilter: moment.Moment | undefined, soSoQLLaoDongFilter: string | undefined, diaDiemLamViecCodeFilter: string | undefined, quanLyGianTiepFilter: string | undefined, quanLyTrucTiepFilter: string | undefined, trangThaiLamViecCodeFilter: string | undefined, bacFilter: string | undefined, capFilter: string | undefined, chucDanhFilter: string | undefined, maChamCongFilter: string | undefined, diaChiLHKCFilter: string | undefined, emailLHKCFilter: string | undefined, dtDiDongLHKCFilter: string | undefined, dtNhaRiengLHKCFilter: string | undefined, quanHeLHKCFilter: string | undefined, hoVaTenLHKCFilter: string | undefined, diaChiHNFilter: string | undefined, maxTinhThanhIDHNFilter: number | undefined, minTinhThanhIDHNFilter: number | undefined, quocGiaHNFilter: string | undefined, laChuHoFilter: number | undefined, maSoHoGiaDinhFilter: string | undefined, soSoHoKhauFilter: string | undefined, diaChiHKTTFilter: string | undefined, maxTinhThanhIDHKTTFilter: number | undefined, minTinhThanhIDHKTTFilter: number | undefined, quocGiaHKTTFilter: string | undefined, facebookFilter: string | undefined, skypeFilter: string | undefined, noiSinhFilter: string | undefined, maxTinhThanhIDFilter: number | undefined, minTinhThanhIDFilter: number | undefined, nguyenQuanFilter: string | undefined, emailKhacFilter: string | undefined, emailCoQuanFilter: string | undefined, emailCaNhanFilter: string | undefined, dtKhacFilter: string | undefined, dtNhaRiengFilter: string | undefined, dtCoQuanFilter: string | undefined, dtDiDongFilter: string | undefined, tepDinhKemFilter: string | undefined, tinhTrangHonNhanCodeFilter: string | undefined, xepLoaiCodeFilter: string | undefined, maxNamTotNghiepFilter: number | undefined, minNamTotNghiepFilter: number | undefined, chuyenNganhFilter: string | undefined, khoaFilter: string | undefined, trinhDoDaoTaoCodeFilter: string | undefined, trinhDoVanHoaFilter: string | undefined, maxNgayHetHanFilter: moment.Moment | undefined, minNgayHetHanFilter: moment.Moment | undefined, noiCapFilter: string | undefined, maxNgayCapFilter: moment.Moment | undefined, minNgayCapFilter: moment.Moment | undefined, soCMNDFilter: string | undefined, quocTichFilter: string | undefined, tonGiaoFilter: string | undefined, danTocFilter: string | undefined, viTriCongViecCodeFilter: string | undefined, maxDonViCongTacIDFilter: number | undefined, minDonViCongTacIDFilter: number | undefined, mSTCaNhanFilter: string | undefined, maxNgaySinhFilter: moment.Moment | undefined, minNgaySinhFilter: moment.Moment | undefined, gioiTinhCodeFilter: string | undefined, anhDaiDienFilter: string | undefined, hoVaTenFilter: string | undefined, maNhanVienFilter: string | undefined, chiNhanhFilter: string | undefined, dVTFilter: string | undefined, maxNgayKyHDKTHFilter: moment.Moment | undefined, minNgayKyHDKTHFilter: moment.Moment | undefined, maxNgayKyHD36THFilter: moment.Moment | undefined, minNgayKyHD36THFilter: moment.Moment | undefined, maxNgayKyHD12THFilter: moment.Moment | undefined, minNgayKyHD12THFilter: moment.Moment | undefined, maxNgayKyHDTVFilter: moment.Moment | undefined, minNgayKyHDTVFilter: moment.Moment | undefined, maxNgayKYHDCTVFilter: moment.Moment | undefined, minNgayKYHDCTVFilter: moment.Moment | undefined, maxNgayKyHDKVFilter: moment.Moment | undefined, minNgayKyHDKVFilter: moment.Moment | undefined, maxNgayKYHDTTFilter: moment.Moment | undefined, minNgayKYHDTTFilter: moment.Moment | undefined, maxNgayKyHDFilter: moment.Moment | undefined, minNgayKyHDFilter: moment.Moment | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetHoSoForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenCtyFilter === null)
            throw new Error("The parameter 'tenCtyFilter' cannot be null.");
        else if (tenCtyFilter !== undefined)
            url_ += "TenCtyFilter=" + encodeURIComponent("" + tenCtyFilter) + "&"; 
        if (hopDongHienTaiFilter === null)
            throw new Error("The parameter 'hopDongHienTaiFilter' cannot be null.");
        else if (hopDongHienTaiFilter !== undefined)
            url_ += "HopDongHienTaiFilter=" + encodeURIComponent("" + hopDongHienTaiFilter) + "&"; 
        if (soHDFilter === null)
            throw new Error("The parameter 'soHDFilter' cannot be null.");
        else if (soHDFilter !== undefined)
            url_ += "SoHDFilter=" + encodeURIComponent("" + soHDFilter) + "&"; 
        if (donViCongTacNameFilter === null)
            throw new Error("The parameter 'donViCongTacNameFilter' cannot be null.");
        else if (donViCongTacNameFilter !== undefined)
            url_ += "DonViCongTacNameFilter=" + encodeURIComponent("" + donViCongTacNameFilter) + "&"; 
        if (choNgoiFilter === null)
            throw new Error("The parameter 'choNgoiFilter' cannot be null.");
        else if (choNgoiFilter !== undefined)
            url_ += "ChoNgoiFilter=" + encodeURIComponent("" + choNgoiFilter) + "&"; 
        if (maxNoiDaoTaoIDFilter === null)
            throw new Error("The parameter 'maxNoiDaoTaoIDFilter' cannot be null.");
        else if (maxNoiDaoTaoIDFilter !== undefined)
            url_ += "MaxNoiDaoTaoIDFilter=" + encodeURIComponent("" + maxNoiDaoTaoIDFilter) + "&"; 
        if (minNoiDaoTaoIDFilter === null)
            throw new Error("The parameter 'minNoiDaoTaoIDFilter' cannot be null.");
        else if (minNoiDaoTaoIDFilter !== undefined)
            url_ += "MinNoiDaoTaoIDFilter=" + encodeURIComponent("" + minNoiDaoTaoIDFilter) + "&"; 
        if (maxLoaiHopDongIDFilter === null)
            throw new Error("The parameter 'maxLoaiHopDongIDFilter' cannot be null.");
        else if (maxLoaiHopDongIDFilter !== undefined)
            url_ += "MaxLoaiHopDongIDFilter=" + encodeURIComponent("" + maxLoaiHopDongIDFilter) + "&"; 
        if (minLoaiHopDongIDFilter === null)
            throw new Error("The parameter 'minLoaiHopDongIDFilter' cannot be null.");
        else if (minLoaiHopDongIDFilter !== undefined)
            url_ += "MinLoaiHopDongIDFilter=" + encodeURIComponent("" + minLoaiHopDongIDFilter) + "&"; 
        if (maSoNoiKCBFilter === null)
            throw new Error("The parameter 'maSoNoiKCBFilter' cannot be null.");
        else if (maSoNoiKCBFilter !== undefined)
            url_ += "MaSoNoiKCBFilter=" + encodeURIComponent("" + maSoNoiKCBFilter) + "&"; 
        if (maxNoiDangKyKCBIDFilter === null)
            throw new Error("The parameter 'maxNoiDangKyKCBIDFilter' cannot be null.");
        else if (maxNoiDangKyKCBIDFilter !== undefined)
            url_ += "MaxNoiDangKyKCBIDFilter=" + encodeURIComponent("" + maxNoiDangKyKCBIDFilter) + "&"; 
        if (minNoiDangKyKCBIDFilter === null)
            throw new Error("The parameter 'minNoiDangKyKCBIDFilter' cannot be null.");
        else if (minNoiDangKyKCBIDFilter !== undefined)
            url_ += "MinNoiDangKyKCBIDFilter=" + encodeURIComponent("" + minNoiDangKyKCBIDFilter) + "&"; 
        if (maxNgayHetHanBHYTFilter === null)
            throw new Error("The parameter 'maxNgayHetHanBHYTFilter' cannot be null.");
        else if (maxNgayHetHanBHYTFilter !== undefined)
            url_ += "MaxNgayHetHanBHYTFilter=" + encodeURIComponent(maxNgayHetHanBHYTFilter ? "" + maxNgayHetHanBHYTFilter.toJSON() : "") + "&"; 
        if (minNgayHetHanBHYTFilter === null)
            throw new Error("The parameter 'minNgayHetHanBHYTFilter' cannot be null.");
        else if (minNgayHetHanBHYTFilter !== undefined)
            url_ += "MinNgayHetHanBHYTFilter=" + encodeURIComponent(minNgayHetHanBHYTFilter ? "" + minNgayHetHanBHYTFilter.toJSON() : "") + "&"; 
        if (soTheBHYTFilter === null)
            throw new Error("The parameter 'soTheBHYTFilter' cannot be null.");
        else if (soTheBHYTFilter !== undefined)
            url_ += "SoTheBHYTFilter=" + encodeURIComponent("" + soTheBHYTFilter) + "&"; 
        if (maTinhCapFilter === null)
            throw new Error("The parameter 'maTinhCapFilter' cannot be null.");
        else if (maTinhCapFilter !== undefined)
            url_ += "MaTinhCapFilter=" + encodeURIComponent("" + maTinhCapFilter) + "&"; 
        if (maSoBHXHFilter === null)
            throw new Error("The parameter 'maSoBHXHFilter' cannot be null.");
        else if (maSoBHXHFilter !== undefined)
            url_ += "MaSoBHXHFilter=" + encodeURIComponent("" + maSoBHXHFilter) + "&"; 
        if (soSoBHXHFilter === null)
            throw new Error("The parameter 'soSoBHXHFilter' cannot be null.");
        else if (soSoBHXHFilter !== undefined)
            url_ += "SoSoBHXHFilter=" + encodeURIComponent("" + soSoBHXHFilter) + "&"; 
        if (maxTyLeDongBHFilter === null)
            throw new Error("The parameter 'maxTyLeDongBHFilter' cannot be null.");
        else if (maxTyLeDongBHFilter !== undefined)
            url_ += "MaxTyLeDongBHFilter=" + encodeURIComponent("" + maxTyLeDongBHFilter) + "&"; 
        if (minTyLeDongBHFilter === null)
            throw new Error("The parameter 'minTyLeDongBHFilter' cannot be null.");
        else if (minTyLeDongBHFilter !== undefined)
            url_ += "MinTyLeDongBHFilter=" + encodeURIComponent("" + minTyLeDongBHFilter) + "&"; 
        if (maxNgayThamGiaBHFilter === null)
            throw new Error("The parameter 'maxNgayThamGiaBHFilter' cannot be null.");
        else if (maxNgayThamGiaBHFilter !== undefined)
            url_ += "MaxNgayThamGiaBHFilter=" + encodeURIComponent(maxNgayThamGiaBHFilter ? "" + maxNgayThamGiaBHFilter.toJSON() : "") + "&"; 
        if (minNgayThamGiaBHFilter === null)
            throw new Error("The parameter 'minNgayThamGiaBHFilter' cannot be null.");
        else if (minNgayThamGiaBHFilter !== undefined)
            url_ += "MinNgayThamGiaBHFilter=" + encodeURIComponent(minNgayThamGiaBHFilter ? "" + minNgayThamGiaBHFilter.toJSON() : "") + "&"; 
        if (thamGiaCongDoanFilter === null)
            throw new Error("The parameter 'thamGiaCongDoanFilter' cannot be null.");
        else if (thamGiaCongDoanFilter !== undefined)
            url_ += "ThamGiaCongDoanFilter=" + encodeURIComponent("" + thamGiaCongDoanFilter) + "&"; 
        if (nganHangCodeFilter === null)
            throw new Error("The parameter 'nganHangCodeFilter' cannot be null.");
        else if (nganHangCodeFilter !== undefined)
            url_ += "NganHangCodeFilter=" + encodeURIComponent("" + nganHangCodeFilter) + "&"; 
        if (tkNganHangFilter === null)
            throw new Error("The parameter 'tkNganHangFilter' cannot be null.");
        else if (tkNganHangFilter !== undefined)
            url_ += "TkNganHangFilter=" + encodeURIComponent("" + tkNganHangFilter) + "&"; 
        if (donViSoCongChuanCodeFilter === null)
            throw new Error("The parameter 'donViSoCongChuanCodeFilter' cannot be null.");
        else if (donViSoCongChuanCodeFilter !== undefined)
            url_ += "DonViSoCongChuanCodeFilter=" + encodeURIComponent("" + donViSoCongChuanCodeFilter) + "&"; 
        if (soCongChuanFilter === null)
            throw new Error("The parameter 'soCongChuanFilter' cannot be null.");
        else if (soCongChuanFilter !== undefined)
            url_ += "SoCongChuanFilter=" + encodeURIComponent("" + soCongChuanFilter) + "&"; 
        if (luongDongBHFilter === null)
            throw new Error("The parameter 'luongDongBHFilter' cannot be null.");
        else if (luongDongBHFilter !== undefined)
            url_ += "LuongDongBHFilter=" + encodeURIComponent("" + luongDongBHFilter) + "&"; 
        if (luongCoBanFilter === null)
            throw new Error("The parameter 'luongCoBanFilter' cannot be null.");
        else if (luongCoBanFilter !== undefined)
            url_ += "LuongCoBanFilter=" + encodeURIComponent("" + luongCoBanFilter) + "&"; 
        if (bacLuongCodeFilter === null)
            throw new Error("The parameter 'bacLuongCodeFilter' cannot be null.");
        else if (bacLuongCodeFilter !== undefined)
            url_ += "BacLuongCodeFilter=" + encodeURIComponent("" + bacLuongCodeFilter) + "&"; 
        if (maxSoNgayPhepFilter === null)
            throw new Error("The parameter 'maxSoNgayPhepFilter' cannot be null.");
        else if (maxSoNgayPhepFilter !== undefined)
            url_ += "MaxSoNgayPhepFilter=" + encodeURIComponent("" + maxSoNgayPhepFilter) + "&"; 
        if (minSoNgayPhepFilter === null)
            throw new Error("The parameter 'minSoNgayPhepFilter' cannot be null.");
        else if (minSoNgayPhepFilter !== undefined)
            url_ += "MinSoNgayPhepFilter=" + encodeURIComponent("" + minSoNgayPhepFilter) + "&"; 
        if (maxNgayChinhThucFilter === null)
            throw new Error("The parameter 'maxNgayChinhThucFilter' cannot be null.");
        else if (maxNgayChinhThucFilter !== undefined)
            url_ += "MaxNgayChinhThucFilter=" + encodeURIComponent(maxNgayChinhThucFilter ? "" + maxNgayChinhThucFilter.toJSON() : "") + "&"; 
        if (minNgayChinhThucFilter === null)
            throw new Error("The parameter 'minNgayChinhThucFilter' cannot be null.");
        else if (minNgayChinhThucFilter !== undefined)
            url_ += "MinNgayChinhThucFilter=" + encodeURIComponent(minNgayChinhThucFilter ? "" + minNgayChinhThucFilter.toJSON() : "") + "&"; 
        if (maxNgayThuViecFilter === null)
            throw new Error("The parameter 'maxNgayThuViecFilter' cannot be null.");
        else if (maxNgayThuViecFilter !== undefined)
            url_ += "MaxNgayThuViecFilter=" + encodeURIComponent(maxNgayThuViecFilter ? "" + maxNgayThuViecFilter.toJSON() : "") + "&"; 
        if (minNgayThuViecFilter === null)
            throw new Error("The parameter 'minNgayThuViecFilter' cannot be null.");
        else if (minNgayThuViecFilter !== undefined)
            url_ += "MinNgayThuViecFilter=" + encodeURIComponent(minNgayThuViecFilter ? "" + minNgayThuViecFilter.toJSON() : "") + "&"; 
        if (maxNgayTapSuFilter === null)
            throw new Error("The parameter 'maxNgayTapSuFilter' cannot be null.");
        else if (maxNgayTapSuFilter !== undefined)
            url_ += "MaxNgayTapSuFilter=" + encodeURIComponent(maxNgayTapSuFilter ? "" + maxNgayTapSuFilter.toJSON() : "") + "&"; 
        if (minNgayTapSuFilter === null)
            throw new Error("The parameter 'minNgayTapSuFilter' cannot be null.");
        else if (minNgayTapSuFilter !== undefined)
            url_ += "MinNgayTapSuFilter=" + encodeURIComponent(minNgayTapSuFilter ? "" + minNgayTapSuFilter.toJSON() : "") + "&"; 
        if (soSoQLLaoDongFilter === null)
            throw new Error("The parameter 'soSoQLLaoDongFilter' cannot be null.");
        else if (soSoQLLaoDongFilter !== undefined)
            url_ += "SoSoQLLaoDongFilter=" + encodeURIComponent("" + soSoQLLaoDongFilter) + "&"; 
        if (diaDiemLamViecCodeFilter === null)
            throw new Error("The parameter 'diaDiemLamViecCodeFilter' cannot be null.");
        else if (diaDiemLamViecCodeFilter !== undefined)
            url_ += "DiaDiemLamViecCodeFilter=" + encodeURIComponent("" + diaDiemLamViecCodeFilter) + "&"; 
        if (quanLyGianTiepFilter === null)
            throw new Error("The parameter 'quanLyGianTiepFilter' cannot be null.");
        else if (quanLyGianTiepFilter !== undefined)
            url_ += "QuanLyGianTiepFilter=" + encodeURIComponent("" + quanLyGianTiepFilter) + "&"; 
        if (quanLyTrucTiepFilter === null)
            throw new Error("The parameter 'quanLyTrucTiepFilter' cannot be null.");
        else if (quanLyTrucTiepFilter !== undefined)
            url_ += "QuanLyTrucTiepFilter=" + encodeURIComponent("" + quanLyTrucTiepFilter) + "&"; 
        if (trangThaiLamViecCodeFilter === null)
            throw new Error("The parameter 'trangThaiLamViecCodeFilter' cannot be null.");
        else if (trangThaiLamViecCodeFilter !== undefined)
            url_ += "TrangThaiLamViecCodeFilter=" + encodeURIComponent("" + trangThaiLamViecCodeFilter) + "&"; 
        if (bacFilter === null)
            throw new Error("The parameter 'bacFilter' cannot be null.");
        else if (bacFilter !== undefined)
            url_ += "BacFilter=" + encodeURIComponent("" + bacFilter) + "&"; 
        if (capFilter === null)
            throw new Error("The parameter 'capFilter' cannot be null.");
        else if (capFilter !== undefined)
            url_ += "CapFilter=" + encodeURIComponent("" + capFilter) + "&"; 
        if (chucDanhFilter === null)
            throw new Error("The parameter 'chucDanhFilter' cannot be null.");
        else if (chucDanhFilter !== undefined)
            url_ += "ChucDanhFilter=" + encodeURIComponent("" + chucDanhFilter) + "&"; 
        if (maChamCongFilter === null)
            throw new Error("The parameter 'maChamCongFilter' cannot be null.");
        else if (maChamCongFilter !== undefined)
            url_ += "MaChamCongFilter=" + encodeURIComponent("" + maChamCongFilter) + "&"; 
        if (diaChiLHKCFilter === null)
            throw new Error("The parameter 'diaChiLHKCFilter' cannot be null.");
        else if (diaChiLHKCFilter !== undefined)
            url_ += "DiaChiLHKCFilter=" + encodeURIComponent("" + diaChiLHKCFilter) + "&"; 
        if (emailLHKCFilter === null)
            throw new Error("The parameter 'emailLHKCFilter' cannot be null.");
        else if (emailLHKCFilter !== undefined)
            url_ += "EmailLHKCFilter=" + encodeURIComponent("" + emailLHKCFilter) + "&"; 
        if (dtDiDongLHKCFilter === null)
            throw new Error("The parameter 'dtDiDongLHKCFilter' cannot be null.");
        else if (dtDiDongLHKCFilter !== undefined)
            url_ += "DtDiDongLHKCFilter=" + encodeURIComponent("" + dtDiDongLHKCFilter) + "&"; 
        if (dtNhaRiengLHKCFilter === null)
            throw new Error("The parameter 'dtNhaRiengLHKCFilter' cannot be null.");
        else if (dtNhaRiengLHKCFilter !== undefined)
            url_ += "DtNhaRiengLHKCFilter=" + encodeURIComponent("" + dtNhaRiengLHKCFilter) + "&"; 
        if (quanHeLHKCFilter === null)
            throw new Error("The parameter 'quanHeLHKCFilter' cannot be null.");
        else if (quanHeLHKCFilter !== undefined)
            url_ += "QuanHeLHKCFilter=" + encodeURIComponent("" + quanHeLHKCFilter) + "&"; 
        if (hoVaTenLHKCFilter === null)
            throw new Error("The parameter 'hoVaTenLHKCFilter' cannot be null.");
        else if (hoVaTenLHKCFilter !== undefined)
            url_ += "HoVaTenLHKCFilter=" + encodeURIComponent("" + hoVaTenLHKCFilter) + "&"; 
        if (diaChiHNFilter === null)
            throw new Error("The parameter 'diaChiHNFilter' cannot be null.");
        else if (diaChiHNFilter !== undefined)
            url_ += "DiaChiHNFilter=" + encodeURIComponent("" + diaChiHNFilter) + "&"; 
        if (maxTinhThanhIDHNFilter === null)
            throw new Error("The parameter 'maxTinhThanhIDHNFilter' cannot be null.");
        else if (maxTinhThanhIDHNFilter !== undefined)
            url_ += "MaxTinhThanhIDHNFilter=" + encodeURIComponent("" + maxTinhThanhIDHNFilter) + "&"; 
        if (minTinhThanhIDHNFilter === null)
            throw new Error("The parameter 'minTinhThanhIDHNFilter' cannot be null.");
        else if (minTinhThanhIDHNFilter !== undefined)
            url_ += "MinTinhThanhIDHNFilter=" + encodeURIComponent("" + minTinhThanhIDHNFilter) + "&"; 
        if (quocGiaHNFilter === null)
            throw new Error("The parameter 'quocGiaHNFilter' cannot be null.");
        else if (quocGiaHNFilter !== undefined)
            url_ += "QuocGiaHNFilter=" + encodeURIComponent("" + quocGiaHNFilter) + "&"; 
        if (laChuHoFilter === null)
            throw new Error("The parameter 'laChuHoFilter' cannot be null.");
        else if (laChuHoFilter !== undefined)
            url_ += "LaChuHoFilter=" + encodeURIComponent("" + laChuHoFilter) + "&"; 
        if (maSoHoGiaDinhFilter === null)
            throw new Error("The parameter 'maSoHoGiaDinhFilter' cannot be null.");
        else if (maSoHoGiaDinhFilter !== undefined)
            url_ += "MaSoHoGiaDinhFilter=" + encodeURIComponent("" + maSoHoGiaDinhFilter) + "&"; 
        if (soSoHoKhauFilter === null)
            throw new Error("The parameter 'soSoHoKhauFilter' cannot be null.");
        else if (soSoHoKhauFilter !== undefined)
            url_ += "SoSoHoKhauFilter=" + encodeURIComponent("" + soSoHoKhauFilter) + "&"; 
        if (diaChiHKTTFilter === null)
            throw new Error("The parameter 'diaChiHKTTFilter' cannot be null.");
        else if (diaChiHKTTFilter !== undefined)
            url_ += "DiaChiHKTTFilter=" + encodeURIComponent("" + diaChiHKTTFilter) + "&"; 
        if (maxTinhThanhIDHKTTFilter === null)
            throw new Error("The parameter 'maxTinhThanhIDHKTTFilter' cannot be null.");
        else if (maxTinhThanhIDHKTTFilter !== undefined)
            url_ += "MaxTinhThanhIDHKTTFilter=" + encodeURIComponent("" + maxTinhThanhIDHKTTFilter) + "&"; 
        if (minTinhThanhIDHKTTFilter === null)
            throw new Error("The parameter 'minTinhThanhIDHKTTFilter' cannot be null.");
        else if (minTinhThanhIDHKTTFilter !== undefined)
            url_ += "MinTinhThanhIDHKTTFilter=" + encodeURIComponent("" + minTinhThanhIDHKTTFilter) + "&"; 
        if (quocGiaHKTTFilter === null)
            throw new Error("The parameter 'quocGiaHKTTFilter' cannot be null.");
        else if (quocGiaHKTTFilter !== undefined)
            url_ += "QuocGiaHKTTFilter=" + encodeURIComponent("" + quocGiaHKTTFilter) + "&"; 
        if (facebookFilter === null)
            throw new Error("The parameter 'facebookFilter' cannot be null.");
        else if (facebookFilter !== undefined)
            url_ += "FacebookFilter=" + encodeURIComponent("" + facebookFilter) + "&"; 
        if (skypeFilter === null)
            throw new Error("The parameter 'skypeFilter' cannot be null.");
        else if (skypeFilter !== undefined)
            url_ += "SkypeFilter=" + encodeURIComponent("" + skypeFilter) + "&"; 
        if (noiSinhFilter === null)
            throw new Error("The parameter 'noiSinhFilter' cannot be null.");
        else if (noiSinhFilter !== undefined)
            url_ += "NoiSinhFilter=" + encodeURIComponent("" + noiSinhFilter) + "&"; 
        if (maxTinhThanhIDFilter === null)
            throw new Error("The parameter 'maxTinhThanhIDFilter' cannot be null.");
        else if (maxTinhThanhIDFilter !== undefined)
            url_ += "MaxTinhThanhIDFilter=" + encodeURIComponent("" + maxTinhThanhIDFilter) + "&"; 
        if (minTinhThanhIDFilter === null)
            throw new Error("The parameter 'minTinhThanhIDFilter' cannot be null.");
        else if (minTinhThanhIDFilter !== undefined)
            url_ += "MinTinhThanhIDFilter=" + encodeURIComponent("" + minTinhThanhIDFilter) + "&"; 
        if (nguyenQuanFilter === null)
            throw new Error("The parameter 'nguyenQuanFilter' cannot be null.");
        else if (nguyenQuanFilter !== undefined)
            url_ += "NguyenQuanFilter=" + encodeURIComponent("" + nguyenQuanFilter) + "&"; 
        if (emailKhacFilter === null)
            throw new Error("The parameter 'emailKhacFilter' cannot be null.");
        else if (emailKhacFilter !== undefined)
            url_ += "EmailKhacFilter=" + encodeURIComponent("" + emailKhacFilter) + "&"; 
        if (emailCoQuanFilter === null)
            throw new Error("The parameter 'emailCoQuanFilter' cannot be null.");
        else if (emailCoQuanFilter !== undefined)
            url_ += "EmailCoQuanFilter=" + encodeURIComponent("" + emailCoQuanFilter) + "&"; 
        if (emailCaNhanFilter === null)
            throw new Error("The parameter 'emailCaNhanFilter' cannot be null.");
        else if (emailCaNhanFilter !== undefined)
            url_ += "EmailCaNhanFilter=" + encodeURIComponent("" + emailCaNhanFilter) + "&"; 
        if (dtKhacFilter === null)
            throw new Error("The parameter 'dtKhacFilter' cannot be null.");
        else if (dtKhacFilter !== undefined)
            url_ += "DtKhacFilter=" + encodeURIComponent("" + dtKhacFilter) + "&"; 
        if (dtNhaRiengFilter === null)
            throw new Error("The parameter 'dtNhaRiengFilter' cannot be null.");
        else if (dtNhaRiengFilter !== undefined)
            url_ += "DtNhaRiengFilter=" + encodeURIComponent("" + dtNhaRiengFilter) + "&"; 
        if (dtCoQuanFilter === null)
            throw new Error("The parameter 'dtCoQuanFilter' cannot be null.");
        else if (dtCoQuanFilter !== undefined)
            url_ += "DtCoQuanFilter=" + encodeURIComponent("" + dtCoQuanFilter) + "&"; 
        if (dtDiDongFilter === null)
            throw new Error("The parameter 'dtDiDongFilter' cannot be null.");
        else if (dtDiDongFilter !== undefined)
            url_ += "DtDiDongFilter=" + encodeURIComponent("" + dtDiDongFilter) + "&"; 
        if (tepDinhKemFilter === null)
            throw new Error("The parameter 'tepDinhKemFilter' cannot be null.");
        else if (tepDinhKemFilter !== undefined)
            url_ += "TepDinhKemFilter=" + encodeURIComponent("" + tepDinhKemFilter) + "&"; 
        if (tinhTrangHonNhanCodeFilter === null)
            throw new Error("The parameter 'tinhTrangHonNhanCodeFilter' cannot be null.");
        else if (tinhTrangHonNhanCodeFilter !== undefined)
            url_ += "TinhTrangHonNhanCodeFilter=" + encodeURIComponent("" + tinhTrangHonNhanCodeFilter) + "&"; 
        if (xepLoaiCodeFilter === null)
            throw new Error("The parameter 'xepLoaiCodeFilter' cannot be null.");
        else if (xepLoaiCodeFilter !== undefined)
            url_ += "XepLoaiCodeFilter=" + encodeURIComponent("" + xepLoaiCodeFilter) + "&"; 
        if (maxNamTotNghiepFilter === null)
            throw new Error("The parameter 'maxNamTotNghiepFilter' cannot be null.");
        else if (maxNamTotNghiepFilter !== undefined)
            url_ += "MaxNamTotNghiepFilter=" + encodeURIComponent("" + maxNamTotNghiepFilter) + "&"; 
        if (minNamTotNghiepFilter === null)
            throw new Error("The parameter 'minNamTotNghiepFilter' cannot be null.");
        else if (minNamTotNghiepFilter !== undefined)
            url_ += "MinNamTotNghiepFilter=" + encodeURIComponent("" + minNamTotNghiepFilter) + "&"; 
        if (chuyenNganhFilter === null)
            throw new Error("The parameter 'chuyenNganhFilter' cannot be null.");
        else if (chuyenNganhFilter !== undefined)
            url_ += "ChuyenNganhFilter=" + encodeURIComponent("" + chuyenNganhFilter) + "&"; 
        if (khoaFilter === null)
            throw new Error("The parameter 'khoaFilter' cannot be null.");
        else if (khoaFilter !== undefined)
            url_ += "KhoaFilter=" + encodeURIComponent("" + khoaFilter) + "&"; 
        if (trinhDoDaoTaoCodeFilter === null)
            throw new Error("The parameter 'trinhDoDaoTaoCodeFilter' cannot be null.");
        else if (trinhDoDaoTaoCodeFilter !== undefined)
            url_ += "TrinhDoDaoTaoCodeFilter=" + encodeURIComponent("" + trinhDoDaoTaoCodeFilter) + "&"; 
        if (trinhDoVanHoaFilter === null)
            throw new Error("The parameter 'trinhDoVanHoaFilter' cannot be null.");
        else if (trinhDoVanHoaFilter !== undefined)
            url_ += "TrinhDoVanHoaFilter=" + encodeURIComponent("" + trinhDoVanHoaFilter) + "&"; 
        if (maxNgayHetHanFilter === null)
            throw new Error("The parameter 'maxNgayHetHanFilter' cannot be null.");
        else if (maxNgayHetHanFilter !== undefined)
            url_ += "MaxNgayHetHanFilter=" + encodeURIComponent(maxNgayHetHanFilter ? "" + maxNgayHetHanFilter.toJSON() : "") + "&"; 
        if (minNgayHetHanFilter === null)
            throw new Error("The parameter 'minNgayHetHanFilter' cannot be null.");
        else if (minNgayHetHanFilter !== undefined)
            url_ += "MinNgayHetHanFilter=" + encodeURIComponent(minNgayHetHanFilter ? "" + minNgayHetHanFilter.toJSON() : "") + "&"; 
        if (noiCapFilter === null)
            throw new Error("The parameter 'noiCapFilter' cannot be null.");
        else if (noiCapFilter !== undefined)
            url_ += "NoiCapFilter=" + encodeURIComponent("" + noiCapFilter) + "&"; 
        if (maxNgayCapFilter === null)
            throw new Error("The parameter 'maxNgayCapFilter' cannot be null.");
        else if (maxNgayCapFilter !== undefined)
            url_ += "MaxNgayCapFilter=" + encodeURIComponent(maxNgayCapFilter ? "" + maxNgayCapFilter.toJSON() : "") + "&"; 
        if (minNgayCapFilter === null)
            throw new Error("The parameter 'minNgayCapFilter' cannot be null.");
        else if (minNgayCapFilter !== undefined)
            url_ += "MinNgayCapFilter=" + encodeURIComponent(minNgayCapFilter ? "" + minNgayCapFilter.toJSON() : "") + "&"; 
        if (soCMNDFilter === null)
            throw new Error("The parameter 'soCMNDFilter' cannot be null.");
        else if (soCMNDFilter !== undefined)
            url_ += "SoCMNDFilter=" + encodeURIComponent("" + soCMNDFilter) + "&"; 
        if (quocTichFilter === null)
            throw new Error("The parameter 'quocTichFilter' cannot be null.");
        else if (quocTichFilter !== undefined)
            url_ += "QuocTichFilter=" + encodeURIComponent("" + quocTichFilter) + "&"; 
        if (tonGiaoFilter === null)
            throw new Error("The parameter 'tonGiaoFilter' cannot be null.");
        else if (tonGiaoFilter !== undefined)
            url_ += "TonGiaoFilter=" + encodeURIComponent("" + tonGiaoFilter) + "&"; 
        if (danTocFilter === null)
            throw new Error("The parameter 'danTocFilter' cannot be null.");
        else if (danTocFilter !== undefined)
            url_ += "DanTocFilter=" + encodeURIComponent("" + danTocFilter) + "&"; 
        if (viTriCongViecCodeFilter === null)
            throw new Error("The parameter 'viTriCongViecCodeFilter' cannot be null.");
        else if (viTriCongViecCodeFilter !== undefined)
            url_ += "ViTriCongViecCodeFilter=" + encodeURIComponent("" + viTriCongViecCodeFilter) + "&"; 
        if (maxDonViCongTacIDFilter === null)
            throw new Error("The parameter 'maxDonViCongTacIDFilter' cannot be null.");
        else if (maxDonViCongTacIDFilter !== undefined)
            url_ += "MaxDonViCongTacIDFilter=" + encodeURIComponent("" + maxDonViCongTacIDFilter) + "&"; 
        if (minDonViCongTacIDFilter === null)
            throw new Error("The parameter 'minDonViCongTacIDFilter' cannot be null.");
        else if (minDonViCongTacIDFilter !== undefined)
            url_ += "MinDonViCongTacIDFilter=" + encodeURIComponent("" + minDonViCongTacIDFilter) + "&"; 
        if (mSTCaNhanFilter === null)
            throw new Error("The parameter 'mSTCaNhanFilter' cannot be null.");
        else if (mSTCaNhanFilter !== undefined)
            url_ += "MSTCaNhanFilter=" + encodeURIComponent("" + mSTCaNhanFilter) + "&"; 
        if (maxNgaySinhFilter === null)
            throw new Error("The parameter 'maxNgaySinhFilter' cannot be null.");
        else if (maxNgaySinhFilter !== undefined)
            url_ += "MaxNgaySinhFilter=" + encodeURIComponent(maxNgaySinhFilter ? "" + maxNgaySinhFilter.toJSON() : "") + "&"; 
        if (minNgaySinhFilter === null)
            throw new Error("The parameter 'minNgaySinhFilter' cannot be null.");
        else if (minNgaySinhFilter !== undefined)
            url_ += "MinNgaySinhFilter=" + encodeURIComponent(minNgaySinhFilter ? "" + minNgaySinhFilter.toJSON() : "") + "&"; 
        if (gioiTinhCodeFilter === null)
            throw new Error("The parameter 'gioiTinhCodeFilter' cannot be null.");
        else if (gioiTinhCodeFilter !== undefined)
            url_ += "GioiTinhCodeFilter=" + encodeURIComponent("" + gioiTinhCodeFilter) + "&"; 
        if (anhDaiDienFilter === null)
            throw new Error("The parameter 'anhDaiDienFilter' cannot be null.");
        else if (anhDaiDienFilter !== undefined)
            url_ += "AnhDaiDienFilter=" + encodeURIComponent("" + anhDaiDienFilter) + "&"; 
        if (hoVaTenFilter === null)
            throw new Error("The parameter 'hoVaTenFilter' cannot be null.");
        else if (hoVaTenFilter !== undefined)
            url_ += "HoVaTenFilter=" + encodeURIComponent("" + hoVaTenFilter) + "&"; 
        if (maNhanVienFilter === null)
            throw new Error("The parameter 'maNhanVienFilter' cannot be null.");
        else if (maNhanVienFilter !== undefined)
            url_ += "MaNhanVienFilter=" + encodeURIComponent("" + maNhanVienFilter) + "&"; 
        if (chiNhanhFilter === null)
            throw new Error("The parameter 'chiNhanhFilter' cannot be null.");
        else if (chiNhanhFilter !== undefined)
            url_ += "ChiNhanhFilter=" + encodeURIComponent("" + chiNhanhFilter) + "&"; 
        if (dVTFilter === null)
            throw new Error("The parameter 'dVTFilter' cannot be null.");
        else if (dVTFilter !== undefined)
            url_ += "DVTFilter=" + encodeURIComponent("" + dVTFilter) + "&"; 
        if (maxNgayKyHDKTHFilter === null)
            throw new Error("The parameter 'maxNgayKyHDKTHFilter' cannot be null.");
        else if (maxNgayKyHDKTHFilter !== undefined)
            url_ += "MaxNgayKyHDKTHFilter=" + encodeURIComponent(maxNgayKyHDKTHFilter ? "" + maxNgayKyHDKTHFilter.toJSON() : "") + "&"; 
        if (minNgayKyHDKTHFilter === null)
            throw new Error("The parameter 'minNgayKyHDKTHFilter' cannot be null.");
        else if (minNgayKyHDKTHFilter !== undefined)
            url_ += "MinNgayKyHDKTHFilter=" + encodeURIComponent(minNgayKyHDKTHFilter ? "" + minNgayKyHDKTHFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHD36THFilter === null)
            throw new Error("The parameter 'maxNgayKyHD36THFilter' cannot be null.");
        else if (maxNgayKyHD36THFilter !== undefined)
            url_ += "MaxNgayKyHD36THFilter=" + encodeURIComponent(maxNgayKyHD36THFilter ? "" + maxNgayKyHD36THFilter.toJSON() : "") + "&"; 
        if (minNgayKyHD36THFilter === null)
            throw new Error("The parameter 'minNgayKyHD36THFilter' cannot be null.");
        else if (minNgayKyHD36THFilter !== undefined)
            url_ += "MinNgayKyHD36THFilter=" + encodeURIComponent(minNgayKyHD36THFilter ? "" + minNgayKyHD36THFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHD12THFilter === null)
            throw new Error("The parameter 'maxNgayKyHD12THFilter' cannot be null.");
        else if (maxNgayKyHD12THFilter !== undefined)
            url_ += "MaxNgayKyHD12THFilter=" + encodeURIComponent(maxNgayKyHD12THFilter ? "" + maxNgayKyHD12THFilter.toJSON() : "") + "&"; 
        if (minNgayKyHD12THFilter === null)
            throw new Error("The parameter 'minNgayKyHD12THFilter' cannot be null.");
        else if (minNgayKyHD12THFilter !== undefined)
            url_ += "MinNgayKyHD12THFilter=" + encodeURIComponent(minNgayKyHD12THFilter ? "" + minNgayKyHD12THFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHDTVFilter === null)
            throw new Error("The parameter 'maxNgayKyHDTVFilter' cannot be null.");
        else if (maxNgayKyHDTVFilter !== undefined)
            url_ += "MaxNgayKyHDTVFilter=" + encodeURIComponent(maxNgayKyHDTVFilter ? "" + maxNgayKyHDTVFilter.toJSON() : "") + "&"; 
        if (minNgayKyHDTVFilter === null)
            throw new Error("The parameter 'minNgayKyHDTVFilter' cannot be null.");
        else if (minNgayKyHDTVFilter !== undefined)
            url_ += "MinNgayKyHDTVFilter=" + encodeURIComponent(minNgayKyHDTVFilter ? "" + minNgayKyHDTVFilter.toJSON() : "") + "&"; 
        if (maxNgayKYHDCTVFilter === null)
            throw new Error("The parameter 'maxNgayKYHDCTVFilter' cannot be null.");
        else if (maxNgayKYHDCTVFilter !== undefined)
            url_ += "MaxNgayKYHDCTVFilter=" + encodeURIComponent(maxNgayKYHDCTVFilter ? "" + maxNgayKYHDCTVFilter.toJSON() : "") + "&"; 
        if (minNgayKYHDCTVFilter === null)
            throw new Error("The parameter 'minNgayKYHDCTVFilter' cannot be null.");
        else if (minNgayKYHDCTVFilter !== undefined)
            url_ += "MinNgayKYHDCTVFilter=" + encodeURIComponent(minNgayKYHDCTVFilter ? "" + minNgayKYHDCTVFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHDKVFilter === null)
            throw new Error("The parameter 'maxNgayKyHDKVFilter' cannot be null.");
        else if (maxNgayKyHDKVFilter !== undefined)
            url_ += "MaxNgayKyHDKVFilter=" + encodeURIComponent(maxNgayKyHDKVFilter ? "" + maxNgayKyHDKVFilter.toJSON() : "") + "&"; 
        if (minNgayKyHDKVFilter === null)
            throw new Error("The parameter 'minNgayKyHDKVFilter' cannot be null.");
        else if (minNgayKyHDKVFilter !== undefined)
            url_ += "MinNgayKyHDKVFilter=" + encodeURIComponent(minNgayKyHDKVFilter ? "" + minNgayKyHDKVFilter.toJSON() : "") + "&"; 
        if (maxNgayKYHDTTFilter === null)
            throw new Error("The parameter 'maxNgayKYHDTTFilter' cannot be null.");
        else if (maxNgayKYHDTTFilter !== undefined)
            url_ += "MaxNgayKYHDTTFilter=" + encodeURIComponent(maxNgayKYHDTTFilter ? "" + maxNgayKYHDTTFilter.toJSON() : "") + "&"; 
        if (minNgayKYHDTTFilter === null)
            throw new Error("The parameter 'minNgayKYHDTTFilter' cannot be null.");
        else if (minNgayKYHDTTFilter !== undefined)
            url_ += "MinNgayKYHDTTFilter=" + encodeURIComponent(minNgayKYHDTTFilter ? "" + minNgayKYHDTTFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHDFilter === null)
            throw new Error("The parameter 'maxNgayKyHDFilter' cannot be null.");
        else if (maxNgayKyHDFilter !== undefined)
            url_ += "MaxNgayKyHDFilter=" + encodeURIComponent(maxNgayKyHDFilter ? "" + maxNgayKyHDFilter.toJSON() : "") + "&"; 
        if (minNgayKyHDFilter === null)
            throw new Error("The parameter 'minNgayKyHDFilter' cannot be null.");
        else if (minNgayKyHDFilter !== undefined)
            url_ += "MinNgayKyHDFilter=" + encodeURIComponent(minNgayKyHDFilter ? "" + minNgayKyHDFilter.toJSON() : "") + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetHoSoForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetHoSoForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetHoSoForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetHoSoForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetHoSoForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetHoSoForViewDto>(<any>null);
    }

    /**
     * @return Success
     */
    getListItemSearchHoSo(): Observable<GetUngVienForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetListItemSearchHoSo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListItemSearchHoSo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListItemSearchHoSo(<any>response_);
                } catch (e) {
                    return <Observable<GetUngVienForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUngVienForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetListItemSearchHoSo(response: HttpResponseBase): Observable<GetUngVienForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUngVienForEditOutput.fromJS(resultData200) : new GetUngVienForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUngVienForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getNameUnit(id: number | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetNameUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNameUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNameUnit(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNameUnit(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getListInFoHoSo(): Observable<ListInfoHoSo[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetListInFoHoSo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListInFoHoSo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListInFoHoSo(<any>response_);
                } catch (e) {
                    return <Observable<ListInfoHoSo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListInfoHoSo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListInFoHoSo(response: HttpResponseBase): Observable<ListInfoHoSo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ListInfoHoSo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListInfoHoSo[]>(<any>null);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param tenCty (optional) 
     * @return Success
     */
    getListNhanVienToDataFromDate(fromDate: string | undefined, toDate: string | undefined, tenCty: string | undefined): Observable<CreateOrEditHoSoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetListNhanVienToDataFromDate?";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&"; 
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent("" + toDate) + "&"; 
        if (tenCty === null)
            throw new Error("The parameter 'tenCty' cannot be null.");
        else if (tenCty !== undefined)
            url_ += "tenCty=" + encodeURIComponent("" + tenCty) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListNhanVienToDataFromDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListNhanVienToDataFromDate(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditHoSoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditHoSoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListNhanVienToDataFromDate(response: HttpResponseBase): Observable<CreateOrEditHoSoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CreateOrEditHoSoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditHoSoDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHoSoForView(id: number | undefined): Observable<CreateOrEditHoSoDto> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetHoSoForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHoSoForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHoSoForView(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditHoSoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditHoSoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHoSoForView(response: HttpResponseBase): Observable<CreateOrEditHoSoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateOrEditHoSoDto.fromJS(resultData200) : new CreateOrEditHoSoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditHoSoDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHoSoForEdit(id: number | undefined): Observable<GetHoSoForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetHoSoForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHoSoForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHoSoForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetHoSoForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetHoSoForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetHoSoForEdit(response: HttpResponseBase): Observable<GetHoSoForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetHoSoForEditOutput.fromJS(resultData200) : new GetHoSoForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetHoSoForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditHoSoInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenTP (optional) 
     * @return Success
     */
    getMaTinhThanh(tenTP: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetMaTinhThanh?";
        if (tenTP === null)
            throw new Error("The parameter 'tenTP' cannot be null.");
        else if (tenTP !== undefined)
            url_ += "tenTP=" + encodeURIComponent("" + tenTP) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaTinhThanh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaTinhThanh(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaTinhThanh(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenNDT (optional) 
     * @return Success
     */
    getMaNoiDaotao(tenNDT: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetMaNoiDaotao?";
        if (tenNDT === null)
            throw new Error("The parameter 'tenNDT' cannot be null.");
        else if (tenNDT !== undefined)
            url_ += "tenNDT=" + encodeURIComponent("" + tenNDT) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaNoiDaotao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaNoiDaotao(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaNoiDaotao(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getHoSoTemplateToExcel(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/GetHoSoTemplateToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHoSoTemplateToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHoSoTemplateToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHoSoTemplateToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param currentTime (optional) 
     * @param path (optional) 
     * @return Success
     */
    importToExcel(currentTime: string | undefined, path: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/HoSos/importToExcel?";
        if (currentTime === null)
            throw new Error("The parameter 'currentTime' cannot be null.");
        else if (currentTime !== undefined)
            url_ += "currentTime=" + encodeURIComponent("" + currentTime) + "&"; 
        if (path === null)
            throw new Error("The parameter 'path' cannot be null.");
        else if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getTopStatsData(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<TopStatsData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetTopStatsData?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStatsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStatsData(<any>response_);
                } catch (e) {
                    return <Observable<TopStatsData>><any>_observableThrow(e);
                }
            } else
                return <Observable<TopStatsData>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopStatsData(response: HttpResponseBase): Observable<TopStatsData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TopStatsData.fromJS(resultData200) : new TopStatsData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TopStatsData>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentTenantsData(): Observable<GetRecentTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetRecentTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentTenantsData(<any>response_);
                } catch (e) {
                    return <Observable<GetRecentTenantsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRecentTenantsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentTenantsData(response: HttpResponseBase): Observable<GetRecentTenantsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRecentTenantsOutput.fromJS(resultData200) : new GetRecentTenantsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRecentTenantsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSubscriptionExpiringTenantsData(): Observable<GetExpiringTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetSubscriptionExpiringTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionExpiringTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionExpiringTenantsData(<any>response_);
                } catch (e) {
                    return <Observable<GetExpiringTenantsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetExpiringTenantsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionExpiringTenantsData(response: HttpResponseBase): Observable<GetExpiringTenantsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetExpiringTenantsOutput.fromJS(resultData200) : new GetExpiringTenantsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExpiringTenantsOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetIncomeStatisticsDataOutput.fromJS(resultData200) : new GetIncomeStatisticsDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionTenantStatisticsOutput.fromJS(resultData200) : new GetEditionTenantStatisticsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setup(body: InstallDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppSettingsJsonDto.fromJS(resultData200) : new AppSettingsJsonDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckDatabaseOutput.fromJS(resultData200) : new CheckDatabaseOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceDto.fromJS(resultData200) : new InvoiceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvoice(body: CreateInvoiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class KeywordDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxKeywordIdFilter (optional) 
     * @param minKeywordIdFilter (optional) 
     * @param isLeaderFilter (optional) 
     * @param fullNameFilter (optional) 
     * @param mainHandlingFilter (optional) 
     * @param coHandlingFilter (optional) 
     * @param toKnowFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param userIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxKeywordIdFilter: number | undefined, minKeywordIdFilter: number | undefined, isLeaderFilter: number | undefined, fullNameFilter: string | undefined, mainHandlingFilter: number | undefined, coHandlingFilter: number | undefined, toKnowFilter: number | undefined, isActiveFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, userIdFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetKeywordDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/KeywordDetails/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxKeywordIdFilter === null)
            throw new Error("The parameter 'maxKeywordIdFilter' cannot be null.");
        else if (maxKeywordIdFilter !== undefined)
            url_ += "MaxKeywordIdFilter=" + encodeURIComponent("" + maxKeywordIdFilter) + "&"; 
        if (minKeywordIdFilter === null)
            throw new Error("The parameter 'minKeywordIdFilter' cannot be null.");
        else if (minKeywordIdFilter !== undefined)
            url_ += "MinKeywordIdFilter=" + encodeURIComponent("" + minKeywordIdFilter) + "&"; 
        if (isLeaderFilter === null)
            throw new Error("The parameter 'isLeaderFilter' cannot be null.");
        else if (isLeaderFilter !== undefined)
            url_ += "IsLeaderFilter=" + encodeURIComponent("" + isLeaderFilter) + "&"; 
        if (fullNameFilter === null)
            throw new Error("The parameter 'fullNameFilter' cannot be null.");
        else if (fullNameFilter !== undefined)
            url_ += "FullNameFilter=" + encodeURIComponent("" + fullNameFilter) + "&"; 
        if (mainHandlingFilter === null)
            throw new Error("The parameter 'mainHandlingFilter' cannot be null.");
        else if (mainHandlingFilter !== undefined)
            url_ += "MainHandlingFilter=" + encodeURIComponent("" + mainHandlingFilter) + "&"; 
        if (coHandlingFilter === null)
            throw new Error("The parameter 'coHandlingFilter' cannot be null.");
        else if (coHandlingFilter !== undefined)
            url_ += "CoHandlingFilter=" + encodeURIComponent("" + coHandlingFilter) + "&"; 
        if (toKnowFilter === null)
            throw new Error("The parameter 'toKnowFilter' cannot be null.");
        else if (toKnowFilter !== undefined)
            url_ += "ToKnowFilter=" + encodeURIComponent("" + toKnowFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (userIdFilter === null)
            throw new Error("The parameter 'userIdFilter' cannot be null.");
        else if (userIdFilter !== undefined)
            url_ += "UserIdFilter=" + encodeURIComponent("" + userIdFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetKeywordDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetKeywordDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetKeywordDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetKeywordDetailForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetKeywordDetailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetKeywordDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getKeywordDetailForEdit(id: number | undefined): Observable<GetKeywordDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/KeywordDetails/GetKeywordDetailForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeywordDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeywordDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetKeywordDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetKeywordDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeywordDetailForEdit(response: HttpResponseBase): Observable<GetKeywordDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetKeywordDetailForEditOutput.fromJS(resultData200) : new GetKeywordDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetKeywordDetailForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditKeywordDetailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KeywordDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KeywordDetails/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keywordId (optional) 
     * @return Success
     */
    getAllKeywordDetailByKeywordId(keywordId: number | undefined): Observable<KeywordDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/KeywordDetails/GetAllKeywordDetailByKeywordId?";
        if (keywordId === null)
            throw new Error("The parameter 'keywordId' cannot be null.");
        else if (keywordId !== undefined)
            url_ += "keywordId=" + encodeURIComponent("" + keywordId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKeywordDetailByKeywordId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKeywordDetailByKeywordId(<any>response_);
                } catch (e) {
                    return <Observable<KeywordDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KeywordDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllKeywordDetailByKeywordId(response: HttpResponseBase): Observable<KeywordDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(KeywordDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KeywordDetailDto[]>(<any>null);
    }
}

@Injectable()
export class LabelsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param titleFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param iconFilter (optional) 
     * @param linkFilter (optional) 
     * @param maxParentFilter (optional) 
     * @param minParentFilter (optional) 
     * @param maxIndexFilter (optional) 
     * @param minIndexFilter (optional) 
     * @param requiredPermissionNameFilter (optional) 
     * @param sqlStringFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, titleFilter: string | undefined, descriptionFilter: string | undefined, iconFilter: string | undefined, linkFilter: string | undefined, maxParentFilter: number | undefined, minParentFilter: number | undefined, maxIndexFilter: number | undefined, minIndexFilter: number | undefined, requiredPermissionNameFilter: string | undefined, sqlStringFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetLabelForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Labels/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (titleFilter === null)
            throw new Error("The parameter 'titleFilter' cannot be null.");
        else if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (iconFilter === null)
            throw new Error("The parameter 'iconFilter' cannot be null.");
        else if (iconFilter !== undefined)
            url_ += "IconFilter=" + encodeURIComponent("" + iconFilter) + "&"; 
        if (linkFilter === null)
            throw new Error("The parameter 'linkFilter' cannot be null.");
        else if (linkFilter !== undefined)
            url_ += "LinkFilter=" + encodeURIComponent("" + linkFilter) + "&"; 
        if (maxParentFilter === null)
            throw new Error("The parameter 'maxParentFilter' cannot be null.");
        else if (maxParentFilter !== undefined)
            url_ += "MaxParentFilter=" + encodeURIComponent("" + maxParentFilter) + "&"; 
        if (minParentFilter === null)
            throw new Error("The parameter 'minParentFilter' cannot be null.");
        else if (minParentFilter !== undefined)
            url_ += "MinParentFilter=" + encodeURIComponent("" + minParentFilter) + "&"; 
        if (maxIndexFilter === null)
            throw new Error("The parameter 'maxIndexFilter' cannot be null.");
        else if (maxIndexFilter !== undefined)
            url_ += "MaxIndexFilter=" + encodeURIComponent("" + maxIndexFilter) + "&"; 
        if (minIndexFilter === null)
            throw new Error("The parameter 'minIndexFilter' cannot be null.");
        else if (minIndexFilter !== undefined)
            url_ += "MinIndexFilter=" + encodeURIComponent("" + minIndexFilter) + "&"; 
        if (requiredPermissionNameFilter === null)
            throw new Error("The parameter 'requiredPermissionNameFilter' cannot be null.");
        else if (requiredPermissionNameFilter !== undefined)
            url_ += "RequiredPermissionNameFilter=" + encodeURIComponent("" + requiredPermissionNameFilter) + "&"; 
        if (sqlStringFilter === null)
            throw new Error("The parameter 'sqlStringFilter' cannot be null.");
        else if (sqlStringFilter !== undefined)
            url_ += "SqlStringFilter=" + encodeURIComponent("" + sqlStringFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetLabelForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetLabelForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetLabelForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetLabelForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetLabelForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetLabelForViewDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLabelForDynamicField(): Observable<LabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Labels/GetAllLabelForDynamicField";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLabelForDynamicField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLabelForDynamicField(<any>response_);
                } catch (e) {
                    return <Observable<LabelDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LabelDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLabelForDynamicField(response: HttpResponseBase): Observable<LabelDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LabelDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LabelDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLabelForView(id: number | undefined): Observable<GetLabelForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Labels/GetLabelForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLabelForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLabelForView(<any>response_);
                } catch (e) {
                    return <Observable<GetLabelForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLabelForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLabelForView(response: HttpResponseBase): Observable<GetLabelForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLabelForViewDto.fromJS(resultData200) : new GetLabelForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLabelForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLabelForEdit(id: number | undefined): Observable<GetLabelForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Labels/GetLabelForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLabelForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLabelForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLabelForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLabelForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLabelForEdit(response: HttpResponseBase): Observable<GetLabelForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLabelForEditOutput.fromJS(resultData200) : new GetLabelForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLabelForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditLabelDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Labels/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Labels/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLabels(): Observable<LabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Labels/GetAllLabels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLabels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLabels(<any>response_);
                } catch (e) {
                    return <Observable<LabelDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LabelDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLabels(response: HttpResponseBase): Observable<LabelDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LabelDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LabelDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAlllabel_(): Observable<LabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Labels/GetAlllabel_";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAlllabel_(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAlllabel_(<any>response_);
                } catch (e) {
                    return <Observable<LabelDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LabelDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAlllabel_(response: HttpResponseBase): Observable<LabelDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LabelDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LabelDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getMenu(): Observable<LabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Labels/GetMenu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenu(<any>response_);
                } catch (e) {
                    return <Observable<LabelDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LabelDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenu(response: HttpResponseBase): Observable<LabelDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LabelDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LabelDto[]>(<any>null);
    }

    /**
     * @param menuId (optional) 
     * @return Success
     */
    getListLabelByMenuId(menuId: number | undefined): Observable<LabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Labels/GetListLabelByMenuId?";
        if (menuId === null)
            throw new Error("The parameter 'menuId' cannot be null.");
        else if (menuId !== undefined)
            url_ += "menuId=" + encodeURIComponent("" + menuId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListLabelByMenuId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListLabelByMenuId(<any>response_);
                } catch (e) {
                    return <Observable<LabelDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LabelDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListLabelByMenuId(response: HttpResponseBase): Observable<LabelDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LabelDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LabelDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getChildLabel(): Observable<LabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Labels/GetChildLabel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChildLabel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChildLabel(<any>response_);
                } catch (e) {
                    return <Observable<LabelDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LabelDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetChildLabel(response: HttpResponseBase): Observable<LabelDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LabelDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LabelDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllForRoleMapper(): Observable<LabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Labels/GetAllForRoleMapper";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForRoleMapper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForRoleMapper(<any>response_);
                } catch (e) {
                    return <Observable<LabelDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LabelDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllForRoleMapper(response: HttpResponseBase): Observable<LabelDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LabelDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LabelDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllSqlConfig(): Observable<SqlConfigDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Labels/GetAllSqlConfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSqlConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSqlConfig(<any>response_);
                } catch (e) {
                    return <Observable<SqlConfigDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SqlConfigDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSqlConfig(response: HttpResponseBase): Observable<SqlConfigDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SqlConfigDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SqlConfigDto[]>(<any>null);
    }

    /**
     * @param sqlConfigCode (optional) 
     * @return Success
     */
    getAllDataAndColumnConfig(sqlConfigCode: string | undefined): Observable<GetDataAndColumnConfig> {
        let url_ = this.baseUrl + "/api/services/app/Labels/GetAllDataAndColumnConfig?";
        if (sqlConfigCode === null)
            throw new Error("The parameter 'sqlConfigCode' cannot be null.");
        else if (sqlConfigCode !== undefined)
            url_ += "sqlConfigCode=" + encodeURIComponent("" + sqlConfigCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDataAndColumnConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDataAndColumnConfig(<any>response_);
                } catch (e) {
                    return <Observable<GetDataAndColumnConfig>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDataAndColumnConfig>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDataAndColumnConfig(response: HttpResponseBase): Observable<GetDataAndColumnConfig> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDataAndColumnConfig.fromJS(resultData200) : new GetDataAndColumnConfig();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDataAndColumnConfig>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined, sourceName: string, baseLanguageName: string | undefined, targetLanguageName: string, targetValueFilter: string | undefined, filterText: string | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName === null)
            throw new Error("The parameter 'baseLanguageName' cannot be null.");
        else if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter === null)
            throw new Error("The parameter 'targetValueFilter' cannot be null.");
        else if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLanguageTextListDto.fromJS(resultData200) : new PagedResultDtoOfLanguageTextListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LichSuLamViecsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAndGetIdComment(body: LichSuLamViecDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/LichSuLamViecs/CreateAndGetIdComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAndGetIdComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAndGetIdComment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAndGetIdComment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditListComment(body: LichSuLamViecDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LichSuLamViecs/CreateOrEditListComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditListComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditListComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditListComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ungvienId (optional) 
     * @return Success
     */
    getLichSuLamViecByUngVien(ungvienId: number | undefined): Observable<LichSuLamViecDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichSuLamViecs/GetLichSuLamViecByUngVien?";
        if (ungvienId === null)
            throw new Error("The parameter 'ungvienId' cannot be null.");
        else if (ungvienId !== undefined)
            url_ += "ungvienId=" + encodeURIComponent("" + ungvienId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichSuLamViecByUngVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichSuLamViecByUngVien(<any>response_);
                } catch (e) {
                    return <Observable<LichSuLamViecDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LichSuLamViecDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLichSuLamViecByUngVien(response: HttpResponseBase): Observable<LichSuLamViecDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LichSuLamViecDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichSuLamViecDto[]>(<any>null);
    }

    /**
     * @param phieuNghiID (optional) 
     * @return Success
     */
    getLichSuLamViecByPhieuNghiPhep(phieuNghiID: number | undefined): Observable<LichSuLamViecDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichSuLamViecs/GetLichSuLamViecByPhieuNghiPhep?";
        if (phieuNghiID === null)
            throw new Error("The parameter 'phieuNghiID' cannot be null.");
        else if (phieuNghiID !== undefined)
            url_ += "phieuNghiID=" + encodeURIComponent("" + phieuNghiID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichSuLamViecByPhieuNghiPhep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichSuLamViecByPhieuNghiPhep(<any>response_);
                } catch (e) {
                    return <Observable<LichSuLamViecDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LichSuLamViecDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLichSuLamViecByPhieuNghiPhep(response: HttpResponseBase): Observable<LichSuLamViecDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LichSuLamViecDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichSuLamViecDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxUngVienIdFilter (optional) 
     * @param minUngVienIdFilter (optional) 
     * @param noiDungFilter (optional) 
     * @param tepDinhKemFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxUngVienIdFilter: number | undefined, minUngVienIdFilter: number | undefined, noiDungFilter: string | undefined, tepDinhKemFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetLichSuLamViecForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LichSuLamViecs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxUngVienIdFilter === null)
            throw new Error("The parameter 'maxUngVienIdFilter' cannot be null.");
        else if (maxUngVienIdFilter !== undefined)
            url_ += "MaxUngVienIdFilter=" + encodeURIComponent("" + maxUngVienIdFilter) + "&"; 
        if (minUngVienIdFilter === null)
            throw new Error("The parameter 'minUngVienIdFilter' cannot be null.");
        else if (minUngVienIdFilter !== undefined)
            url_ += "MinUngVienIdFilter=" + encodeURIComponent("" + minUngVienIdFilter) + "&"; 
        if (noiDungFilter === null)
            throw new Error("The parameter 'noiDungFilter' cannot be null.");
        else if (noiDungFilter !== undefined)
            url_ += "NoiDungFilter=" + encodeURIComponent("" + noiDungFilter) + "&"; 
        if (tepDinhKemFilter === null)
            throw new Error("The parameter 'tepDinhKemFilter' cannot be null.");
        else if (tepDinhKemFilter !== undefined)
            url_ += "TepDinhKemFilter=" + encodeURIComponent("" + tepDinhKemFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetLichSuLamViecForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetLichSuLamViecForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetLichSuLamViecForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetLichSuLamViecForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetLichSuLamViecForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetLichSuLamViecForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLichSuLamViecForView(id: number | undefined): Observable<GetLichSuLamViecForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LichSuLamViecs/GetLichSuLamViecForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichSuLamViecForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichSuLamViecForView(<any>response_);
                } catch (e) {
                    return <Observable<GetLichSuLamViecForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLichSuLamViecForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLichSuLamViecForView(response: HttpResponseBase): Observable<GetLichSuLamViecForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLichSuLamViecForViewDto.fromJS(resultData200) : new GetLichSuLamViecForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLichSuLamViecForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLichSuLamViecForEdit(id: number | undefined): Observable<GetLichSuLamViecForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/LichSuLamViecs/GetLichSuLamViecForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichSuLamViecForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichSuLamViecForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLichSuLamViecForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLichSuLamViecForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLichSuLamViecForEdit(response: HttpResponseBase): Observable<GetLichSuLamViecForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLichSuLamViecForEditOutput.fromJS(resultData200) : new GetLichSuLamViecForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLichSuLamViecForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditLichSuLamViecDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LichSuLamViecs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LichSuLamViecs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxUngVienIdFilter (optional) 
     * @param minUngVienIdFilter (optional) 
     * @param noiDungFilter (optional) 
     * @param tepDinhKemFilter (optional) 
     * @return Success
     */
    getLichSuLamViecsToExcel(filter: string | undefined, maxUngVienIdFilter: number | undefined, minUngVienIdFilter: number | undefined, noiDungFilter: string | undefined, tepDinhKemFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/LichSuLamViecs/GetLichSuLamViecsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxUngVienIdFilter === null)
            throw new Error("The parameter 'maxUngVienIdFilter' cannot be null.");
        else if (maxUngVienIdFilter !== undefined)
            url_ += "MaxUngVienIdFilter=" + encodeURIComponent("" + maxUngVienIdFilter) + "&"; 
        if (minUngVienIdFilter === null)
            throw new Error("The parameter 'minUngVienIdFilter' cannot be null.");
        else if (minUngVienIdFilter !== undefined)
            url_ += "MinUngVienIdFilter=" + encodeURIComponent("" + minUngVienIdFilter) + "&"; 
        if (noiDungFilter === null)
            throw new Error("The parameter 'noiDungFilter' cannot be null.");
        else if (noiDungFilter !== undefined)
            url_ += "NoiDungFilter=" + encodeURIComponent("" + noiDungFilter) + "&"; 
        if (tepDinhKemFilter === null)
            throw new Error("The parameter 'tepDinhKemFilter' cannot be null.");
        else if (tepDinhKemFilter !== undefined)
            url_ += "TepDinhKemFilter=" + encodeURIComponent("" + tepDinhKemFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichSuLamViecsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichSuLamViecsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLichSuLamViecsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class LichSuUploadsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param tenFileFilter (optional) 
     * @param dungLuongFilter (optional) 
     * @param tieuDeFilter (optional) 
     * @param typeFilter (optional) 
     * @param typeIDFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, tenFileFilter: string | undefined, dungLuongFilter: string | undefined, tieuDeFilter: string | undefined, typeFilter: string | undefined, typeIDFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetLichSuUploadForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LichSuUploads/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenFileFilter === null)
            throw new Error("The parameter 'tenFileFilter' cannot be null.");
        else if (tenFileFilter !== undefined)
            url_ += "TenFileFilter=" + encodeURIComponent("" + tenFileFilter) + "&"; 
        if (dungLuongFilter === null)
            throw new Error("The parameter 'dungLuongFilter' cannot be null.");
        else if (dungLuongFilter !== undefined)
            url_ += "DungLuongFilter=" + encodeURIComponent("" + dungLuongFilter) + "&"; 
        if (tieuDeFilter === null)
            throw new Error("The parameter 'tieuDeFilter' cannot be null.");
        else if (tieuDeFilter !== undefined)
            url_ += "TieuDeFilter=" + encodeURIComponent("" + tieuDeFilter) + "&"; 
        if (typeFilter === null)
            throw new Error("The parameter 'typeFilter' cannot be null.");
        else if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&"; 
        if (typeIDFilter === null)
            throw new Error("The parameter 'typeIDFilter' cannot be null.");
        else if (typeIDFilter !== undefined)
            url_ += "TypeIDFilter=" + encodeURIComponent("" + typeIDFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetLichSuUploadForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetLichSuUploadForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetLichSuUploadForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetLichSuUploadForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetLichSuUploadForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetLichSuUploadForViewDto>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param id (optional) 
     * @return Success
     */
    getListLichSuUploadDto(type: string | undefined, id: string | undefined): Observable<LichSuUploadDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichSuUploads/GetListLichSuUploadDto?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListLichSuUploadDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListLichSuUploadDto(<any>response_);
                } catch (e) {
                    return <Observable<LichSuUploadDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LichSuUploadDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListLichSuUploadDto(response: HttpResponseBase): Observable<LichSuUploadDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LichSuUploadDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichSuUploadDto[]>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param id (optional) 
     * @return Success
     */
    xoaLichSuUpLoadToID(type: string | undefined, id: string | undefined): Observable<LichSuUploadDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichSuUploads/XoaLichSuUpLoadToID?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXoaLichSuUpLoadToID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXoaLichSuUpLoadToID(<any>response_);
                } catch (e) {
                    return <Observable<LichSuUploadDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LichSuUploadDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processXoaLichSuUpLoadToID(response: HttpResponseBase): Observable<LichSuUploadDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LichSuUploadDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichSuUploadDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLichSuUploadForView(id: number | undefined): Observable<GetLichSuUploadForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LichSuUploads/GetLichSuUploadForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichSuUploadForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichSuUploadForView(<any>response_);
                } catch (e) {
                    return <Observable<GetLichSuUploadForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLichSuUploadForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLichSuUploadForView(response: HttpResponseBase): Observable<GetLichSuUploadForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLichSuUploadForViewDto.fromJS(resultData200) : new GetLichSuUploadForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLichSuUploadForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLichSuUploadForEdit(id: number | undefined): Observable<GetLichSuUploadForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/LichSuUploads/GetLichSuUploadForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichSuUploadForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichSuUploadForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLichSuUploadForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLichSuUploadForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLichSuUploadForEdit(response: HttpResponseBase): Observable<GetLichSuUploadForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLichSuUploadForEditOutput.fromJS(resultData200) : new GetLichSuUploadForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLichSuUploadForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditLichSuUploadDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LichSuUploads/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LichSuUploads/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class Memorize_KeywordsesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllMemorize_Keywordses(): Observable<GetDataAndColumnConfigMemorize> {
        let url_ = this.baseUrl + "/api/services/app/Memorize_Keywordses/GetAllMemorize_Keywordses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMemorize_Keywordses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMemorize_Keywordses(<any>response_);
                } catch (e) {
                    return <Observable<GetDataAndColumnConfigMemorize>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDataAndColumnConfigMemorize>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMemorize_Keywordses(response: HttpResponseBase): Observable<GetDataAndColumnConfigMemorize> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDataAndColumnConfigMemorize.fromJS(resultData200) : new GetDataAndColumnConfigMemorize();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDataAndColumnConfigMemorize>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenGoiNhoFilter (optional) 
     * @param xuLyChinhFilter (optional) 
     * @param dongXuLyFilter (optional) 
     * @param deBietFilter (optional) 
     * @param maxHead_IDFilter (optional) 
     * @param minHead_IDFilter (optional) 
     * @param full_NameFilter (optional) 
     * @param prefixFilter (optional) 
     * @param maxHire_DateFilter (optional) 
     * @param minHire_DateFilter (optional) 
     * @param keyWordFilter (optional) 
     * @param maxIsActiveFilter (optional) 
     * @param minIsActiveFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, tenGoiNhoFilter: string | undefined, xuLyChinhFilter: string | undefined, dongXuLyFilter: string | undefined, deBietFilter: string | undefined, maxHead_IDFilter: number | undefined, minHead_IDFilter: number | undefined, full_NameFilter: string | undefined, prefixFilter: string | undefined, maxHire_DateFilter: moment.Moment | undefined, minHire_DateFilter: moment.Moment | undefined, keyWordFilter: string | undefined, maxIsActiveFilter: number | undefined, minIsActiveFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMemorize_KeywordsForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Memorize_Keywordses/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenGoiNhoFilter === null)
            throw new Error("The parameter 'tenGoiNhoFilter' cannot be null.");
        else if (tenGoiNhoFilter !== undefined)
            url_ += "TenGoiNhoFilter=" + encodeURIComponent("" + tenGoiNhoFilter) + "&"; 
        if (xuLyChinhFilter === null)
            throw new Error("The parameter 'xuLyChinhFilter' cannot be null.");
        else if (xuLyChinhFilter !== undefined)
            url_ += "XuLyChinhFilter=" + encodeURIComponent("" + xuLyChinhFilter) + "&"; 
        if (dongXuLyFilter === null)
            throw new Error("The parameter 'dongXuLyFilter' cannot be null.");
        else if (dongXuLyFilter !== undefined)
            url_ += "DongXuLyFilter=" + encodeURIComponent("" + dongXuLyFilter) + "&"; 
        if (deBietFilter === null)
            throw new Error("The parameter 'deBietFilter' cannot be null.");
        else if (deBietFilter !== undefined)
            url_ += "DeBietFilter=" + encodeURIComponent("" + deBietFilter) + "&"; 
        if (maxHead_IDFilter === null)
            throw new Error("The parameter 'maxHead_IDFilter' cannot be null.");
        else if (maxHead_IDFilter !== undefined)
            url_ += "MaxHead_IDFilter=" + encodeURIComponent("" + maxHead_IDFilter) + "&"; 
        if (minHead_IDFilter === null)
            throw new Error("The parameter 'minHead_IDFilter' cannot be null.");
        else if (minHead_IDFilter !== undefined)
            url_ += "MinHead_IDFilter=" + encodeURIComponent("" + minHead_IDFilter) + "&"; 
        if (full_NameFilter === null)
            throw new Error("The parameter 'full_NameFilter' cannot be null.");
        else if (full_NameFilter !== undefined)
            url_ += "Full_NameFilter=" + encodeURIComponent("" + full_NameFilter) + "&"; 
        if (prefixFilter === null)
            throw new Error("The parameter 'prefixFilter' cannot be null.");
        else if (prefixFilter !== undefined)
            url_ += "PrefixFilter=" + encodeURIComponent("" + prefixFilter) + "&"; 
        if (maxHire_DateFilter === null)
            throw new Error("The parameter 'maxHire_DateFilter' cannot be null.");
        else if (maxHire_DateFilter !== undefined)
            url_ += "MaxHire_DateFilter=" + encodeURIComponent(maxHire_DateFilter ? "" + maxHire_DateFilter.toJSON() : "") + "&"; 
        if (minHire_DateFilter === null)
            throw new Error("The parameter 'minHire_DateFilter' cannot be null.");
        else if (minHire_DateFilter !== undefined)
            url_ += "MinHire_DateFilter=" + encodeURIComponent(minHire_DateFilter ? "" + minHire_DateFilter.toJSON() : "") + "&"; 
        if (keyWordFilter === null)
            throw new Error("The parameter 'keyWordFilter' cannot be null.");
        else if (keyWordFilter !== undefined)
            url_ += "KeyWordFilter=" + encodeURIComponent("" + keyWordFilter) + "&"; 
        if (maxIsActiveFilter === null)
            throw new Error("The parameter 'maxIsActiveFilter' cannot be null.");
        else if (maxIsActiveFilter !== undefined)
            url_ += "MaxIsActiveFilter=" + encodeURIComponent("" + maxIsActiveFilter) + "&"; 
        if (minIsActiveFilter === null)
            throw new Error("The parameter 'minIsActiveFilter' cannot be null.");
        else if (minIsActiveFilter !== undefined)
            url_ += "MinIsActiveFilter=" + encodeURIComponent("" + minIsActiveFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMemorize_KeywordsForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMemorize_KeywordsForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMemorize_KeywordsForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetMemorize_KeywordsForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetMemorize_KeywordsForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMemorize_KeywordsForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMemorize_KeywordsForView(id: number | undefined): Observable<GetMemorize_KeywordsForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Memorize_Keywordses/GetMemorize_KeywordsForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemorize_KeywordsForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemorize_KeywordsForView(<any>response_);
                } catch (e) {
                    return <Observable<GetMemorize_KeywordsForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemorize_KeywordsForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemorize_KeywordsForView(response: HttpResponseBase): Observable<GetMemorize_KeywordsForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemorize_KeywordsForViewDto.fromJS(resultData200) : new GetMemorize_KeywordsForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemorize_KeywordsForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMemorize_KeywordsForEdit(id: number | undefined): Observable<GetMemorize_KeywordsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Memorize_Keywordses/GetMemorize_KeywordsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemorize_KeywordsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemorize_KeywordsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMemorize_KeywordsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemorize_KeywordsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemorize_KeywordsForEdit(response: HttpResponseBase): Observable<GetMemorize_KeywordsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemorize_KeywordsForEditOutput.fromJS(resultData200) : new GetMemorize_KeywordsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemorize_KeywordsForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMemorize_KeywordsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Memorize_Keywordses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Memorize_Keywordses/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenGoiNhoFilter (optional) 
     * @param xuLyChinhFilter (optional) 
     * @param dongXuLyFilter (optional) 
     * @param deBietFilter (optional) 
     * @param maxHead_IDFilter (optional) 
     * @param minHead_IDFilter (optional) 
     * @param full_NameFilter (optional) 
     * @param prefixFilter (optional) 
     * @param maxHire_DateFilter (optional) 
     * @param minHire_DateFilter (optional) 
     * @param keyWordFilter (optional) 
     * @param maxIsActiveFilter (optional) 
     * @param minIsActiveFilter (optional) 
     * @return Success
     */
    getMemorize_KeywordsesToExcel(filter: string | undefined, tenGoiNhoFilter: string | undefined, xuLyChinhFilter: string | undefined, dongXuLyFilter: string | undefined, deBietFilter: string | undefined, maxHead_IDFilter: number | undefined, minHead_IDFilter: number | undefined, full_NameFilter: string | undefined, prefixFilter: string | undefined, maxHire_DateFilter: moment.Moment | undefined, minHire_DateFilter: moment.Moment | undefined, keyWordFilter: string | undefined, maxIsActiveFilter: number | undefined, minIsActiveFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Memorize_Keywordses/GetMemorize_KeywordsesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenGoiNhoFilter === null)
            throw new Error("The parameter 'tenGoiNhoFilter' cannot be null.");
        else if (tenGoiNhoFilter !== undefined)
            url_ += "TenGoiNhoFilter=" + encodeURIComponent("" + tenGoiNhoFilter) + "&"; 
        if (xuLyChinhFilter === null)
            throw new Error("The parameter 'xuLyChinhFilter' cannot be null.");
        else if (xuLyChinhFilter !== undefined)
            url_ += "XuLyChinhFilter=" + encodeURIComponent("" + xuLyChinhFilter) + "&"; 
        if (dongXuLyFilter === null)
            throw new Error("The parameter 'dongXuLyFilter' cannot be null.");
        else if (dongXuLyFilter !== undefined)
            url_ += "DongXuLyFilter=" + encodeURIComponent("" + dongXuLyFilter) + "&"; 
        if (deBietFilter === null)
            throw new Error("The parameter 'deBietFilter' cannot be null.");
        else if (deBietFilter !== undefined)
            url_ += "DeBietFilter=" + encodeURIComponent("" + deBietFilter) + "&"; 
        if (maxHead_IDFilter === null)
            throw new Error("The parameter 'maxHead_IDFilter' cannot be null.");
        else if (maxHead_IDFilter !== undefined)
            url_ += "MaxHead_IDFilter=" + encodeURIComponent("" + maxHead_IDFilter) + "&"; 
        if (minHead_IDFilter === null)
            throw new Error("The parameter 'minHead_IDFilter' cannot be null.");
        else if (minHead_IDFilter !== undefined)
            url_ += "MinHead_IDFilter=" + encodeURIComponent("" + minHead_IDFilter) + "&"; 
        if (full_NameFilter === null)
            throw new Error("The parameter 'full_NameFilter' cannot be null.");
        else if (full_NameFilter !== undefined)
            url_ += "Full_NameFilter=" + encodeURIComponent("" + full_NameFilter) + "&"; 
        if (prefixFilter === null)
            throw new Error("The parameter 'prefixFilter' cannot be null.");
        else if (prefixFilter !== undefined)
            url_ += "PrefixFilter=" + encodeURIComponent("" + prefixFilter) + "&"; 
        if (maxHire_DateFilter === null)
            throw new Error("The parameter 'maxHire_DateFilter' cannot be null.");
        else if (maxHire_DateFilter !== undefined)
            url_ += "MaxHire_DateFilter=" + encodeURIComponent(maxHire_DateFilter ? "" + maxHire_DateFilter.toJSON() : "") + "&"; 
        if (minHire_DateFilter === null)
            throw new Error("The parameter 'minHire_DateFilter' cannot be null.");
        else if (minHire_DateFilter !== undefined)
            url_ += "MinHire_DateFilter=" + encodeURIComponent(minHire_DateFilter ? "" + minHire_DateFilter.toJSON() : "") + "&"; 
        if (keyWordFilter === null)
            throw new Error("The parameter 'keyWordFilter' cannot be null.");
        else if (keyWordFilter !== undefined)
            url_ += "KeyWordFilter=" + encodeURIComponent("" + keyWordFilter) + "&"; 
        if (maxIsActiveFilter === null)
            throw new Error("The parameter 'maxIsActiveFilter' cannot be null.");
        else if (maxIsActiveFilter !== undefined)
            url_ += "MaxIsActiveFilter=" + encodeURIComponent("" + maxIsActiveFilter) + "&"; 
        if (minIsActiveFilter === null)
            throw new Error("The parameter 'minIsActiveFilter' cannot be null.");
        else if (minIsActiveFilter !== undefined)
            url_ += "MinIsActiveFilter=" + encodeURIComponent("" + minIsActiveFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemorize_KeywordsesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemorize_KeywordsesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemorize_KeywordsesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class MemorizeKeywordsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyWordFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, keyWordFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMemorizeKeywordForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MemorizeKeywords/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyWordFilter === null)
            throw new Error("The parameter 'keyWordFilter' cannot be null.");
        else if (keyWordFilter !== undefined)
            url_ += "KeyWordFilter=" + encodeURIComponent("" + keyWordFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMemorizeKeywordForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMemorizeKeywordForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMemorizeKeywordForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetMemorizeKeywordForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetMemorizeKeywordForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMemorizeKeywordForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMemorizeKeywordForView(id: number | undefined): Observable<GetMemorizeKeywordForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MemorizeKeywords/GetMemorizeKeywordForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemorizeKeywordForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemorizeKeywordForView(<any>response_);
                } catch (e) {
                    return <Observable<GetMemorizeKeywordForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemorizeKeywordForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemorizeKeywordForView(response: HttpResponseBase): Observable<GetMemorizeKeywordForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemorizeKeywordForViewDto.fromJS(resultData200) : new GetMemorizeKeywordForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemorizeKeywordForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMemorizeKeywordForEdit(id: number | undefined): Observable<GetMemorizeKeywordForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MemorizeKeywords/GetMemorizeKeywordForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemorizeKeywordForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemorizeKeywordForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMemorizeKeywordForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemorizeKeywordForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemorizeKeywordForEdit(response: HttpResponseBase): Observable<GetMemorizeKeywordForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemorizeKeywordForEditOutput.fromJS(resultData200) : new GetMemorizeKeywordForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemorizeKeywordForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMemorizeKeywordDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/MemorizeKeywords/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MemorizeKeywords/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param keyWordFilter (optional) 
     * @return Success
     */
    getMemorizeKeywordsToExcel(filter: string | undefined, keyWordFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MemorizeKeywords/GetMemorizeKeywordsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyWordFilter === null)
            throw new Error("The parameter 'keyWordFilter' cannot be null.");
        else if (keyWordFilter !== undefined)
            url_ += "KeyWordFilter=" + encodeURIComponent("" + keyWordFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemorizeKeywordsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemorizeKeywordsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemorizeKeywordsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMemorizeKeyword(): Observable<MemorizeKeywordDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MemorizeKeywords/GetAllMemorizeKeyword";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMemorizeKeyword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMemorizeKeyword(<any>response_);
                } catch (e) {
                    return <Observable<MemorizeKeywordDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemorizeKeywordDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMemorizeKeyword(response: HttpResponseBase): Observable<MemorizeKeywordDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MemorizeKeywordDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemorizeKeywordDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getKeywordDetails(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MemorizeKeywords/GetKeywordDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeywordDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeywordDetails(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeywordDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MenusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param titleFilter (optional) 
     * @param iconFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxParentFilter (optional) 
     * @param minParentFilter (optional) 
     * @param linkFilter (optional) 
     * @param maxCreationTimeFilter (optional) 
     * @param minCreationTimeFilter (optional) 
     * @param maxLastModificationTimeFilter (optional) 
     * @param minLastModificationTimeFilter (optional) 
     * @param isDeletedFilter (optional) 
     * @param maxDeletionTimeFilter (optional) 
     * @param minDeletionTimeFilter (optional) 
     * @param maxIndexFilter (optional) 
     * @param minIndexFilter (optional) 
     * @param requiredPermissionNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, titleFilter: string | undefined, iconFilter: string | undefined, descriptionFilter: string | undefined, maxParentFilter: number | undefined, minParentFilter: number | undefined, linkFilter: string | undefined, maxCreationTimeFilter: moment.Moment | undefined, minCreationTimeFilter: moment.Moment | undefined, maxLastModificationTimeFilter: moment.Moment | undefined, minLastModificationTimeFilter: moment.Moment | undefined, isDeletedFilter: number | undefined, maxDeletionTimeFilter: moment.Moment | undefined, minDeletionTimeFilter: moment.Moment | undefined, maxIndexFilter: number | undefined, minIndexFilter: number | undefined, requiredPermissionNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMenuForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (titleFilter === null)
            throw new Error("The parameter 'titleFilter' cannot be null.");
        else if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (iconFilter === null)
            throw new Error("The parameter 'iconFilter' cannot be null.");
        else if (iconFilter !== undefined)
            url_ += "IconFilter=" + encodeURIComponent("" + iconFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxParentFilter === null)
            throw new Error("The parameter 'maxParentFilter' cannot be null.");
        else if (maxParentFilter !== undefined)
            url_ += "MaxParentFilter=" + encodeURIComponent("" + maxParentFilter) + "&"; 
        if (minParentFilter === null)
            throw new Error("The parameter 'minParentFilter' cannot be null.");
        else if (minParentFilter !== undefined)
            url_ += "MinParentFilter=" + encodeURIComponent("" + minParentFilter) + "&"; 
        if (linkFilter === null)
            throw new Error("The parameter 'linkFilter' cannot be null.");
        else if (linkFilter !== undefined)
            url_ += "LinkFilter=" + encodeURIComponent("" + linkFilter) + "&"; 
        if (maxCreationTimeFilter === null)
            throw new Error("The parameter 'maxCreationTimeFilter' cannot be null.");
        else if (maxCreationTimeFilter !== undefined)
            url_ += "MaxCreationTimeFilter=" + encodeURIComponent(maxCreationTimeFilter ? "" + maxCreationTimeFilter.toJSON() : "") + "&"; 
        if (minCreationTimeFilter === null)
            throw new Error("The parameter 'minCreationTimeFilter' cannot be null.");
        else if (minCreationTimeFilter !== undefined)
            url_ += "MinCreationTimeFilter=" + encodeURIComponent(minCreationTimeFilter ? "" + minCreationTimeFilter.toJSON() : "") + "&"; 
        if (maxLastModificationTimeFilter === null)
            throw new Error("The parameter 'maxLastModificationTimeFilter' cannot be null.");
        else if (maxLastModificationTimeFilter !== undefined)
            url_ += "MaxLastModificationTimeFilter=" + encodeURIComponent(maxLastModificationTimeFilter ? "" + maxLastModificationTimeFilter.toJSON() : "") + "&"; 
        if (minLastModificationTimeFilter === null)
            throw new Error("The parameter 'minLastModificationTimeFilter' cannot be null.");
        else if (minLastModificationTimeFilter !== undefined)
            url_ += "MinLastModificationTimeFilter=" + encodeURIComponent(minLastModificationTimeFilter ? "" + minLastModificationTimeFilter.toJSON() : "") + "&"; 
        if (isDeletedFilter === null)
            throw new Error("The parameter 'isDeletedFilter' cannot be null.");
        else if (isDeletedFilter !== undefined)
            url_ += "IsDeletedFilter=" + encodeURIComponent("" + isDeletedFilter) + "&"; 
        if (maxDeletionTimeFilter === null)
            throw new Error("The parameter 'maxDeletionTimeFilter' cannot be null.");
        else if (maxDeletionTimeFilter !== undefined)
            url_ += "MaxDeletionTimeFilter=" + encodeURIComponent(maxDeletionTimeFilter ? "" + maxDeletionTimeFilter.toJSON() : "") + "&"; 
        if (minDeletionTimeFilter === null)
            throw new Error("The parameter 'minDeletionTimeFilter' cannot be null.");
        else if (minDeletionTimeFilter !== undefined)
            url_ += "MinDeletionTimeFilter=" + encodeURIComponent(minDeletionTimeFilter ? "" + minDeletionTimeFilter.toJSON() : "") + "&"; 
        if (maxIndexFilter === null)
            throw new Error("The parameter 'maxIndexFilter' cannot be null.");
        else if (maxIndexFilter !== undefined)
            url_ += "MaxIndexFilter=" + encodeURIComponent("" + maxIndexFilter) + "&"; 
        if (minIndexFilter === null)
            throw new Error("The parameter 'minIndexFilter' cannot be null.");
        else if (minIndexFilter !== undefined)
            url_ += "MinIndexFilter=" + encodeURIComponent("" + minIndexFilter) + "&"; 
        if (requiredPermissionNameFilter === null)
            throw new Error("The parameter 'requiredPermissionNameFilter' cannot be null.");
        else if (requiredPermissionNameFilter !== undefined)
            url_ += "RequiredPermissionNameFilter=" + encodeURIComponent("" + requiredPermissionNameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMenuForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMenuForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMenuForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetMenuForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetMenuForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMenuForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMenuForView(id: number | undefined): Observable<GetMenuForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetMenuForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuForView(<any>response_);
                } catch (e) {
                    return <Observable<GetMenuForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMenuForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenuForView(response: HttpResponseBase): Observable<GetMenuForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMenuForViewDto.fromJS(resultData200) : new GetMenuForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMenuForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMenuForEdit(id: number | undefined): Observable<GetMenuForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetMenuForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMenuForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMenuForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenuForEdit(response: HttpResponseBase): Observable<GetMenuForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMenuForEditOutput.fromJS(resultData200) : new GetMenuForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMenuForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMenuDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Menus/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Menus/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param titleFilter (optional) 
     * @param iconFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxParentFilter (optional) 
     * @param minParentFilter (optional) 
     * @param linkFilter (optional) 
     * @param maxCreationTimeFilter (optional) 
     * @param minCreationTimeFilter (optional) 
     * @param maxLastModificationTimeFilter (optional) 
     * @param minLastModificationTimeFilter (optional) 
     * @param isDeletedFilter (optional) 
     * @param maxDeletionTimeFilter (optional) 
     * @param minDeletionTimeFilter (optional) 
     * @param maxIndexFilter (optional) 
     * @param minIndexFilter (optional) 
     * @param requiredPermissionNameFilter (optional) 
     * @return Success
     */
    getMenusToExcel(filter: string | undefined, nameFilter: string | undefined, titleFilter: string | undefined, iconFilter: string | undefined, descriptionFilter: string | undefined, maxParentFilter: number | undefined, minParentFilter: number | undefined, linkFilter: string | undefined, maxCreationTimeFilter: moment.Moment | undefined, minCreationTimeFilter: moment.Moment | undefined, maxLastModificationTimeFilter: moment.Moment | undefined, minLastModificationTimeFilter: moment.Moment | undefined, isDeletedFilter: number | undefined, maxDeletionTimeFilter: moment.Moment | undefined, minDeletionTimeFilter: moment.Moment | undefined, maxIndexFilter: number | undefined, minIndexFilter: number | undefined, requiredPermissionNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetMenusToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (titleFilter === null)
            throw new Error("The parameter 'titleFilter' cannot be null.");
        else if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (iconFilter === null)
            throw new Error("The parameter 'iconFilter' cannot be null.");
        else if (iconFilter !== undefined)
            url_ += "IconFilter=" + encodeURIComponent("" + iconFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxParentFilter === null)
            throw new Error("The parameter 'maxParentFilter' cannot be null.");
        else if (maxParentFilter !== undefined)
            url_ += "MaxParentFilter=" + encodeURIComponent("" + maxParentFilter) + "&"; 
        if (minParentFilter === null)
            throw new Error("The parameter 'minParentFilter' cannot be null.");
        else if (minParentFilter !== undefined)
            url_ += "MinParentFilter=" + encodeURIComponent("" + minParentFilter) + "&"; 
        if (linkFilter === null)
            throw new Error("The parameter 'linkFilter' cannot be null.");
        else if (linkFilter !== undefined)
            url_ += "LinkFilter=" + encodeURIComponent("" + linkFilter) + "&"; 
        if (maxCreationTimeFilter === null)
            throw new Error("The parameter 'maxCreationTimeFilter' cannot be null.");
        else if (maxCreationTimeFilter !== undefined)
            url_ += "MaxCreationTimeFilter=" + encodeURIComponent(maxCreationTimeFilter ? "" + maxCreationTimeFilter.toJSON() : "") + "&"; 
        if (minCreationTimeFilter === null)
            throw new Error("The parameter 'minCreationTimeFilter' cannot be null.");
        else if (minCreationTimeFilter !== undefined)
            url_ += "MinCreationTimeFilter=" + encodeURIComponent(minCreationTimeFilter ? "" + minCreationTimeFilter.toJSON() : "") + "&"; 
        if (maxLastModificationTimeFilter === null)
            throw new Error("The parameter 'maxLastModificationTimeFilter' cannot be null.");
        else if (maxLastModificationTimeFilter !== undefined)
            url_ += "MaxLastModificationTimeFilter=" + encodeURIComponent(maxLastModificationTimeFilter ? "" + maxLastModificationTimeFilter.toJSON() : "") + "&"; 
        if (minLastModificationTimeFilter === null)
            throw new Error("The parameter 'minLastModificationTimeFilter' cannot be null.");
        else if (minLastModificationTimeFilter !== undefined)
            url_ += "MinLastModificationTimeFilter=" + encodeURIComponent(minLastModificationTimeFilter ? "" + minLastModificationTimeFilter.toJSON() : "") + "&"; 
        if (isDeletedFilter === null)
            throw new Error("The parameter 'isDeletedFilter' cannot be null.");
        else if (isDeletedFilter !== undefined)
            url_ += "IsDeletedFilter=" + encodeURIComponent("" + isDeletedFilter) + "&"; 
        if (maxDeletionTimeFilter === null)
            throw new Error("The parameter 'maxDeletionTimeFilter' cannot be null.");
        else if (maxDeletionTimeFilter !== undefined)
            url_ += "MaxDeletionTimeFilter=" + encodeURIComponent(maxDeletionTimeFilter ? "" + maxDeletionTimeFilter.toJSON() : "") + "&"; 
        if (minDeletionTimeFilter === null)
            throw new Error("The parameter 'minDeletionTimeFilter' cannot be null.");
        else if (minDeletionTimeFilter !== undefined)
            url_ += "MinDeletionTimeFilter=" + encodeURIComponent(minDeletionTimeFilter ? "" + minDeletionTimeFilter.toJSON() : "") + "&"; 
        if (maxIndexFilter === null)
            throw new Error("The parameter 'maxIndexFilter' cannot be null.");
        else if (maxIndexFilter !== undefined)
            url_ += "MaxIndexFilter=" + encodeURIComponent("" + maxIndexFilter) + "&"; 
        if (minIndexFilter === null)
            throw new Error("The parameter 'minIndexFilter' cannot be null.");
        else if (minIndexFilter !== undefined)
            url_ += "MinIndexFilter=" + encodeURIComponent("" + minIndexFilter) + "&"; 
        if (requiredPermissionNameFilter === null)
            throw new Error("The parameter 'requiredPermissionNameFilter' cannot be null.");
        else if (requiredPermissionNameFilter !== undefined)
            url_ += "RequiredPermissionNameFilter=" + encodeURIComponent("" + requiredPermissionNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenusToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenusToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenusToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRootPermissions(): Observable<PermissionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetRootPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRootPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRootPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRootPermissions(response: HttpResponseBase): Observable<PermissionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PermissionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDto[]>(<any>null);
    }

    /**
     * @param name (optional) 
     * @param type (optional) 
     * @return Success
     */
    getList(name: string | undefined, type: string | undefined): Observable<MenuDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetList?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<MenuDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<MenuDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MenuDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMenuDto(): Observable<MenuDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetAllMenuDto";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMenuDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMenuDto(<any>response_);
                } catch (e) {
                    return <Observable<MenuDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMenuDto(response: HttpResponseBase): Observable<MenuDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MenuDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllActive(): Observable<PagedResultDtoOfGetMenusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetAllActive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActive(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMenusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMenusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllActive(response: HttpResponseBase): Observable<PagedResultDtoOfGetMenusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetMenusForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetMenusForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMenusForViewDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getDetail(input: number | undefined): Observable<MenuDto> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetDetail?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<MenuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<MenuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuDto.fromJS(resultData200) : new MenuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllIndices(): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetAllIndices";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIndices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIndices(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIndices(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param index (optional) 
     * @return Success
     */
    getIndexById(id: number | undefined, index: number | undefined): Observable<IdNameDto> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetIndexById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (index === null)
            throw new Error("The parameter 'index' cannot be null.");
        else if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndexById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndexById(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndexById(response: HttpResponseBase): Observable<IdNameDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IdNameDto.fromJS(resultData200) : new IdNameDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto>(<any>null);
    }

    /**
     * @param parent (optional) 
     * @return Success
     */
    getAllChildMenu(parent: number | undefined): Observable<MenuDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetAllChildMenu?";
        if (parent === null)
            throw new Error("The parameter 'parent' cannot be null.");
        else if (parent !== undefined)
            url_ += "parent=" + encodeURIComponent("" + parent) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChildMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChildMenu(<any>response_);
                } catch (e) {
                    return <Observable<MenuDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChildMenu(response: HttpResponseBase): Observable<MenuDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MenuDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTopMenu(): Observable<PagedResultDtoOfMenuDto> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetAllTopMenu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTopMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTopMenu(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMenuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMenuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTopMenu(response: HttpResponseBase): Observable<PagedResultDtoOfMenuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMenuDto.fromJS(resultData200) : new PagedResultDtoOfMenuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMenuDto>(<any>null);
    }

    /**
     * @param parentMenuId (optional) 
     * @return Success
     */
    getAllSideBarMenu(parentMenuId: number | undefined): Observable<PagedResultDtoOfMenuDto> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetAllSideBarMenu?";
        if (parentMenuId === null)
            throw new Error("The parameter 'parentMenuId' cannot be null.");
        else if (parentMenuId !== undefined)
            url_ += "parentMenuId=" + encodeURIComponent("" + parentMenuId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSideBarMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSideBarMenu(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMenuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMenuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSideBarMenu(response: HttpResponseBase): Observable<PagedResultDtoOfMenuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMenuDto.fromJS(resultData200) : new PagedResultDtoOfMenuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMenuDto>(<any>null);
    }

    /**
     * @param name (optional) 
     * @param type (optional) 
     * @return Success
     */
    getFullMenu(name: string | undefined, type: string | undefined): Observable<MenuDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetFullMenu?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullMenu(<any>response_);
                } catch (e) {
                    return <Observable<MenuDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFullMenu(response: HttpResponseBase): Observable<MenuDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MenuDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMenuActive(): Observable<MenuDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Menus/GetAllMenuActive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMenuActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMenuActive(<any>response_);
                } catch (e) {
                    return <Observable<MenuDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMenuActive(response: HttpResponseBase): Observable<MenuDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MenuDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuDto[]>(<any>null);
    }
}

@Injectable()
export class NoiDaoTaosServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param ten (optional) 
     * @return Success
     */
    checkNoiDaoTaoName(ten: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/NoiDaoTaos/CheckNoiDaoTaoName?";
        if (ten === null)
            throw new Error("The parameter 'ten' cannot be null.");
        else if (ten !== undefined)
            url_ += "ten=" + encodeURIComponent("" + ten) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckNoiDaoTaoName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckNoiDaoTaoName(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckNoiDaoTaoName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    checkNoiDaoTaoCode(code: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/NoiDaoTaos/CheckNoiDaoTaoCode?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckNoiDaoTaoCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckNoiDaoTaoCode(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckNoiDaoTaoCode(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getAllNoiDaoTao(): Observable<NoiDaoTaoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/NoiDaoTaos/GetAllNoiDaoTao";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNoiDaoTao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNoiDaoTao(<any>response_);
                } catch (e) {
                    return <Observable<NoiDaoTaoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NoiDaoTaoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNoiDaoTao(response: HttpResponseBase): Observable<NoiDaoTaoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NoiDaoTaoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoiDaoTaoDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenNoiDaoTaoFilter (optional) 
     * @param maNoiDaoTaoFilter (optional) 
     * @param diaChiFilter (optional) 
     * @param khuVucFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, tenNoiDaoTaoFilter: string | undefined, maNoiDaoTaoFilter: string | undefined, diaChiFilter: string | undefined, khuVucFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetNoiDaoTaoForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/NoiDaoTaos/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenNoiDaoTaoFilter === null)
            throw new Error("The parameter 'tenNoiDaoTaoFilter' cannot be null.");
        else if (tenNoiDaoTaoFilter !== undefined)
            url_ += "TenNoiDaoTaoFilter=" + encodeURIComponent("" + tenNoiDaoTaoFilter) + "&"; 
        if (maNoiDaoTaoFilter === null)
            throw new Error("The parameter 'maNoiDaoTaoFilter' cannot be null.");
        else if (maNoiDaoTaoFilter !== undefined)
            url_ += "MaNoiDaoTaoFilter=" + encodeURIComponent("" + maNoiDaoTaoFilter) + "&"; 
        if (diaChiFilter === null)
            throw new Error("The parameter 'diaChiFilter' cannot be null.");
        else if (diaChiFilter !== undefined)
            url_ += "DiaChiFilter=" + encodeURIComponent("" + diaChiFilter) + "&"; 
        if (khuVucFilter === null)
            throw new Error("The parameter 'khuVucFilter' cannot be null.");
        else if (khuVucFilter !== undefined)
            url_ += "KhuVucFilter=" + encodeURIComponent("" + khuVucFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetNoiDaoTaoForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetNoiDaoTaoForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetNoiDaoTaoForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetNoiDaoTaoForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetNoiDaoTaoForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetNoiDaoTaoForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getNoiDaoTaoForView(id: number | undefined): Observable<GetNoiDaoTaoForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/NoiDaoTaos/GetNoiDaoTaoForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoiDaoTaoForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoiDaoTaoForView(<any>response_);
                } catch (e) {
                    return <Observable<GetNoiDaoTaoForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNoiDaoTaoForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNoiDaoTaoForView(response: HttpResponseBase): Observable<GetNoiDaoTaoForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNoiDaoTaoForViewDto.fromJS(resultData200) : new GetNoiDaoTaoForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNoiDaoTaoForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getNoiDaoTaoForEdit(id: number | undefined): Observable<GetNoiDaoTaoForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/NoiDaoTaos/GetNoiDaoTaoForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoiDaoTaoForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoiDaoTaoForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetNoiDaoTaoForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNoiDaoTaoForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNoiDaoTaoForEdit(response: HttpResponseBase): Observable<GetNoiDaoTaoForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNoiDaoTaoForEditOutput.fromJS(resultData200) : new GetNoiDaoTaoForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNoiDaoTaoForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditNoiDaoTaoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NoiDaoTaos/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NoiDaoTaos/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenNoiDaoTaoFilter (optional) 
     * @param maNoiDaoTaoFilter (optional) 
     * @param diaChiFilter (optional) 
     * @param khuVucFilter (optional) 
     * @return Success
     */
    getNoiDaoTaosToExcel(filter: string | undefined, tenNoiDaoTaoFilter: string | undefined, maNoiDaoTaoFilter: string | undefined, diaChiFilter: string | undefined, khuVucFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/NoiDaoTaos/GetNoiDaoTaosToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenNoiDaoTaoFilter === null)
            throw new Error("The parameter 'tenNoiDaoTaoFilter' cannot be null.");
        else if (tenNoiDaoTaoFilter !== undefined)
            url_ += "TenNoiDaoTaoFilter=" + encodeURIComponent("" + tenNoiDaoTaoFilter) + "&"; 
        if (maNoiDaoTaoFilter === null)
            throw new Error("The parameter 'maNoiDaoTaoFilter' cannot be null.");
        else if (maNoiDaoTaoFilter !== undefined)
            url_ += "MaNoiDaoTaoFilter=" + encodeURIComponent("" + maNoiDaoTaoFilter) + "&"; 
        if (diaChiFilter === null)
            throw new Error("The parameter 'diaChiFilter' cannot be null.");
        else if (diaChiFilter !== undefined)
            url_ += "DiaChiFilter=" + encodeURIComponent("" + diaChiFilter) + "&"; 
        if (khuVucFilter === null)
            throw new Error("The parameter 'khuVucFilter' cannot be null.");
        else if (khuVucFilter !== undefined)
            url_ += "KhuVucFilter=" + encodeURIComponent("" + khuVucFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoiDaoTaosToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoiDaoTaosToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNoiDaoTaosToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setNotificationAsRead(body: EntityDtoOfGuid | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    deleteAllUserNotifications(state: UserNotificationState | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteAllUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAllUserNotifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllUnit(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetAllUnit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUnit(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUnit(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfOrganizationUnitDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(body: RolesToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findRoles(body: FindOrganizationUnitRolesInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId === null)
            throw new Error("The parameter 'upgradeEditionId' cannot be null.");
        else if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentInfoDto.fromJS(resultData200) : new PaymentInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPayment(body: CreatePaymentDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelPayment(body: CancelPaymentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200) : new PagedResultDtoOfSubscriptionPaymentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled === null)
            throw new Error("The parameter 'recurringPaymentsEnabled' cannot be null.");
        else if (recurringPaymentsEnabled !== undefined)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(<any>response_);
                } catch (e) {
                    return <Observable<PaymentGatewayModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentGatewayModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PaymentGatewayModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentGatewayModel[]>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPayment(paymentId: number | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionPaymentDto.fromJS(resultData200) : new SubscriptionPaymentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionPaymentDto.fromJS(resultData200) : new SubscriptionPaymentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalOrderId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | undefined, paypalOrderId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        if (paypalOrderId === null)
            throw new Error("The parameter 'paypalOrderId' cannot be null.");
        else if (paypalOrderId !== undefined)
            url_ += "paypalOrderId=" + encodeURIComponent("" + paypalOrderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<PayPalConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PayPalConfigurationDto.fromJS(resultData200) : new PayPalConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalConfigurationDto>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200) : new ListResultDtoOfFlatPermissionWithLevelDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }
}

@Injectable()
export class PrioritiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param maxValueFilter (optional) 
     * @param minValueFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, keyFilter: string | undefined, maxValueFilter: number | undefined, minValueFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetPriorityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Priorities/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter === null)
            throw new Error("The parameter 'keyFilter' cannot be null.");
        else if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (maxValueFilter === null)
            throw new Error("The parameter 'maxValueFilter' cannot be null.");
        else if (maxValueFilter !== undefined)
            url_ += "MaxValueFilter=" + encodeURIComponent("" + maxValueFilter) + "&"; 
        if (minValueFilter === null)
            throw new Error("The parameter 'minValueFilter' cannot be null.");
        else if (minValueFilter !== undefined)
            url_ += "MinValueFilter=" + encodeURIComponent("" + minValueFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPriorityForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPriorityForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetPriorityForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetPriorityForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetPriorityForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPriorityForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPriorityForView(id: number | undefined): Observable<GetPriorityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Priorities/GetPriorityForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPriorityForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPriorityForView(<any>response_);
                } catch (e) {
                    return <Observable<GetPriorityForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPriorityForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPriorityForView(response: HttpResponseBase): Observable<GetPriorityForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPriorityForViewDto.fromJS(resultData200) : new GetPriorityForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPriorityForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPriorityForEdit(id: number | undefined): Observable<GetPriorityForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Priorities/GetPriorityForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPriorityForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPriorityForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPriorityForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPriorityForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPriorityForEdit(response: HttpResponseBase): Observable<GetPriorityForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPriorityForEditOutput.fromJS(resultData200) : new GetPriorityForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPriorityForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditPriorityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Priorities/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Priorities/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPriorities(): Observable<PriorityDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Priorities/GetAllPriorities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPriorities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPriorities(<any>response_);
                } catch (e) {
                    return <Observable<PriorityDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PriorityDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPriorities(response: HttpResponseBase): Observable<PriorityDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PriorityDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PriorityDto[]>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    disableGoogleAuthenticator(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/DisableGoogleAuthenticator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableGoogleAuthenticator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableGoogleAuthenticator(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableGoogleAuthenticator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200) : new UpdateGoogleAuthenticatorKeyOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendVerificationSms(body: SendVerificationSmsInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifySmsCode(body: VerifySmsCodeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfilePicture(body: UpdateProfilePictureInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPasswordComplexitySettingOutput.fromJS(resultData200) : new GetPasswordComplexitySettingOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | undefined, userId: number | undefined, tenantId: number | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePictureById?";
        if (profilePictureId === null)
            throw new Error("The parameter 'profilePictureId' cannot be null.");
        else if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId === null)
            throw new Error("The parameter 'profilePictureId' cannot be null.");
        else if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PromulgatedsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param displayNameFilter (optional) 
     * @param representativeFilter (optional) 
     * @param leaderFilter (optional) 
     * @param positionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, displayNameFilter: string | undefined, representativeFilter: string | undefined, leaderFilter: string | undefined, positionFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetPromulgatedForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Promulgateds/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (displayNameFilter === null)
            throw new Error("The parameter 'displayNameFilter' cannot be null.");
        else if (displayNameFilter !== undefined)
            url_ += "DisplayNameFilter=" + encodeURIComponent("" + displayNameFilter) + "&"; 
        if (representativeFilter === null)
            throw new Error("The parameter 'representativeFilter' cannot be null.");
        else if (representativeFilter !== undefined)
            url_ += "RepresentativeFilter=" + encodeURIComponent("" + representativeFilter) + "&"; 
        if (leaderFilter === null)
            throw new Error("The parameter 'leaderFilter' cannot be null.");
        else if (leaderFilter !== undefined)
            url_ += "LeaderFilter=" + encodeURIComponent("" + leaderFilter) + "&"; 
        if (positionFilter === null)
            throw new Error("The parameter 'positionFilter' cannot be null.");
        else if (positionFilter !== undefined)
            url_ += "PositionFilter=" + encodeURIComponent("" + positionFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPromulgatedForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPromulgatedForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetPromulgatedForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetPromulgatedForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetPromulgatedForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPromulgatedForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPromulgatedForView(id: number | undefined): Observable<GetPromulgatedForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Promulgateds/GetPromulgatedForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPromulgatedForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPromulgatedForView(<any>response_);
                } catch (e) {
                    return <Observable<GetPromulgatedForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPromulgatedForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPromulgatedForView(response: HttpResponseBase): Observable<GetPromulgatedForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPromulgatedForViewDto.fromJS(resultData200) : new GetPromulgatedForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPromulgatedForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPromulgatedForEdit(id: number | undefined): Observable<GetPromulgatedForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Promulgateds/GetPromulgatedForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPromulgatedForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPromulgatedForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPromulgatedForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPromulgatedForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPromulgatedForEdit(response: HttpResponseBase): Observable<GetPromulgatedForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPromulgatedForEditOutput.fromJS(resultData200) : new GetPromulgatedForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPromulgatedForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditPromulgatedDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Promulgateds/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Promulgateds/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param displayNameFilter (optional) 
     * @param representativeFilter (optional) 
     * @param leaderFilter (optional) 
     * @param positionFilter (optional) 
     * @return Success
     */
    getPromulgatedsToExcel(filter: string | undefined, nameFilter: string | undefined, displayNameFilter: string | undefined, representativeFilter: string | undefined, leaderFilter: string | undefined, positionFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Promulgateds/GetPromulgatedsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (displayNameFilter === null)
            throw new Error("The parameter 'displayNameFilter' cannot be null.");
        else if (displayNameFilter !== undefined)
            url_ += "DisplayNameFilter=" + encodeURIComponent("" + displayNameFilter) + "&"; 
        if (representativeFilter === null)
            throw new Error("The parameter 'representativeFilter' cannot be null.");
        else if (representativeFilter !== undefined)
            url_ += "RepresentativeFilter=" + encodeURIComponent("" + representativeFilter) + "&"; 
        if (leaderFilter === null)
            throw new Error("The parameter 'leaderFilter' cannot be null.");
        else if (leaderFilter !== undefined)
            url_ += "LeaderFilter=" + encodeURIComponent("" + leaderFilter) + "&"; 
        if (positionFilter === null)
            throw new Error("The parameter 'positionFilter' cannot be null.");
        else if (positionFilter !== undefined)
            url_ += "PositionFilter=" + encodeURIComponent("" + positionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPromulgatedsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPromulgatedsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPromulgatedsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPromulgated(): Observable<PromulgatedDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Promulgateds/GetAllPromulgated";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPromulgated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPromulgated(<any>response_);
                } catch (e) {
                    return <Observable<PromulgatedDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PromulgatedDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPromulgated(response: HttpResponseBase): Observable<PromulgatedDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PromulgatedDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PromulgatedDto[]>(<any>null);
    }
}

@Injectable()
export class QuanLyNghiPhepsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOrganizationUnitForEdit(id: number | undefined): Observable<GetOrganizationUnitForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyNghiPheps/GetOrganizationUnitForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetOrganizationUnitForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOrganizationUnitForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitForEdit(response: HttpResponseBase): Observable<GetOrganizationUnitForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetOrganizationUnitForEditOutput.fromJS(resultData200) : new GetOrganizationUnitForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOrganizationUnitForEditOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUser(): Observable<UserListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyNghiPheps/GetAllUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUser(<any>response_);
                } catch (e) {
                    return <Observable<UserListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUser(response: HttpResponseBase): Observable<UserListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPhieuNghiPhep(): Observable<QuanLyNghiPhepDto[]> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyNghiPheps/GetAllPhieuNghiPhep";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPhieuNghiPhep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPhieuNghiPhep(<any>response_);
                } catch (e) {
                    return <Observable<QuanLyNghiPhepDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuanLyNghiPhepDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPhieuNghiPhep(response: HttpResponseBase): Observable<QuanLyNghiPhepDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(QuanLyNghiPhepDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuanLyNghiPhepDto[]>(<any>null);
    }

    /**
     * @param maNVFilter (optional) 
     * @return Success
     */
    getAllPhieuNghiPhepToMaNV(maNVFilter: string | undefined): Observable<QuanLyNghiPhepDto[]> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyNghiPheps/GetAllPhieuNghiPhepToMaNV?";
        if (maNVFilter === null)
            throw new Error("The parameter 'maNVFilter' cannot be null.");
        else if (maNVFilter !== undefined)
            url_ += "MaNVFilter=" + encodeURIComponent("" + maNVFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPhieuNghiPhepToMaNV(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPhieuNghiPhepToMaNV(<any>response_);
                } catch (e) {
                    return <Observable<QuanLyNghiPhepDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuanLyNghiPhepDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPhieuNghiPhepToMaNV(response: HttpResponseBase): Observable<QuanLyNghiPhepDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(QuanLyNghiPhepDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuanLyNghiPhepDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenNhanVienFilter (optional) 
     * @param maNVFilter (optional) 
     * @param nghiPhepFilter (optional) 
     * @param congTacFilter (optional) 
     * @param tangCaFilter (optional) 
     * @param maxNgayBatDauFilter (optional) 
     * @param minNgayBatDauFilter (optional) 
     * @param maxNgayKetThucFilter (optional) 
     * @param minNgayKetThucFilter (optional) 
     * @param lyDoFilter (optional) 
     * @param tepDinhKemFilter (optional) 
     * @param tenCTYFilter (optional) 
     * @param maxNguoiDuyetIDFilter (optional) 
     * @param minNguoiDuyetIDFilter (optional) 
     * @param maxNgayDuyetFilter (optional) 
     * @param minNgayDuyetFilter (optional) 
     * @param trangThaiIDFilter (optional) 
     * @param donViCongTacIDFilter (optional) 
     * @param quanLyTrucTiepIDFilter (optional) 
     * @param isCheckTimeFilter (optional) 
     * @param createTimeFilter (optional) 
     * @param lastModificationTimeFilter (optional) 
     * @param startDateFilter (optional) 
     * @param endDateFilter (optional) 
     * @param roleIDFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, tenNhanVienFilter: string | undefined, maNVFilter: string | undefined, nghiPhepFilter: number | undefined, congTacFilter: number | undefined, tangCaFilter: number | undefined, maxNgayBatDauFilter: moment.Moment | undefined, minNgayBatDauFilter: moment.Moment | undefined, maxNgayKetThucFilter: moment.Moment | undefined, minNgayKetThucFilter: moment.Moment | undefined, lyDoFilter: string | undefined, tepDinhKemFilter: string | undefined, tenCTYFilter: string | undefined, maxNguoiDuyetIDFilter: number | undefined, minNguoiDuyetIDFilter: number | undefined, maxNgayDuyetFilter: moment.Moment | undefined, minNgayDuyetFilter: moment.Moment | undefined, trangThaiIDFilter: number | undefined, donViCongTacIDFilter: number | undefined, quanLyTrucTiepIDFilter: number | undefined, isCheckTimeFilter: boolean | undefined, createTimeFilter: moment.Moment | undefined, lastModificationTimeFilter: moment.Moment | undefined, startDateFilter: moment.Moment | undefined, endDateFilter: moment.Moment | undefined, roleIDFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetQuanLyNghiPhepForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyNghiPheps/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenNhanVienFilter === null)
            throw new Error("The parameter 'tenNhanVienFilter' cannot be null.");
        else if (tenNhanVienFilter !== undefined)
            url_ += "TenNhanVienFilter=" + encodeURIComponent("" + tenNhanVienFilter) + "&"; 
        if (maNVFilter === null)
            throw new Error("The parameter 'maNVFilter' cannot be null.");
        else if (maNVFilter !== undefined)
            url_ += "MaNVFilter=" + encodeURIComponent("" + maNVFilter) + "&"; 
        if (nghiPhepFilter === null)
            throw new Error("The parameter 'nghiPhepFilter' cannot be null.");
        else if (nghiPhepFilter !== undefined)
            url_ += "NghiPhepFilter=" + encodeURIComponent("" + nghiPhepFilter) + "&"; 
        if (congTacFilter === null)
            throw new Error("The parameter 'congTacFilter' cannot be null.");
        else if (congTacFilter !== undefined)
            url_ += "CongTacFilter=" + encodeURIComponent("" + congTacFilter) + "&"; 
        if (tangCaFilter === null)
            throw new Error("The parameter 'tangCaFilter' cannot be null.");
        else if (tangCaFilter !== undefined)
            url_ += "TangCaFilter=" + encodeURIComponent("" + tangCaFilter) + "&"; 
        if (maxNgayBatDauFilter === null)
            throw new Error("The parameter 'maxNgayBatDauFilter' cannot be null.");
        else if (maxNgayBatDauFilter !== undefined)
            url_ += "MaxNgayBatDauFilter=" + encodeURIComponent(maxNgayBatDauFilter ? "" + maxNgayBatDauFilter.toJSON() : "") + "&"; 
        if (minNgayBatDauFilter === null)
            throw new Error("The parameter 'minNgayBatDauFilter' cannot be null.");
        else if (minNgayBatDauFilter !== undefined)
            url_ += "MinNgayBatDauFilter=" + encodeURIComponent(minNgayBatDauFilter ? "" + minNgayBatDauFilter.toJSON() : "") + "&"; 
        if (maxNgayKetThucFilter === null)
            throw new Error("The parameter 'maxNgayKetThucFilter' cannot be null.");
        else if (maxNgayKetThucFilter !== undefined)
            url_ += "MaxNgayKetThucFilter=" + encodeURIComponent(maxNgayKetThucFilter ? "" + maxNgayKetThucFilter.toJSON() : "") + "&"; 
        if (minNgayKetThucFilter === null)
            throw new Error("The parameter 'minNgayKetThucFilter' cannot be null.");
        else if (minNgayKetThucFilter !== undefined)
            url_ += "MinNgayKetThucFilter=" + encodeURIComponent(minNgayKetThucFilter ? "" + minNgayKetThucFilter.toJSON() : "") + "&"; 
        if (lyDoFilter === null)
            throw new Error("The parameter 'lyDoFilter' cannot be null.");
        else if (lyDoFilter !== undefined)
            url_ += "LyDoFilter=" + encodeURIComponent("" + lyDoFilter) + "&"; 
        if (tepDinhKemFilter === null)
            throw new Error("The parameter 'tepDinhKemFilter' cannot be null.");
        else if (tepDinhKemFilter !== undefined)
            url_ += "TepDinhKemFilter=" + encodeURIComponent("" + tepDinhKemFilter) + "&"; 
        if (tenCTYFilter === null)
            throw new Error("The parameter 'tenCTYFilter' cannot be null.");
        else if (tenCTYFilter !== undefined)
            url_ += "TenCTYFilter=" + encodeURIComponent("" + tenCTYFilter) + "&"; 
        if (maxNguoiDuyetIDFilter === null)
            throw new Error("The parameter 'maxNguoiDuyetIDFilter' cannot be null.");
        else if (maxNguoiDuyetIDFilter !== undefined)
            url_ += "MaxNguoiDuyetIDFilter=" + encodeURIComponent("" + maxNguoiDuyetIDFilter) + "&"; 
        if (minNguoiDuyetIDFilter === null)
            throw new Error("The parameter 'minNguoiDuyetIDFilter' cannot be null.");
        else if (minNguoiDuyetIDFilter !== undefined)
            url_ += "MinNguoiDuyetIDFilter=" + encodeURIComponent("" + minNguoiDuyetIDFilter) + "&"; 
        if (maxNgayDuyetFilter === null)
            throw new Error("The parameter 'maxNgayDuyetFilter' cannot be null.");
        else if (maxNgayDuyetFilter !== undefined)
            url_ += "MaxNgayDuyetFilter=" + encodeURIComponent(maxNgayDuyetFilter ? "" + maxNgayDuyetFilter.toJSON() : "") + "&"; 
        if (minNgayDuyetFilter === null)
            throw new Error("The parameter 'minNgayDuyetFilter' cannot be null.");
        else if (minNgayDuyetFilter !== undefined)
            url_ += "MinNgayDuyetFilter=" + encodeURIComponent(minNgayDuyetFilter ? "" + minNgayDuyetFilter.toJSON() : "") + "&"; 
        if (trangThaiIDFilter === null)
            throw new Error("The parameter 'trangThaiIDFilter' cannot be null.");
        else if (trangThaiIDFilter !== undefined)
            url_ += "TrangThaiIDFilter=" + encodeURIComponent("" + trangThaiIDFilter) + "&"; 
        if (donViCongTacIDFilter === null)
            throw new Error("The parameter 'donViCongTacIDFilter' cannot be null.");
        else if (donViCongTacIDFilter !== undefined)
            url_ += "DonViCongTacIDFilter=" + encodeURIComponent("" + donViCongTacIDFilter) + "&"; 
        if (quanLyTrucTiepIDFilter === null)
            throw new Error("The parameter 'quanLyTrucTiepIDFilter' cannot be null.");
        else if (quanLyTrucTiepIDFilter !== undefined)
            url_ += "QuanLyTrucTiepIDFilter=" + encodeURIComponent("" + quanLyTrucTiepIDFilter) + "&"; 
        if (isCheckTimeFilter === null)
            throw new Error("The parameter 'isCheckTimeFilter' cannot be null.");
        else if (isCheckTimeFilter !== undefined)
            url_ += "isCheckTimeFilter=" + encodeURIComponent("" + isCheckTimeFilter) + "&"; 
        if (createTimeFilter === null)
            throw new Error("The parameter 'createTimeFilter' cannot be null.");
        else if (createTimeFilter !== undefined)
            url_ += "CreateTimeFilter=" + encodeURIComponent(createTimeFilter ? "" + createTimeFilter.toJSON() : "") + "&"; 
        if (lastModificationTimeFilter === null)
            throw new Error("The parameter 'lastModificationTimeFilter' cannot be null.");
        else if (lastModificationTimeFilter !== undefined)
            url_ += "LastModificationTimeFilter=" + encodeURIComponent(lastModificationTimeFilter ? "" + lastModificationTimeFilter.toJSON() : "") + "&"; 
        if (startDateFilter === null)
            throw new Error("The parameter 'startDateFilter' cannot be null.");
        else if (startDateFilter !== undefined)
            url_ += "StartDateFilter=" + encodeURIComponent(startDateFilter ? "" + startDateFilter.toJSON() : "") + "&"; 
        if (endDateFilter === null)
            throw new Error("The parameter 'endDateFilter' cannot be null.");
        else if (endDateFilter !== undefined)
            url_ += "EndDateFilter=" + encodeURIComponent(endDateFilter ? "" + endDateFilter.toJSON() : "") + "&"; 
        if (roleIDFilter === null)
            throw new Error("The parameter 'roleIDFilter' cannot be null.");
        else if (roleIDFilter !== undefined)
            url_ += "RoleIDFilter=" + encodeURIComponent("" + roleIDFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetQuanLyNghiPhepForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetQuanLyNghiPhepForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetQuanLyNghiPhepForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetQuanLyNghiPhepForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetQuanLyNghiPhepForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetQuanLyNghiPhepForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getQuanLyNghiPhepForView(id: number | undefined): Observable<GetQuanLyNghiPhepForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyNghiPheps/GetQuanLyNghiPhepForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuanLyNghiPhepForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuanLyNghiPhepForView(<any>response_);
                } catch (e) {
                    return <Observable<GetQuanLyNghiPhepForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetQuanLyNghiPhepForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuanLyNghiPhepForView(response: HttpResponseBase): Observable<GetQuanLyNghiPhepForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetQuanLyNghiPhepForViewDto.fromJS(resultData200) : new GetQuanLyNghiPhepForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetQuanLyNghiPhepForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getQuanLyNghiPhepForEdit(id: number | undefined): Observable<GetQuanLyNghiPhepForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyNghiPheps/GetQuanLyNghiPhepForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuanLyNghiPhepForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuanLyNghiPhepForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetQuanLyNghiPhepForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetQuanLyNghiPhepForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuanLyNghiPhepForEdit(response: HttpResponseBase): Observable<GetQuanLyNghiPhepForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetQuanLyNghiPhepForEditOutput.fromJS(resultData200) : new GetQuanLyNghiPhepForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetQuanLyNghiPhepForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditNghiPhepInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyNghiPheps/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyNghiPheps/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class QuanLyTrucTiepPNPsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getListQuanLyTrucTiepDto(id: number | undefined): Observable<QuanLyTrucTiepPNPDto[]> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyTrucTiepPNPs/GetListQuanLyTrucTiepDto?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListQuanLyTrucTiepDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListQuanLyTrucTiepDto(<any>response_);
                } catch (e) {
                    return <Observable<QuanLyTrucTiepPNPDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuanLyTrucTiepPNPDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListQuanLyTrucTiepDto(response: HttpResponseBase): Observable<QuanLyTrucTiepPNPDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(QuanLyTrucTiepPNPDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuanLyTrucTiepPNPDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxPhieuNghiPhepIDFilter (optional) 
     * @param minPhieuNghiPhepIDFilter (optional) 
     * @param qLTTFilter (optional) 
     * @param ghiChuFilter (optional) 
     * @param maHoSoFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxPhieuNghiPhepIDFilter: number | undefined, minPhieuNghiPhepIDFilter: number | undefined, qLTTFilter: string | undefined, ghiChuFilter: string | undefined, maHoSoFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyTrucTiepPNPs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxPhieuNghiPhepIDFilter === null)
            throw new Error("The parameter 'maxPhieuNghiPhepIDFilter' cannot be null.");
        else if (maxPhieuNghiPhepIDFilter !== undefined)
            url_ += "MaxPhieuNghiPhepIDFilter=" + encodeURIComponent("" + maxPhieuNghiPhepIDFilter) + "&"; 
        if (minPhieuNghiPhepIDFilter === null)
            throw new Error("The parameter 'minPhieuNghiPhepIDFilter' cannot be null.");
        else if (minPhieuNghiPhepIDFilter !== undefined)
            url_ += "MinPhieuNghiPhepIDFilter=" + encodeURIComponent("" + minPhieuNghiPhepIDFilter) + "&"; 
        if (qLTTFilter === null)
            throw new Error("The parameter 'qLTTFilter' cannot be null.");
        else if (qLTTFilter !== undefined)
            url_ += "QLTTFilter=" + encodeURIComponent("" + qLTTFilter) + "&"; 
        if (ghiChuFilter === null)
            throw new Error("The parameter 'ghiChuFilter' cannot be null.");
        else if (ghiChuFilter !== undefined)
            url_ += "GhiChuFilter=" + encodeURIComponent("" + ghiChuFilter) + "&"; 
        if (maHoSoFilter === null)
            throw new Error("The parameter 'maHoSoFilter' cannot be null.");
        else if (maHoSoFilter !== undefined)
            url_ += "MaHoSoFilter=" + encodeURIComponent("" + maHoSoFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    xoaQuanLyTrucTiepId(id: number | undefined): Observable<QuanLyTrucTiepPNPDto[]> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyTrucTiepPNPs/XoaQuanLyTrucTiepId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXoaQuanLyTrucTiepId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXoaQuanLyTrucTiepId(<any>response_);
                } catch (e) {
                    return <Observable<QuanLyTrucTiepPNPDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuanLyTrucTiepPNPDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processXoaQuanLyTrucTiepId(response: HttpResponseBase): Observable<QuanLyTrucTiepPNPDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(QuanLyTrucTiepPNPDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuanLyTrucTiepPNPDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getQuanLyTrucTiepPNPForEdit(id: number | undefined): Observable<GetQuanLyTrucTiepPNPForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyTrucTiepPNPs/GetQuanLyTrucTiepPNPForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuanLyTrucTiepPNPForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuanLyTrucTiepPNPForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetQuanLyTrucTiepPNPForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetQuanLyTrucTiepPNPForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuanLyTrucTiepPNPForEdit(response: HttpResponseBase): Observable<GetQuanLyTrucTiepPNPForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetQuanLyTrucTiepPNPForEditOutput.fromJS(resultData200) : new GetQuanLyTrucTiepPNPForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetQuanLyTrucTiepPNPForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditQuanLyTrucTiepPNPDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyTrucTiepPNPs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyTrucTiepPNPs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class QuyTrinhCongTacsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAll(id: number | undefined): Observable<PagedResultDtoOfGetQuyTrinhCongTacForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/QuyTrinhCongTacs/GetAll?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetQuyTrinhCongTacForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetQuyTrinhCongTacForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetQuyTrinhCongTacForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetQuyTrinhCongTacForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetQuyTrinhCongTacForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetQuyTrinhCongTacForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getListQuaTrinhCongTac(id: number | undefined): Observable<QuyTrinhCongTacDto[]> {
        let url_ = this.baseUrl + "/api/services/app/QuyTrinhCongTacs/GetListQuaTrinhCongTac?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListQuaTrinhCongTac(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListQuaTrinhCongTac(<any>response_);
                } catch (e) {
                    return <Observable<QuyTrinhCongTacDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuyTrinhCongTacDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListQuaTrinhCongTac(response: HttpResponseBase): Observable<QuyTrinhCongTacDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(QuyTrinhCongTacDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuyTrinhCongTacDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getQuyTrinhCongTacForEdit(id: number | undefined): Observable<GetQuyTrinhCongTacForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/QuyTrinhCongTacs/GetQuyTrinhCongTacForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuyTrinhCongTacForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuyTrinhCongTacForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetQuyTrinhCongTacForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetQuyTrinhCongTacForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuyTrinhCongTacForEdit(response: HttpResponseBase): Observable<GetQuyTrinhCongTacForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetQuyTrinhCongTacForEditOutput.fromJS(resultData200) : new GetQuyTrinhCongTacForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetQuyTrinhCongTacForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditQuyTrinhCongTacDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuyTrinhCongTacs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuyTrinhCongTacs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenCtyFilter (optional) 
     * @param maxDateToFilter (optional) 
     * @param minDateToFilter (optional) 
     * @param maxDateFromFilter (optional) 
     * @param minDateFromFilter (optional) 
     * @param viTriCongViecCodeFilter (optional) 
     * @param maxDonViCongTacIDFilter (optional) 
     * @param minDonViCongTacIDFilter (optional) 
     * @param quanLyTrucTiepFilter (optional) 
     * @param trangThaiCodeFilter (optional) 
     * @param ghiChuFilter (optional) 
     * @return Success
     */
    getQuyTrinhCongTacsToExcel(filter: string | undefined, tenCtyFilter: string | undefined, maxDateToFilter: moment.Moment | undefined, minDateToFilter: moment.Moment | undefined, maxDateFromFilter: moment.Moment | undefined, minDateFromFilter: moment.Moment | undefined, viTriCongViecCodeFilter: string | undefined, maxDonViCongTacIDFilter: number | undefined, minDonViCongTacIDFilter: number | undefined, quanLyTrucTiepFilter: string | undefined, trangThaiCodeFilter: string | undefined, ghiChuFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/QuyTrinhCongTacs/GetQuyTrinhCongTacsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenCtyFilter === null)
            throw new Error("The parameter 'tenCtyFilter' cannot be null.");
        else if (tenCtyFilter !== undefined)
            url_ += "TenCtyFilter=" + encodeURIComponent("" + tenCtyFilter) + "&"; 
        if (maxDateToFilter === null)
            throw new Error("The parameter 'maxDateToFilter' cannot be null.");
        else if (maxDateToFilter !== undefined)
            url_ += "MaxDateToFilter=" + encodeURIComponent(maxDateToFilter ? "" + maxDateToFilter.toJSON() : "") + "&"; 
        if (minDateToFilter === null)
            throw new Error("The parameter 'minDateToFilter' cannot be null.");
        else if (minDateToFilter !== undefined)
            url_ += "MinDateToFilter=" + encodeURIComponent(minDateToFilter ? "" + minDateToFilter.toJSON() : "") + "&"; 
        if (maxDateFromFilter === null)
            throw new Error("The parameter 'maxDateFromFilter' cannot be null.");
        else if (maxDateFromFilter !== undefined)
            url_ += "MaxDateFromFilter=" + encodeURIComponent(maxDateFromFilter ? "" + maxDateFromFilter.toJSON() : "") + "&"; 
        if (minDateFromFilter === null)
            throw new Error("The parameter 'minDateFromFilter' cannot be null.");
        else if (minDateFromFilter !== undefined)
            url_ += "MinDateFromFilter=" + encodeURIComponent(minDateFromFilter ? "" + minDateFromFilter.toJSON() : "") + "&"; 
        if (viTriCongViecCodeFilter === null)
            throw new Error("The parameter 'viTriCongViecCodeFilter' cannot be null.");
        else if (viTriCongViecCodeFilter !== undefined)
            url_ += "ViTriCongViecCodeFilter=" + encodeURIComponent("" + viTriCongViecCodeFilter) + "&"; 
        if (maxDonViCongTacIDFilter === null)
            throw new Error("The parameter 'maxDonViCongTacIDFilter' cannot be null.");
        else if (maxDonViCongTacIDFilter !== undefined)
            url_ += "MaxDonViCongTacIDFilter=" + encodeURIComponent("" + maxDonViCongTacIDFilter) + "&"; 
        if (minDonViCongTacIDFilter === null)
            throw new Error("The parameter 'minDonViCongTacIDFilter' cannot be null.");
        else if (minDonViCongTacIDFilter !== undefined)
            url_ += "MinDonViCongTacIDFilter=" + encodeURIComponent("" + minDonViCongTacIDFilter) + "&"; 
        if (quanLyTrucTiepFilter === null)
            throw new Error("The parameter 'quanLyTrucTiepFilter' cannot be null.");
        else if (quanLyTrucTiepFilter !== undefined)
            url_ += "QuanLyTrucTiepFilter=" + encodeURIComponent("" + quanLyTrucTiepFilter) + "&"; 
        if (trangThaiCodeFilter === null)
            throw new Error("The parameter 'trangThaiCodeFilter' cannot be null.");
        else if (trangThaiCodeFilter !== undefined)
            url_ += "TrangThaiCodeFilter=" + encodeURIComponent("" + trangThaiCodeFilter) + "&"; 
        if (ghiChuFilter === null)
            throw new Error("The parameter 'ghiChuFilter' cannot be null.");
        else if (ghiChuFilter !== undefined)
            url_ += "GhiChuFilter=" + encodeURIComponent("" + ghiChuFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuyTrinhCongTacsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuyTrinhCongTacsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuyTrinhCongTacsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class ReceiveUnitsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param positionFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, positionFilter: string | undefined, isActiveFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetReceiveUnitForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ReceiveUnits/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (positionFilter === null)
            throw new Error("The parameter 'positionFilter' cannot be null.");
        else if (positionFilter !== undefined)
            url_ += "PositionFilter=" + encodeURIComponent("" + positionFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetReceiveUnitForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetReceiveUnitForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetReceiveUnitForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetReceiveUnitForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetReceiveUnitForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetReceiveUnitForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getReceiveUnitForView(id: number | undefined): Observable<GetReceiveUnitForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ReceiveUnits/GetReceiveUnitForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceiveUnitForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceiveUnitForView(<any>response_);
                } catch (e) {
                    return <Observable<GetReceiveUnitForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReceiveUnitForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReceiveUnitForView(response: HttpResponseBase): Observable<GetReceiveUnitForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetReceiveUnitForViewDto.fromJS(resultData200) : new GetReceiveUnitForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReceiveUnitForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getReceiveUnitForEdit(id: number | undefined): Observable<GetReceiveUnitForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ReceiveUnits/GetReceiveUnitForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceiveUnitForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceiveUnitForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetReceiveUnitForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReceiveUnitForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetReceiveUnitForEdit(response: HttpResponseBase): Observable<GetReceiveUnitForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetReceiveUnitForEditOutput.fromJS(resultData200) : new GetReceiveUnitForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReceiveUnitForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditReceiveUnitDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReceiveUnits/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReceiveUnits/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param positionFilter (optional) 
     * @param isActiveFilter (optional) 
     * @return Success
     */
    getReceiveUnitsToExcel(filter: string | undefined, nameFilter: string | undefined, positionFilter: string | undefined, isActiveFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ReceiveUnits/GetReceiveUnitsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (positionFilter === null)
            throw new Error("The parameter 'positionFilter' cannot be null.");
        else if (positionFilter !== undefined)
            url_ += "PositionFilter=" + encodeURIComponent("" + positionFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceiveUnitsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceiveUnitsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReceiveUnitsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllRoles(): Observable<Role[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(<any>response_);
                } catch (e) {
                    return <Observable<Role[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Role[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Role.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role[]>(<any>null);
    }

    /**
     * @param permissions (optional) 
     * @return Success
     */
    getRoles(permissions: string[] | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permissions === null)
            throw new Error("The parameter 'permissions' cannot be null.");
        else if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateRole(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleMappersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxRoleIdFilter (optional) 
     * @param minRoleIdFilter (optional) 
     * @param maxLabelIdFilter (optional) 
     * @param minLabelIdFilter (optional) 
     * @param maxMenuIdFilter (optional) 
     * @param minMenuIdFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxRoleIdFilter: number | undefined, minRoleIdFilter: number | undefined, maxLabelIdFilter: number | undefined, minLabelIdFilter: number | undefined, maxMenuIdFilter: number | undefined, minMenuIdFilter: number | undefined, isActiveFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetRoleMapperForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RoleMappers/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxRoleIdFilter === null)
            throw new Error("The parameter 'maxRoleIdFilter' cannot be null.");
        else if (maxRoleIdFilter !== undefined)
            url_ += "MaxRoleIdFilter=" + encodeURIComponent("" + maxRoleIdFilter) + "&"; 
        if (minRoleIdFilter === null)
            throw new Error("The parameter 'minRoleIdFilter' cannot be null.");
        else if (minRoleIdFilter !== undefined)
            url_ += "MinRoleIdFilter=" + encodeURIComponent("" + minRoleIdFilter) + "&"; 
        if (maxLabelIdFilter === null)
            throw new Error("The parameter 'maxLabelIdFilter' cannot be null.");
        else if (maxLabelIdFilter !== undefined)
            url_ += "MaxLabelIdFilter=" + encodeURIComponent("" + maxLabelIdFilter) + "&"; 
        if (minLabelIdFilter === null)
            throw new Error("The parameter 'minLabelIdFilter' cannot be null.");
        else if (minLabelIdFilter !== undefined)
            url_ += "MinLabelIdFilter=" + encodeURIComponent("" + minLabelIdFilter) + "&"; 
        if (maxMenuIdFilter === null)
            throw new Error("The parameter 'maxMenuIdFilter' cannot be null.");
        else if (maxMenuIdFilter !== undefined)
            url_ += "MaxMenuIdFilter=" + encodeURIComponent("" + maxMenuIdFilter) + "&"; 
        if (minMenuIdFilter === null)
            throw new Error("The parameter 'minMenuIdFilter' cannot be null.");
        else if (minMenuIdFilter !== undefined)
            url_ += "MinMenuIdFilter=" + encodeURIComponent("" + minMenuIdFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRoleMapperForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRoleMapperForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRoleMapperForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRoleMapperForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRoleMapperForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRoleMapperForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleMapperForView(id: number | undefined): Observable<GetRoleMapperForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RoleMappers/GetRoleMapperForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleMapperForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleMapperForView(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleMapperForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleMapperForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleMapperForView(response: HttpResponseBase): Observable<GetRoleMapperForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleMapperForViewDto.fromJS(resultData200) : new GetRoleMapperForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleMapperForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleMapperForEdit(id: number | undefined): Observable<GetRoleMapperForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RoleMappers/GetRoleMapperForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleMapperForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleMapperForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleMapperForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleMapperForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleMapperForEdit(response: HttpResponseBase): Observable<GetRoleMapperForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleMapperForEditOutput.fromJS(resultData200) : new GetRoleMapperForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleMapperForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditRoleMapperDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RoleMappers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RoleMappers/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditListRoleMapper(body: CreateOrEditListRoleMapper | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RoleMappers/CreateOrEditListRoleMapper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditListRoleMapper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditListRoleMapper(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditListRoleMapper(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SchedulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxScheduleTypeIDFilter (optional) 
     * @param minScheduleTypeIDFilter (optional) 
     * @param maxDateCreatedFilter (optional) 
     * @param minDateCreatedFilter (optional) 
     * @param maxDateOccurFilter (optional) 
     * @param minDateOccurFilter (optional) 
     * @param fromTimeFilter (optional) 
     * @param toTimeFilter (optional) 
     * @param contentFilter (optional) 
     * @param notesFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxScheduleTypeIDFilter: number | undefined, minScheduleTypeIDFilter: number | undefined, maxDateCreatedFilter: moment.Moment | undefined, minDateCreatedFilter: moment.Moment | undefined, maxDateOccurFilter: moment.Moment | undefined, minDateOccurFilter: moment.Moment | undefined, fromTimeFilter: string | undefined, toTimeFilter: string | undefined, contentFilter: string | undefined, notesFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetScheduleForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedules/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxScheduleTypeIDFilter === null)
            throw new Error("The parameter 'maxScheduleTypeIDFilter' cannot be null.");
        else if (maxScheduleTypeIDFilter !== undefined)
            url_ += "MaxScheduleTypeIDFilter=" + encodeURIComponent("" + maxScheduleTypeIDFilter) + "&"; 
        if (minScheduleTypeIDFilter === null)
            throw new Error("The parameter 'minScheduleTypeIDFilter' cannot be null.");
        else if (minScheduleTypeIDFilter !== undefined)
            url_ += "MinScheduleTypeIDFilter=" + encodeURIComponent("" + minScheduleTypeIDFilter) + "&"; 
        if (maxDateCreatedFilter === null)
            throw new Error("The parameter 'maxDateCreatedFilter' cannot be null.");
        else if (maxDateCreatedFilter !== undefined)
            url_ += "MaxDateCreatedFilter=" + encodeURIComponent(maxDateCreatedFilter ? "" + maxDateCreatedFilter.toJSON() : "") + "&"; 
        if (minDateCreatedFilter === null)
            throw new Error("The parameter 'minDateCreatedFilter' cannot be null.");
        else if (minDateCreatedFilter !== undefined)
            url_ += "MinDateCreatedFilter=" + encodeURIComponent(minDateCreatedFilter ? "" + minDateCreatedFilter.toJSON() : "") + "&"; 
        if (maxDateOccurFilter === null)
            throw new Error("The parameter 'maxDateOccurFilter' cannot be null.");
        else if (maxDateOccurFilter !== undefined)
            url_ += "MaxDateOccurFilter=" + encodeURIComponent(maxDateOccurFilter ? "" + maxDateOccurFilter.toJSON() : "") + "&"; 
        if (minDateOccurFilter === null)
            throw new Error("The parameter 'minDateOccurFilter' cannot be null.");
        else if (minDateOccurFilter !== undefined)
            url_ += "MinDateOccurFilter=" + encodeURIComponent(minDateOccurFilter ? "" + minDateOccurFilter.toJSON() : "") + "&"; 
        if (fromTimeFilter === null)
            throw new Error("The parameter 'fromTimeFilter' cannot be null.");
        else if (fromTimeFilter !== undefined)
            url_ += "FromTimeFilter=" + encodeURIComponent("" + fromTimeFilter) + "&"; 
        if (toTimeFilter === null)
            throw new Error("The parameter 'toTimeFilter' cannot be null.");
        else if (toTimeFilter !== undefined)
            url_ += "ToTimeFilter=" + encodeURIComponent("" + toTimeFilter) + "&"; 
        if (contentFilter === null)
            throw new Error("The parameter 'contentFilter' cannot be null.");
        else if (contentFilter !== undefined)
            url_ += "ContentFilter=" + encodeURIComponent("" + contentFilter) + "&"; 
        if (notesFilter === null)
            throw new Error("The parameter 'notesFilter' cannot be null.");
        else if (notesFilter !== undefined)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetScheduleForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetScheduleForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetScheduleForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetScheduleForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetScheduleForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetScheduleForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getScheduleForView(id: number | undefined): Observable<GetScheduleForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedules/GetScheduleForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScheduleForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScheduleForView(<any>response_);
                } catch (e) {
                    return <Observable<GetScheduleForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetScheduleForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetScheduleForView(response: HttpResponseBase): Observable<GetScheduleForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetScheduleForViewDto.fromJS(resultData200) : new GetScheduleForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetScheduleForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getScheduleForEdit(id: number | undefined): Observable<GetScheduleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Schedules/GetScheduleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScheduleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScheduleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetScheduleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetScheduleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetScheduleForEdit(response: HttpResponseBase): Observable<GetScheduleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetScheduleForEditOutput.fromJS(resultData200) : new GetScheduleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetScheduleForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditScheduleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Schedules/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Schedules/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxScheduleTypeIDFilter (optional) 
     * @param minScheduleTypeIDFilter (optional) 
     * @param maxDateCreatedFilter (optional) 
     * @param minDateCreatedFilter (optional) 
     * @param maxDateOccurFilter (optional) 
     * @param minDateOccurFilter (optional) 
     * @param fromTimeFilter (optional) 
     * @param toTimeFilter (optional) 
     * @param contentFilter (optional) 
     * @param notesFilter (optional) 
     * @return Success
     */
    getSchedulesToExcel(filter: string | undefined, maxScheduleTypeIDFilter: number | undefined, minScheduleTypeIDFilter: number | undefined, maxDateCreatedFilter: moment.Moment | undefined, minDateCreatedFilter: moment.Moment | undefined, maxDateOccurFilter: moment.Moment | undefined, minDateOccurFilter: moment.Moment | undefined, fromTimeFilter: string | undefined, toTimeFilter: string | undefined, contentFilter: string | undefined, notesFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedules/GetSchedulesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxScheduleTypeIDFilter === null)
            throw new Error("The parameter 'maxScheduleTypeIDFilter' cannot be null.");
        else if (maxScheduleTypeIDFilter !== undefined)
            url_ += "MaxScheduleTypeIDFilter=" + encodeURIComponent("" + maxScheduleTypeIDFilter) + "&"; 
        if (minScheduleTypeIDFilter === null)
            throw new Error("The parameter 'minScheduleTypeIDFilter' cannot be null.");
        else if (minScheduleTypeIDFilter !== undefined)
            url_ += "MinScheduleTypeIDFilter=" + encodeURIComponent("" + minScheduleTypeIDFilter) + "&"; 
        if (maxDateCreatedFilter === null)
            throw new Error("The parameter 'maxDateCreatedFilter' cannot be null.");
        else if (maxDateCreatedFilter !== undefined)
            url_ += "MaxDateCreatedFilter=" + encodeURIComponent(maxDateCreatedFilter ? "" + maxDateCreatedFilter.toJSON() : "") + "&"; 
        if (minDateCreatedFilter === null)
            throw new Error("The parameter 'minDateCreatedFilter' cannot be null.");
        else if (minDateCreatedFilter !== undefined)
            url_ += "MinDateCreatedFilter=" + encodeURIComponent(minDateCreatedFilter ? "" + minDateCreatedFilter.toJSON() : "") + "&"; 
        if (maxDateOccurFilter === null)
            throw new Error("The parameter 'maxDateOccurFilter' cannot be null.");
        else if (maxDateOccurFilter !== undefined)
            url_ += "MaxDateOccurFilter=" + encodeURIComponent(maxDateOccurFilter ? "" + maxDateOccurFilter.toJSON() : "") + "&"; 
        if (minDateOccurFilter === null)
            throw new Error("The parameter 'minDateOccurFilter' cannot be null.");
        else if (minDateOccurFilter !== undefined)
            url_ += "MinDateOccurFilter=" + encodeURIComponent(minDateOccurFilter ? "" + minDateOccurFilter.toJSON() : "") + "&"; 
        if (fromTimeFilter === null)
            throw new Error("The parameter 'fromTimeFilter' cannot be null.");
        else if (fromTimeFilter !== undefined)
            url_ += "FromTimeFilter=" + encodeURIComponent("" + fromTimeFilter) + "&"; 
        if (toTimeFilter === null)
            throw new Error("The parameter 'toTimeFilter' cannot be null.");
        else if (toTimeFilter !== undefined)
            url_ += "ToTimeFilter=" + encodeURIComponent("" + toTimeFilter) + "&"; 
        if (contentFilter === null)
            throw new Error("The parameter 'contentFilter' cannot be null.");
        else if (contentFilter !== undefined)
            url_ += "ContentFilter=" + encodeURIComponent("" + contentFilter) + "&"; 
        if (notesFilter === null)
            throw new Error("The parameter 'notesFilter' cannot be null.");
        else if (notesFilter !== undefined)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSchedulesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSchedulesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSchedulesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class SettingConfigsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param valueStringFilter (optional) 
     * @param maxValueIntFilter (optional) 
     * @param minValueIntFilter (optional) 
     * @param valueHtmlFilter (optional) 
     * @param imageFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, codeFilter: string | undefined, valueStringFilter: string | undefined, maxValueIntFilter: number | undefined, minValueIntFilter: number | undefined, valueHtmlFilter: string | undefined, imageFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSettingConfigForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SettingConfigs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (valueStringFilter === null)
            throw new Error("The parameter 'valueStringFilter' cannot be null.");
        else if (valueStringFilter !== undefined)
            url_ += "ValueStringFilter=" + encodeURIComponent("" + valueStringFilter) + "&"; 
        if (maxValueIntFilter === null)
            throw new Error("The parameter 'maxValueIntFilter' cannot be null.");
        else if (maxValueIntFilter !== undefined)
            url_ += "MaxValueIntFilter=" + encodeURIComponent("" + maxValueIntFilter) + "&"; 
        if (minValueIntFilter === null)
            throw new Error("The parameter 'minValueIntFilter' cannot be null.");
        else if (minValueIntFilter !== undefined)
            url_ += "MinValueIntFilter=" + encodeURIComponent("" + minValueIntFilter) + "&"; 
        if (valueHtmlFilter === null)
            throw new Error("The parameter 'valueHtmlFilter' cannot be null.");
        else if (valueHtmlFilter !== undefined)
            url_ += "ValueHtmlFilter=" + encodeURIComponent("" + valueHtmlFilter) + "&"; 
        if (imageFilter === null)
            throw new Error("The parameter 'imageFilter' cannot be null.");
        else if (imageFilter !== undefined)
            url_ += "ImageFilter=" + encodeURIComponent("" + imageFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSettingConfigForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSettingConfigForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSettingConfigForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetSettingConfigForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetSettingConfigForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSettingConfigForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSettingConfigForView(id: number | undefined): Observable<GetSettingConfigForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SettingConfigs/GetSettingConfigForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingConfigForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingConfigForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSettingConfigForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSettingConfigForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettingConfigForView(response: HttpResponseBase): Observable<GetSettingConfigForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSettingConfigForViewDto.fromJS(resultData200) : new GetSettingConfigForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSettingConfigForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSettingConfigForEdit(id: number | undefined): Observable<GetSettingConfigForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SettingConfigs/GetSettingConfigForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingConfigForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingConfigForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSettingConfigForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSettingConfigForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettingConfigForEdit(response: HttpResponseBase): Observable<GetSettingConfigForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSettingConfigForEditOutput.fromJS(resultData200) : new GetSettingConfigForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSettingConfigForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSettingConfigDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SettingConfigs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SettingConfigs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param valueStringFilter (optional) 
     * @param maxValueIntFilter (optional) 
     * @param minValueIntFilter (optional) 
     * @param valueHtmlFilter (optional) 
     * @param imageFilter (optional) 
     * @return Success
     */
    getSettingConfigsToExcel(filter: string | undefined, codeFilter: string | undefined, valueStringFilter: string | undefined, maxValueIntFilter: number | undefined, minValueIntFilter: number | undefined, valueHtmlFilter: string | undefined, imageFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SettingConfigs/GetSettingConfigsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (valueStringFilter === null)
            throw new Error("The parameter 'valueStringFilter' cannot be null.");
        else if (valueStringFilter !== undefined)
            url_ += "ValueStringFilter=" + encodeURIComponent("" + valueStringFilter) + "&"; 
        if (maxValueIntFilter === null)
            throw new Error("The parameter 'maxValueIntFilter' cannot be null.");
        else if (maxValueIntFilter !== undefined)
            url_ += "MaxValueIntFilter=" + encodeURIComponent("" + maxValueIntFilter) + "&"; 
        if (minValueIntFilter === null)
            throw new Error("The parameter 'minValueIntFilter' cannot be null.");
        else if (minValueIntFilter !== undefined)
            url_ += "MinValueIntFilter=" + encodeURIComponent("" + minValueIntFilter) + "&"; 
        if (valueHtmlFilter === null)
            throw new Error("The parameter 'valueHtmlFilter' cannot be null.");
        else if (valueHtmlFilter !== undefined)
            url_ += "ValueHtmlFilter=" + encodeURIComponent("" + valueHtmlFilter) + "&"; 
        if (imageFilter === null)
            throw new Error("The parameter 'imageFilter' cannot be null.");
        else if (imageFilter !== undefined)
            url_ += "ImageFilter=" + encodeURIComponent("" + imageFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingConfigsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingConfigsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettingConfigsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class SqlConfigDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getColumnConfigBySqlId(id: number | undefined): Observable<SqlConfigDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigDetails/GetColumnConfigBySqlId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetColumnConfigBySqlId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetColumnConfigBySqlId(<any>response_);
                } catch (e) {
                    return <Observable<SqlConfigDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SqlConfigDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetColumnConfigBySqlId(response: HttpResponseBase): Observable<SqlConfigDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SqlConfigDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SqlConfigDetailDto[]>(<any>null);
    }

    /**
     * @param sqlConfigId (optional) 
     * @return Success
     */
    deleteAllConfigByConfigId(sqlConfigId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigDetails/DeleteAllConfigByConfigId?";
        if (sqlConfigId === null)
            throw new Error("The parameter 'sqlConfigId' cannot be null.");
        else if (sqlConfigId !== undefined)
            url_ += "sqlConfigId=" + encodeURIComponent("" + sqlConfigId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllConfigByConfigId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllConfigByConfigId(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAllConfigByConfigId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sqlConfigId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createConfigIfNotExistsAsync2(sqlConfigId: number | undefined, body: SqlConfigDetailDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigDetails/CreateConfigIfNotExistsAsync2?";
        if (sqlConfigId === null)
            throw new Error("The parameter 'sqlConfigId' cannot be null.");
        else if (sqlConfigId !== undefined)
            url_ += "sqlConfigId=" + encodeURIComponent("" + sqlConfigId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateConfigIfNotExistsAsync2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateConfigIfNotExistsAsync2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateConfigIfNotExistsAsync2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sqlConfigId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createConfigIfNotExists(sqlConfigId: number | undefined, body: SqlConfigDetailDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigDetails/CreateConfigIfNotExists?";
        if (sqlConfigId === null)
            throw new Error("The parameter 'sqlConfigId' cannot be null.");
        else if (sqlConfigId !== undefined)
            url_ += "sqlConfigId=" + encodeURIComponent("" + sqlConfigId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateConfigIfNotExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateConfigIfNotExists(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateConfigIfNotExists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sqlConfigId (optional) 
     * @param sqlContent (optional) 
     * @return Success
     */
    getColumn(sqlConfigId: number | undefined, sqlContent: string | undefined): Observable<DataVm> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigDetails/GetColumn?";
        if (sqlConfigId === null)
            throw new Error("The parameter 'sqlConfigId' cannot be null.");
        else if (sqlConfigId !== undefined)
            url_ += "sqlConfigId=" + encodeURIComponent("" + sqlConfigId) + "&"; 
        if (sqlContent === null)
            throw new Error("The parameter 'sqlContent' cannot be null.");
        else if (sqlContent !== undefined)
            url_ += "sqlContent=" + encodeURIComponent("" + sqlContent) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetColumn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetColumn(<any>response_);
                } catch (e) {
                    return <Observable<DataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetColumn(response: HttpResponseBase): Observable<DataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DataVm.fromJS(resultData200) : new DataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataVm>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxSqlConfigIdFilter (optional) 
     * @param minSqlConfigIdFilter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param formatFilter (optional) 
     * @param typeFilter (optional) 
     * @param widthFilter (optional) 
     * @param maxColNumFilter (optional) 
     * @param minColNumFilter (optional) 
     * @param maxGroupLevelFilter (optional) 
     * @param minGroupLevelFilter (optional) 
     * @param isDisplayFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param textAlignFilter (optional) 
     * @param maxVersionFilter (optional) 
     * @param minVersionFilter (optional) 
     * @param isSumFilter (optional) 
     * @param isFreePaneFilter (optional) 
     * @param isParentFilter (optional) 
     * @param parentCodeFilter (optional) 
     * @param groupSortFilter (optional) 
     * @param cellTemplateFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxSqlConfigIdFilter: number | undefined, minSqlConfigIdFilter: number | undefined, codeFilter: string | undefined, nameFilter: string | undefined, formatFilter: string | undefined, typeFilter: string | undefined, widthFilter: string | undefined, maxColNumFilter: number | undefined, minColNumFilter: number | undefined, maxGroupLevelFilter: number | undefined, minGroupLevelFilter: number | undefined, isDisplayFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, textAlignFilter: string | undefined, maxVersionFilter: number | undefined, minVersionFilter: number | undefined, isSumFilter: number | undefined, isFreePaneFilter: number | undefined, isParentFilter: number | undefined, parentCodeFilter: string | undefined, groupSortFilter: string | undefined, cellTemplateFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSqlConfigDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigDetails/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxSqlConfigIdFilter === null)
            throw new Error("The parameter 'maxSqlConfigIdFilter' cannot be null.");
        else if (maxSqlConfigIdFilter !== undefined)
            url_ += "MaxSqlConfigIdFilter=" + encodeURIComponent("" + maxSqlConfigIdFilter) + "&"; 
        if (minSqlConfigIdFilter === null)
            throw new Error("The parameter 'minSqlConfigIdFilter' cannot be null.");
        else if (minSqlConfigIdFilter !== undefined)
            url_ += "MinSqlConfigIdFilter=" + encodeURIComponent("" + minSqlConfigIdFilter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (formatFilter === null)
            throw new Error("The parameter 'formatFilter' cannot be null.");
        else if (formatFilter !== undefined)
            url_ += "FormatFilter=" + encodeURIComponent("" + formatFilter) + "&"; 
        if (typeFilter === null)
            throw new Error("The parameter 'typeFilter' cannot be null.");
        else if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&"; 
        if (widthFilter === null)
            throw new Error("The parameter 'widthFilter' cannot be null.");
        else if (widthFilter !== undefined)
            url_ += "WidthFilter=" + encodeURIComponent("" + widthFilter) + "&"; 
        if (maxColNumFilter === null)
            throw new Error("The parameter 'maxColNumFilter' cannot be null.");
        else if (maxColNumFilter !== undefined)
            url_ += "MaxColNumFilter=" + encodeURIComponent("" + maxColNumFilter) + "&"; 
        if (minColNumFilter === null)
            throw new Error("The parameter 'minColNumFilter' cannot be null.");
        else if (minColNumFilter !== undefined)
            url_ += "MinColNumFilter=" + encodeURIComponent("" + minColNumFilter) + "&"; 
        if (maxGroupLevelFilter === null)
            throw new Error("The parameter 'maxGroupLevelFilter' cannot be null.");
        else if (maxGroupLevelFilter !== undefined)
            url_ += "MaxGroupLevelFilter=" + encodeURIComponent("" + maxGroupLevelFilter) + "&"; 
        if (minGroupLevelFilter === null)
            throw new Error("The parameter 'minGroupLevelFilter' cannot be null.");
        else if (minGroupLevelFilter !== undefined)
            url_ += "MinGroupLevelFilter=" + encodeURIComponent("" + minGroupLevelFilter) + "&"; 
        if (isDisplayFilter === null)
            throw new Error("The parameter 'isDisplayFilter' cannot be null.");
        else if (isDisplayFilter !== undefined)
            url_ += "IsDisplayFilter=" + encodeURIComponent("" + isDisplayFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (textAlignFilter === null)
            throw new Error("The parameter 'textAlignFilter' cannot be null.");
        else if (textAlignFilter !== undefined)
            url_ += "TextAlignFilter=" + encodeURIComponent("" + textAlignFilter) + "&"; 
        if (maxVersionFilter === null)
            throw new Error("The parameter 'maxVersionFilter' cannot be null.");
        else if (maxVersionFilter !== undefined)
            url_ += "MaxVersionFilter=" + encodeURIComponent("" + maxVersionFilter) + "&"; 
        if (minVersionFilter === null)
            throw new Error("The parameter 'minVersionFilter' cannot be null.");
        else if (minVersionFilter !== undefined)
            url_ += "MinVersionFilter=" + encodeURIComponent("" + minVersionFilter) + "&"; 
        if (isSumFilter === null)
            throw new Error("The parameter 'isSumFilter' cannot be null.");
        else if (isSumFilter !== undefined)
            url_ += "IsSumFilter=" + encodeURIComponent("" + isSumFilter) + "&"; 
        if (isFreePaneFilter === null)
            throw new Error("The parameter 'isFreePaneFilter' cannot be null.");
        else if (isFreePaneFilter !== undefined)
            url_ += "IsFreePaneFilter=" + encodeURIComponent("" + isFreePaneFilter) + "&"; 
        if (isParentFilter === null)
            throw new Error("The parameter 'isParentFilter' cannot be null.");
        else if (isParentFilter !== undefined)
            url_ += "IsParentFilter=" + encodeURIComponent("" + isParentFilter) + "&"; 
        if (parentCodeFilter === null)
            throw new Error("The parameter 'parentCodeFilter' cannot be null.");
        else if (parentCodeFilter !== undefined)
            url_ += "ParentCodeFilter=" + encodeURIComponent("" + parentCodeFilter) + "&"; 
        if (groupSortFilter === null)
            throw new Error("The parameter 'groupSortFilter' cannot be null.");
        else if (groupSortFilter !== undefined)
            url_ += "GroupSortFilter=" + encodeURIComponent("" + groupSortFilter) + "&"; 
        if (cellTemplateFilter === null)
            throw new Error("The parameter 'cellTemplateFilter' cannot be null.");
        else if (cellTemplateFilter !== undefined)
            url_ += "CellTemplateFilter=" + encodeURIComponent("" + cellTemplateFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSqlConfigDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSqlConfigDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSqlConfigDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetSqlConfigDetailForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetSqlConfigDetailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSqlConfigDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSqlConfigDetailForView(id: number | undefined): Observable<GetSqlConfigDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigDetails/GetSqlConfigDetailForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSqlConfigDetailForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSqlConfigDetailForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSqlConfigDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSqlConfigDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSqlConfigDetailForView(response: HttpResponseBase): Observable<GetSqlConfigDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSqlConfigDetailForViewDto.fromJS(resultData200) : new GetSqlConfigDetailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSqlConfigDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSqlConfigDetailForEdit(id: number | undefined): Observable<GetSqlConfigDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigDetails/GetSqlConfigDetailForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSqlConfigDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSqlConfigDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSqlConfigDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSqlConfigDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSqlConfigDetailForEdit(response: HttpResponseBase): Observable<GetSqlConfigDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSqlConfigDetailForEditOutput.fromJS(resultData200) : new GetSqlConfigDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSqlConfigDetailForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSqlConfigDetailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigDetails/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxSqlConfigIdFilter (optional) 
     * @param minSqlConfigIdFilter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param formatFilter (optional) 
     * @param typeFilter (optional) 
     * @param widthFilter (optional) 
     * @param maxColNumFilter (optional) 
     * @param minColNumFilter (optional) 
     * @param maxGroupLevelFilter (optional) 
     * @param minGroupLevelFilter (optional) 
     * @param isDisplayFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param textAlignFilter (optional) 
     * @param maxVersionFilter (optional) 
     * @param minVersionFilter (optional) 
     * @param isSumFilter (optional) 
     * @param isFreePaneFilter (optional) 
     * @param isParentFilter (optional) 
     * @param parentCodeFilter (optional) 
     * @param groupSortFilter (optional) 
     * @return Success
     */
    getSqlConfigDetailsToExcel(filter: string | undefined, maxSqlConfigIdFilter: number | undefined, minSqlConfigIdFilter: number | undefined, codeFilter: string | undefined, nameFilter: string | undefined, formatFilter: string | undefined, typeFilter: string | undefined, widthFilter: string | undefined, maxColNumFilter: number | undefined, minColNumFilter: number | undefined, maxGroupLevelFilter: number | undefined, minGroupLevelFilter: number | undefined, isDisplayFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, textAlignFilter: string | undefined, maxVersionFilter: number | undefined, minVersionFilter: number | undefined, isSumFilter: number | undefined, isFreePaneFilter: number | undefined, isParentFilter: number | undefined, parentCodeFilter: string | undefined, groupSortFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigDetails/GetSqlConfigDetailsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxSqlConfigIdFilter === null)
            throw new Error("The parameter 'maxSqlConfigIdFilter' cannot be null.");
        else if (maxSqlConfigIdFilter !== undefined)
            url_ += "MaxSqlConfigIdFilter=" + encodeURIComponent("" + maxSqlConfigIdFilter) + "&"; 
        if (minSqlConfigIdFilter === null)
            throw new Error("The parameter 'minSqlConfigIdFilter' cannot be null.");
        else if (minSqlConfigIdFilter !== undefined)
            url_ += "MinSqlConfigIdFilter=" + encodeURIComponent("" + minSqlConfigIdFilter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (formatFilter === null)
            throw new Error("The parameter 'formatFilter' cannot be null.");
        else if (formatFilter !== undefined)
            url_ += "FormatFilter=" + encodeURIComponent("" + formatFilter) + "&"; 
        if (typeFilter === null)
            throw new Error("The parameter 'typeFilter' cannot be null.");
        else if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&"; 
        if (widthFilter === null)
            throw new Error("The parameter 'widthFilter' cannot be null.");
        else if (widthFilter !== undefined)
            url_ += "WidthFilter=" + encodeURIComponent("" + widthFilter) + "&"; 
        if (maxColNumFilter === null)
            throw new Error("The parameter 'maxColNumFilter' cannot be null.");
        else if (maxColNumFilter !== undefined)
            url_ += "MaxColNumFilter=" + encodeURIComponent("" + maxColNumFilter) + "&"; 
        if (minColNumFilter === null)
            throw new Error("The parameter 'minColNumFilter' cannot be null.");
        else if (minColNumFilter !== undefined)
            url_ += "MinColNumFilter=" + encodeURIComponent("" + minColNumFilter) + "&"; 
        if (maxGroupLevelFilter === null)
            throw new Error("The parameter 'maxGroupLevelFilter' cannot be null.");
        else if (maxGroupLevelFilter !== undefined)
            url_ += "MaxGroupLevelFilter=" + encodeURIComponent("" + maxGroupLevelFilter) + "&"; 
        if (minGroupLevelFilter === null)
            throw new Error("The parameter 'minGroupLevelFilter' cannot be null.");
        else if (minGroupLevelFilter !== undefined)
            url_ += "MinGroupLevelFilter=" + encodeURIComponent("" + minGroupLevelFilter) + "&"; 
        if (isDisplayFilter === null)
            throw new Error("The parameter 'isDisplayFilter' cannot be null.");
        else if (isDisplayFilter !== undefined)
            url_ += "IsDisplayFilter=" + encodeURIComponent("" + isDisplayFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (textAlignFilter === null)
            throw new Error("The parameter 'textAlignFilter' cannot be null.");
        else if (textAlignFilter !== undefined)
            url_ += "TextAlignFilter=" + encodeURIComponent("" + textAlignFilter) + "&"; 
        if (maxVersionFilter === null)
            throw new Error("The parameter 'maxVersionFilter' cannot be null.");
        else if (maxVersionFilter !== undefined)
            url_ += "MaxVersionFilter=" + encodeURIComponent("" + maxVersionFilter) + "&"; 
        if (minVersionFilter === null)
            throw new Error("The parameter 'minVersionFilter' cannot be null.");
        else if (minVersionFilter !== undefined)
            url_ += "MinVersionFilter=" + encodeURIComponent("" + minVersionFilter) + "&"; 
        if (isSumFilter === null)
            throw new Error("The parameter 'isSumFilter' cannot be null.");
        else if (isSumFilter !== undefined)
            url_ += "IsSumFilter=" + encodeURIComponent("" + isSumFilter) + "&"; 
        if (isFreePaneFilter === null)
            throw new Error("The parameter 'isFreePaneFilter' cannot be null.");
        else if (isFreePaneFilter !== undefined)
            url_ += "IsFreePaneFilter=" + encodeURIComponent("" + isFreePaneFilter) + "&"; 
        if (isParentFilter === null)
            throw new Error("The parameter 'isParentFilter' cannot be null.");
        else if (isParentFilter !== undefined)
            url_ += "IsParentFilter=" + encodeURIComponent("" + isParentFilter) + "&"; 
        if (parentCodeFilter === null)
            throw new Error("The parameter 'parentCodeFilter' cannot be null.");
        else if (parentCodeFilter !== undefined)
            url_ += "ParentCodeFilter=" + encodeURIComponent("" + parentCodeFilter) + "&"; 
        if (groupSortFilter === null)
            throw new Error("The parameter 'groupSortFilter' cannot be null.");
        else if (groupSortFilter !== undefined)
            url_ += "GroupSortFilter=" + encodeURIComponent("" + groupSortFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSqlConfigDetailsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSqlConfigDetailsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSqlConfigDetailsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class SqlConfigsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getSqlConfigByCode(code: string | undefined): Observable<SqlConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigs/GetSqlConfigByCode?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSqlConfigByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSqlConfigByCode(<any>response_);
                } catch (e) {
                    return <Observable<SqlConfigDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SqlConfigDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSqlConfigByCode(response: HttpResponseBase): Observable<SqlConfigDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SqlConfigDto.fromJS(resultData200) : new SqlConfigDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SqlConfigDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param isRawQueryFilter (optional) 
     * @param sqlContentFilter (optional) 
     * @param maxGroupLevelFilter (optional) 
     * @param minGroupLevelFilter (optional) 
     * @param maxDisplayTypeFilter (optional) 
     * @param minDisplayTypeFilter (optional) 
     * @param maxVersionFilter (optional) 
     * @param minVersionFilter (optional) 
     * @param isDynamicColumnFilter (optional) 
     * @param maxTypeGetColumnFilter (optional) 
     * @param minTypeGetColumnFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, codeFilter: string | undefined, nameFilter: string | undefined, isRawQueryFilter: number | undefined, sqlContentFilter: string | undefined, maxGroupLevelFilter: number | undefined, minGroupLevelFilter: number | undefined, maxDisplayTypeFilter: number | undefined, minDisplayTypeFilter: number | undefined, maxVersionFilter: number | undefined, minVersionFilter: number | undefined, isDynamicColumnFilter: number | undefined, maxTypeGetColumnFilter: number | undefined, minTypeGetColumnFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSqlConfigForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (isRawQueryFilter === null)
            throw new Error("The parameter 'isRawQueryFilter' cannot be null.");
        else if (isRawQueryFilter !== undefined)
            url_ += "IsRawQueryFilter=" + encodeURIComponent("" + isRawQueryFilter) + "&"; 
        if (sqlContentFilter === null)
            throw new Error("The parameter 'sqlContentFilter' cannot be null.");
        else if (sqlContentFilter !== undefined)
            url_ += "SqlContentFilter=" + encodeURIComponent("" + sqlContentFilter) + "&"; 
        if (maxGroupLevelFilter === null)
            throw new Error("The parameter 'maxGroupLevelFilter' cannot be null.");
        else if (maxGroupLevelFilter !== undefined)
            url_ += "MaxGroupLevelFilter=" + encodeURIComponent("" + maxGroupLevelFilter) + "&"; 
        if (minGroupLevelFilter === null)
            throw new Error("The parameter 'minGroupLevelFilter' cannot be null.");
        else if (minGroupLevelFilter !== undefined)
            url_ += "MinGroupLevelFilter=" + encodeURIComponent("" + minGroupLevelFilter) + "&"; 
        if (maxDisplayTypeFilter === null)
            throw new Error("The parameter 'maxDisplayTypeFilter' cannot be null.");
        else if (maxDisplayTypeFilter !== undefined)
            url_ += "MaxDisplayTypeFilter=" + encodeURIComponent("" + maxDisplayTypeFilter) + "&"; 
        if (minDisplayTypeFilter === null)
            throw new Error("The parameter 'minDisplayTypeFilter' cannot be null.");
        else if (minDisplayTypeFilter !== undefined)
            url_ += "MinDisplayTypeFilter=" + encodeURIComponent("" + minDisplayTypeFilter) + "&"; 
        if (maxVersionFilter === null)
            throw new Error("The parameter 'maxVersionFilter' cannot be null.");
        else if (maxVersionFilter !== undefined)
            url_ += "MaxVersionFilter=" + encodeURIComponent("" + maxVersionFilter) + "&"; 
        if (minVersionFilter === null)
            throw new Error("The parameter 'minVersionFilter' cannot be null.");
        else if (minVersionFilter !== undefined)
            url_ += "MinVersionFilter=" + encodeURIComponent("" + minVersionFilter) + "&"; 
        if (isDynamicColumnFilter === null)
            throw new Error("The parameter 'isDynamicColumnFilter' cannot be null.");
        else if (isDynamicColumnFilter !== undefined)
            url_ += "IsDynamicColumnFilter=" + encodeURIComponent("" + isDynamicColumnFilter) + "&"; 
        if (maxTypeGetColumnFilter === null)
            throw new Error("The parameter 'maxTypeGetColumnFilter' cannot be null.");
        else if (maxTypeGetColumnFilter !== undefined)
            url_ += "MaxTypeGetColumnFilter=" + encodeURIComponent("" + maxTypeGetColumnFilter) + "&"; 
        if (minTypeGetColumnFilter === null)
            throw new Error("The parameter 'minTypeGetColumnFilter' cannot be null.");
        else if (minTypeGetColumnFilter !== undefined)
            url_ += "MinTypeGetColumnFilter=" + encodeURIComponent("" + minTypeGetColumnFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSqlConfigForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSqlConfigForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSqlConfigForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetSqlConfigForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetSqlConfigForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSqlConfigForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSqlConfigForView(id: number | undefined): Observable<GetSqlConfigForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigs/GetSqlConfigForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSqlConfigForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSqlConfigForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSqlConfigForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSqlConfigForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSqlConfigForView(response: HttpResponseBase): Observable<GetSqlConfigForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSqlConfigForViewDto.fromJS(resultData200) : new GetSqlConfigForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSqlConfigForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSqlConfigForEdit(id: number | undefined): Observable<GetSqlConfigForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigs/GetSqlConfigForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSqlConfigForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSqlConfigForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSqlConfigForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSqlConfigForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSqlConfigForEdit(response: HttpResponseBase): Observable<GetSqlConfigForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSqlConfigForEditOutput.fromJS(resultData200) : new GetSqlConfigForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSqlConfigForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSqlConfigDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SqlConfigs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SqlStoreParamsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllStore(): Observable<SqlConfigDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SqlStoreParams/GetAllStore";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStore(<any>response_);
                } catch (e) {
                    return <Observable<SqlConfigDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SqlConfigDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStore(response: HttpResponseBase): Observable<SqlConfigDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SqlConfigDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SqlConfigDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxSqlConfigIdFilter (optional) 
     * @param minSqlConfigIdFilter (optional) 
     * @param codeFilter (optional) 
     * @param formatFilter (optional) 
     * @param nameFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param valueStringFilter (optional) 
     * @param maxValueIntFilter (optional) 
     * @param minValueIntFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxSqlConfigIdFilter: number | undefined, minSqlConfigIdFilter: number | undefined, codeFilter: string | undefined, formatFilter: string | undefined, nameFilter: string | undefined, isActiveFilter: number | undefined, valueStringFilter: string | undefined, maxValueIntFilter: number | undefined, minValueIntFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSqlStoreParamForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SqlStoreParams/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxSqlConfigIdFilter === null)
            throw new Error("The parameter 'maxSqlConfigIdFilter' cannot be null.");
        else if (maxSqlConfigIdFilter !== undefined)
            url_ += "MaxSqlConfigIdFilter=" + encodeURIComponent("" + maxSqlConfigIdFilter) + "&"; 
        if (minSqlConfigIdFilter === null)
            throw new Error("The parameter 'minSqlConfigIdFilter' cannot be null.");
        else if (minSqlConfigIdFilter !== undefined)
            url_ += "MinSqlConfigIdFilter=" + encodeURIComponent("" + minSqlConfigIdFilter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (formatFilter === null)
            throw new Error("The parameter 'formatFilter' cannot be null.");
        else if (formatFilter !== undefined)
            url_ += "FormatFilter=" + encodeURIComponent("" + formatFilter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (valueStringFilter === null)
            throw new Error("The parameter 'valueStringFilter' cannot be null.");
        else if (valueStringFilter !== undefined)
            url_ += "ValueStringFilter=" + encodeURIComponent("" + valueStringFilter) + "&"; 
        if (maxValueIntFilter === null)
            throw new Error("The parameter 'maxValueIntFilter' cannot be null.");
        else if (maxValueIntFilter !== undefined)
            url_ += "MaxValueIntFilter=" + encodeURIComponent("" + maxValueIntFilter) + "&"; 
        if (minValueIntFilter === null)
            throw new Error("The parameter 'minValueIntFilter' cannot be null.");
        else if (minValueIntFilter !== undefined)
            url_ += "MinValueIntFilter=" + encodeURIComponent("" + minValueIntFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSqlStoreParamForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSqlStoreParamForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSqlStoreParamForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetSqlStoreParamForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetSqlStoreParamForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSqlStoreParamForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSqlStoreParamForView(id: number | undefined): Observable<GetSqlStoreParamForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SqlStoreParams/GetSqlStoreParamForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSqlStoreParamForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSqlStoreParamForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSqlStoreParamForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSqlStoreParamForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSqlStoreParamForView(response: HttpResponseBase): Observable<GetSqlStoreParamForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSqlStoreParamForViewDto.fromJS(resultData200) : new GetSqlStoreParamForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSqlStoreParamForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSqlStoreParamForEdit(id: number | undefined): Observable<GetSqlStoreParamForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SqlStoreParams/GetSqlStoreParamForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSqlStoreParamForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSqlStoreParamForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSqlStoreParamForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSqlStoreParamForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSqlStoreParamForEdit(response: HttpResponseBase): Observable<GetSqlStoreParamForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSqlStoreParamForEditOutput.fromJS(resultData200) : new GetSqlStoreParamForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSqlStoreParamForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSqlStoreParamDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SqlStoreParams/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SqlStoreParams/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxSqlConfigIdFilter (optional) 
     * @param minSqlConfigIdFilter (optional) 
     * @param codeFilter (optional) 
     * @param formatFilter (optional) 
     * @param nameFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param valueStringFilter (optional) 
     * @param maxValueIntFilter (optional) 
     * @param minValueIntFilter (optional) 
     * @return Success
     */
    getSqlStoreParamsToExcel(filter: string | undefined, maxSqlConfigIdFilter: number | undefined, minSqlConfigIdFilter: number | undefined, codeFilter: string | undefined, formatFilter: string | undefined, nameFilter: string | undefined, isActiveFilter: number | undefined, valueStringFilter: string | undefined, maxValueIntFilter: number | undefined, minValueIntFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SqlStoreParams/GetSqlStoreParamsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxSqlConfigIdFilter === null)
            throw new Error("The parameter 'maxSqlConfigIdFilter' cannot be null.");
        else if (maxSqlConfigIdFilter !== undefined)
            url_ += "MaxSqlConfigIdFilter=" + encodeURIComponent("" + maxSqlConfigIdFilter) + "&"; 
        if (minSqlConfigIdFilter === null)
            throw new Error("The parameter 'minSqlConfigIdFilter' cannot be null.");
        else if (minSqlConfigIdFilter !== undefined)
            url_ += "MinSqlConfigIdFilter=" + encodeURIComponent("" + minSqlConfigIdFilter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (formatFilter === null)
            throw new Error("The parameter 'formatFilter' cannot be null.");
        else if (formatFilter !== undefined)
            url_ += "FormatFilter=" + encodeURIComponent("" + formatFilter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (valueStringFilter === null)
            throw new Error("The parameter 'valueStringFilter' cannot be null.");
        else if (valueStringFilter !== undefined)
            url_ += "ValueStringFilter=" + encodeURIComponent("" + valueStringFilter) + "&"; 
        if (maxValueIntFilter === null)
            throw new Error("The parameter 'maxValueIntFilter' cannot be null.");
        else if (maxValueIntFilter !== undefined)
            url_ += "MaxValueIntFilter=" + encodeURIComponent("" + maxValueIntFilter) + "&"; 
        if (minValueIntFilter === null)
            throw new Error("The parameter 'minValueIntFilter' cannot be null.");
        else if (minValueIntFilter !== undefined)
            url_ += "MinValueIntFilter=" + encodeURIComponent("" + minValueIntFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSqlStoreParamsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSqlStoreParamsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSqlStoreParamsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class StoreDatasourcesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameStoreFilter (optional) 
     * @param keyFilter (optional) 
     * @param valueFilter (optional) 
     * @param maxDynamicDatasourceIdFilter (optional) 
     * @param minDynamicDatasourceIdFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameStoreFilter: string | undefined, keyFilter: string | undefined, valueFilter: string | undefined, maxDynamicDatasourceIdFilter: number | undefined, minDynamicDatasourceIdFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, isActiveFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreDatasourceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreDatasources/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameStoreFilter === null)
            throw new Error("The parameter 'nameStoreFilter' cannot be null.");
        else if (nameStoreFilter !== undefined)
            url_ += "NameStoreFilter=" + encodeURIComponent("" + nameStoreFilter) + "&"; 
        if (keyFilter === null)
            throw new Error("The parameter 'keyFilter' cannot be null.");
        else if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (valueFilter === null)
            throw new Error("The parameter 'valueFilter' cannot be null.");
        else if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (maxDynamicDatasourceIdFilter === null)
            throw new Error("The parameter 'maxDynamicDatasourceIdFilter' cannot be null.");
        else if (maxDynamicDatasourceIdFilter !== undefined)
            url_ += "MaxDynamicDatasourceIdFilter=" + encodeURIComponent("" + maxDynamicDatasourceIdFilter) + "&"; 
        if (minDynamicDatasourceIdFilter === null)
            throw new Error("The parameter 'minDynamicDatasourceIdFilter' cannot be null.");
        else if (minDynamicDatasourceIdFilter !== undefined)
            url_ += "MinDynamicDatasourceIdFilter=" + encodeURIComponent("" + minDynamicDatasourceIdFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetStoreDatasourceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetStoreDatasourceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreDatasourceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetStoreDatasourceForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetStoreDatasourceForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetStoreDatasourceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreDatasourceForView(id: number | undefined): Observable<GetStoreDatasourceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreDatasources/GetStoreDatasourceForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreDatasourceForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreDatasourceForView(<any>response_);
                } catch (e) {
                    return <Observable<GetStoreDatasourceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetStoreDatasourceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoreDatasourceForView(response: HttpResponseBase): Observable<GetStoreDatasourceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetStoreDatasourceForViewDto.fromJS(resultData200) : new GetStoreDatasourceForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetStoreDatasourceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreDatasourceForEdit(id: number | undefined): Observable<GetStoreDatasourceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreDatasources/GetStoreDatasourceForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreDatasourceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreDatasourceForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetStoreDatasourceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetStoreDatasourceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoreDatasourceForEdit(response: HttpResponseBase): Observable<GetStoreDatasourceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetStoreDatasourceForEditOutput.fromJS(resultData200) : new GetStoreDatasourceForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetStoreDatasourceForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreDatasourceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreDatasources/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreDatasources/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameStoreFilter (optional) 
     * @param keyFilter (optional) 
     * @param valueFilter (optional) 
     * @param maxDynamicDatasourceIdFilter (optional) 
     * @param minDynamicDatasourceIdFilter (optional) 
     * @param maxOrderFilter (optional) 
     * @param minOrderFilter (optional) 
     * @param isActiveFilter (optional) 
     * @return Success
     */
    getStoreDatasourcesToExcel(filter: string | undefined, nameStoreFilter: string | undefined, keyFilter: string | undefined, valueFilter: string | undefined, maxDynamicDatasourceIdFilter: number | undefined, minDynamicDatasourceIdFilter: number | undefined, maxOrderFilter: number | undefined, minOrderFilter: number | undefined, isActiveFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreDatasources/GetStoreDatasourcesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameStoreFilter === null)
            throw new Error("The parameter 'nameStoreFilter' cannot be null.");
        else if (nameStoreFilter !== undefined)
            url_ += "NameStoreFilter=" + encodeURIComponent("" + nameStoreFilter) + "&"; 
        if (keyFilter === null)
            throw new Error("The parameter 'keyFilter' cannot be null.");
        else if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (valueFilter === null)
            throw new Error("The parameter 'valueFilter' cannot be null.");
        else if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (maxDynamicDatasourceIdFilter === null)
            throw new Error("The parameter 'maxDynamicDatasourceIdFilter' cannot be null.");
        else if (maxDynamicDatasourceIdFilter !== undefined)
            url_ += "MaxDynamicDatasourceIdFilter=" + encodeURIComponent("" + maxDynamicDatasourceIdFilter) + "&"; 
        if (minDynamicDatasourceIdFilter === null)
            throw new Error("The parameter 'minDynamicDatasourceIdFilter' cannot be null.");
        else if (minDynamicDatasourceIdFilter !== undefined)
            url_ += "MinDynamicDatasourceIdFilter=" + encodeURIComponent("" + minDynamicDatasourceIdFilter) + "&"; 
        if (maxOrderFilter === null)
            throw new Error("The parameter 'maxOrderFilter' cannot be null.");
        else if (maxOrderFilter !== undefined)
            url_ += "MaxOrderFilter=" + encodeURIComponent("" + maxOrderFilter) + "&"; 
        if (minOrderFilter === null)
            throw new Error("The parameter 'minOrderFilter' cannot be null.");
        else if (minOrderFilter !== undefined)
            url_ += "MinOrderFilter=" + encodeURIComponent("" + minOrderFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreDatasourcesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreDatasourcesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoreDatasourcesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmPayment(body: StripeConfirmPaymentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/ConfirmPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSubscription(body: StripeCreateSubscriptionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubscription(body: StripeUpdateSubscriptionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<StripeConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripeConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StripeConfigurationDto.fromJS(resultData200) : new StripeConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeConfigurationDto>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SYS_CODEMASTERSsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param prefixFilter (optional) 
     * @param maxCurValueFilter (optional) 
     * @param minCurValueFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param activeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, prefixFilter: string | undefined, maxCurValueFilter: number | undefined, minCurValueFilter: number | undefined, descriptionFilter: string | undefined, activeFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSYS_CODEMASTERSForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SYS_CODEMASTERSs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (prefixFilter === null)
            throw new Error("The parameter 'prefixFilter' cannot be null.");
        else if (prefixFilter !== undefined)
            url_ += "PrefixFilter=" + encodeURIComponent("" + prefixFilter) + "&"; 
        if (maxCurValueFilter === null)
            throw new Error("The parameter 'maxCurValueFilter' cannot be null.");
        else if (maxCurValueFilter !== undefined)
            url_ += "MaxCurValueFilter=" + encodeURIComponent("" + maxCurValueFilter) + "&"; 
        if (minCurValueFilter === null)
            throw new Error("The parameter 'minCurValueFilter' cannot be null.");
        else if (minCurValueFilter !== undefined)
            url_ += "MinCurValueFilter=" + encodeURIComponent("" + minCurValueFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (activeFilter === null)
            throw new Error("The parameter 'activeFilter' cannot be null.");
        else if (activeFilter !== undefined)
            url_ += "ActiveFilter=" + encodeURIComponent("" + activeFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSYS_CODEMASTERSForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSYS_CODEMASTERSForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSYS_CODEMASTERSForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetSYS_CODEMASTERSForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetSYS_CODEMASTERSForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSYS_CODEMASTERSForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSYS_CODEMASTERSForView(id: number | undefined): Observable<GetSYS_CODEMASTERSForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SYS_CODEMASTERSs/GetSYS_CODEMASTERSForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSYS_CODEMASTERSForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSYS_CODEMASTERSForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSYS_CODEMASTERSForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSYS_CODEMASTERSForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSYS_CODEMASTERSForView(response: HttpResponseBase): Observable<GetSYS_CODEMASTERSForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSYS_CODEMASTERSForViewDto.fromJS(resultData200) : new GetSYS_CODEMASTERSForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSYS_CODEMASTERSForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSYS_CODEMASTERSForEdit(id: number | undefined): Observable<GetSYS_CODEMASTERSForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SYS_CODEMASTERSs/GetSYS_CODEMASTERSForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSYS_CODEMASTERSForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSYS_CODEMASTERSForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSYS_CODEMASTERSForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSYS_CODEMASTERSForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSYS_CODEMASTERSForEdit(response: HttpResponseBase): Observable<GetSYS_CODEMASTERSForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSYS_CODEMASTERSForEditOutput.fromJS(resultData200) : new GetSYS_CODEMASTERSForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSYS_CODEMASTERSForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSYS_CODEMASTERSDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SYS_CODEMASTERSs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SYS_CODEMASTERSs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param prefixFilter (optional) 
     * @param maxCurValueFilter (optional) 
     * @param minCurValueFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param activeFilter (optional) 
     * @return Success
     */
    getSYS_CODEMASTERSsToExcel(filter: string | undefined, prefixFilter: string | undefined, maxCurValueFilter: number | undefined, minCurValueFilter: number | undefined, descriptionFilter: string | undefined, activeFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SYS_CODEMASTERSs/GetSYS_CODEMASTERSsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (prefixFilter === null)
            throw new Error("The parameter 'prefixFilter' cannot be null.");
        else if (prefixFilter !== undefined)
            url_ += "PrefixFilter=" + encodeURIComponent("" + prefixFilter) + "&"; 
        if (maxCurValueFilter === null)
            throw new Error("The parameter 'maxCurValueFilter' cannot be null.");
        else if (maxCurValueFilter !== undefined)
            url_ += "MaxCurValueFilter=" + encodeURIComponent("" + maxCurValueFilter) + "&"; 
        if (minCurValueFilter === null)
            throw new Error("The parameter 'minCurValueFilter' cannot be null.");
        else if (minCurValueFilter !== undefined)
            url_ += "MinCurValueFilter=" + encodeURIComponent("" + minCurValueFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (activeFilter === null)
            throw new Error("The parameter 'activeFilter' cannot be null.");
        else if (activeFilter !== undefined)
            url_ += "ActiveFilter=" + encodeURIComponent("" + activeFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSYS_CODEMASTERSsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSYS_CODEMASTERSsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSYS_CODEMASTERSsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class SYS_PREFIXsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param prefixFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, codeFilter: string | undefined, prefixFilter: string | undefined, descriptionFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSYS_PREFIXForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SYS_PREFIXs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (prefixFilter === null)
            throw new Error("The parameter 'prefixFilter' cannot be null.");
        else if (prefixFilter !== undefined)
            url_ += "PrefixFilter=" + encodeURIComponent("" + prefixFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSYS_PREFIXForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSYS_PREFIXForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSYS_PREFIXForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetSYS_PREFIXForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetSYS_PREFIXForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSYS_PREFIXForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSYS_PREFIXForView(id: number | undefined): Observable<GetSYS_PREFIXForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SYS_PREFIXs/GetSYS_PREFIXForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSYS_PREFIXForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSYS_PREFIXForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSYS_PREFIXForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSYS_PREFIXForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSYS_PREFIXForView(response: HttpResponseBase): Observable<GetSYS_PREFIXForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSYS_PREFIXForViewDto.fromJS(resultData200) : new GetSYS_PREFIXForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSYS_PREFIXForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSYS_PREFIXForEdit(id: number | undefined): Observable<GetSYS_PREFIXForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SYS_PREFIXs/GetSYS_PREFIXForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSYS_PREFIXForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSYS_PREFIXForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSYS_PREFIXForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSYS_PREFIXForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSYS_PREFIXForEdit(response: HttpResponseBase): Observable<GetSYS_PREFIXForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSYS_PREFIXForEditOutput.fromJS(resultData200) : new GetSYS_PREFIXForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSYS_PREFIXForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSYS_PREFIXDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SYS_PREFIXs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SYS_PREFIXs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param prefixFilter (optional) 
     * @param descriptionFilter (optional) 
     * @return Success
     */
    getSYS_PREFIXsToExcel(filter: string | undefined, codeFilter: string | undefined, prefixFilter: string | undefined, descriptionFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SYS_PREFIXs/GetSYS_PREFIXsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (prefixFilter === null)
            throw new Error("The parameter 'prefixFilter' cannot be null.");
        else if (prefixFilter !== undefined)
            url_ += "PrefixFilter=" + encodeURIComponent("" + prefixFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSYS_PREFIXsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSYS_PREFIXsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSYS_PREFIXsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class TemplatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maTemplateFilter (optional) 
     * @param tenTemplateFilter (optional) 
     * @param linkTemplateFilter (optional) 
     * @param ghiChuFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maTemplateFilter: string | undefined, tenTemplateFilter: string | undefined, linkTemplateFilter: string | undefined, ghiChuFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTemplateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Templates/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maTemplateFilter === null)
            throw new Error("The parameter 'maTemplateFilter' cannot be null.");
        else if (maTemplateFilter !== undefined)
            url_ += "MaTemplateFilter=" + encodeURIComponent("" + maTemplateFilter) + "&"; 
        if (tenTemplateFilter === null)
            throw new Error("The parameter 'tenTemplateFilter' cannot be null.");
        else if (tenTemplateFilter !== undefined)
            url_ += "TenTemplateFilter=" + encodeURIComponent("" + tenTemplateFilter) + "&"; 
        if (linkTemplateFilter === null)
            throw new Error("The parameter 'linkTemplateFilter' cannot be null.");
        else if (linkTemplateFilter !== undefined)
            url_ += "LinkTemplateFilter=" + encodeURIComponent("" + linkTemplateFilter) + "&"; 
        if (ghiChuFilter === null)
            throw new Error("The parameter 'ghiChuFilter' cannot be null.");
        else if (ghiChuFilter !== undefined)
            url_ += "GhiChuFilter=" + encodeURIComponent("" + ghiChuFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTemplateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTemplateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTemplateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTemplateForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetTemplateForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTemplateForViewDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTemplate(): Observable<TemplateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Templates/GetAllTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTemplate(<any>response_);
                } catch (e) {
                    return <Observable<TemplateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TemplateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTemplate(response: HttpResponseBase): Observable<TemplateDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TemplateDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTemplateForView(id: number | undefined): Observable<GetTemplateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Templates/GetTemplateForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateForView(<any>response_);
                } catch (e) {
                    return <Observable<GetTemplateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTemplateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTemplateForView(response: HttpResponseBase): Observable<GetTemplateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTemplateForViewDto.fromJS(resultData200) : new GetTemplateForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTemplateForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTemplateForEdit(id: number | undefined): Observable<GetTemplateForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Templates/GetTemplateForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTemplateForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTemplateForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTemplateForEdit(response: HttpResponseBase): Observable<GetTemplateForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTemplateForEditOutput.fromJS(resultData200) : new GetTemplateForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTemplateForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTemplateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Templates/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenCty (optional) 
     * @return Success
     */
    getListTemplate(tenCty: string | undefined): Observable<TemplateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Templates/GetListTemplate?";
        if (tenCty === null)
            throw new Error("The parameter 'tenCty' cannot be null.");
        else if (tenCty !== undefined)
            url_ += "TenCty=" + encodeURIComponent("" + tenCty) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListTemplate(<any>response_);
                } catch (e) {
                    return <Observable<TemplateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TemplateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListTemplate(response: HttpResponseBase): Observable<TemplateDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TemplateDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateDto[]>(<any>null);
    }

    /**
     * @param tenCty (optional) 
     * @return Success
     */
    capNhatLink(tenCty: string | undefined): Observable<TemplateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Templates/CapNhatLink?";
        if (tenCty === null)
            throw new Error("The parameter 'tenCty' cannot be null.");
        else if (tenCty !== undefined)
            url_ += "TenCty=" + encodeURIComponent("" + tenCty) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCapNhatLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCapNhatLink(<any>response_);
                } catch (e) {
                    return <Observable<TemplateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TemplateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCapNhatLink(response: HttpResponseBase): Observable<TemplateDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TemplateDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateDto[]>(<any>null);
    }

    /**
     * @param link (optional) 
     * @param maTemplate (optional) 
     * @return Success
     */
    thayDoiLink(link: string | undefined, maTemplate: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Templates/ThayDoiLink?";
        if (link === null)
            throw new Error("The parameter 'link' cannot be null.");
        else if (link !== undefined)
            url_ += "link=" + encodeURIComponent("" + link) + "&"; 
        if (maTemplate === null)
            throw new Error("The parameter 'maTemplate' cannot be null.");
        else if (maTemplate !== undefined)
            url_ += "MaTemplate=" + encodeURIComponent("" + maTemplate) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThayDoiLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThayDoiLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processThayDoiLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Templates/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | undefined, subscriptionEndDateStart: moment.Moment | undefined, subscriptionEndDateEnd: moment.Moment | undefined, creationDateStart: moment.Moment | undefined, creationDateEnd: moment.Moment | undefined, editionId: number | undefined, editionIdSpecified: boolean | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subscriptionEndDateStart === null)
            throw new Error("The parameter 'subscriptionEndDateStart' cannot be null.");
        else if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&"; 
        if (subscriptionEndDateEnd === null)
            throw new Error("The parameter 'subscriptionEndDateEnd' cannot be null.");
        else if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&"; 
        if (creationDateStart === null)
            throw new Error("The parameter 'creationDateStart' cannot be null.");
        else if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd === null)
            throw new Error("The parameter 'creationDateEnd' cannot be null.");
        else if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified === null)
            throw new Error("The parameter 'editionIdSpecified' cannot be null.");
        else if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTenant(): Observable<TenantListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAllTenant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTenant(<any>response_);
                } catch (e) {
                    return <Observable<TenantListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTenant(response: HttpResponseBase): Observable<TenantListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TenantListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantListDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTenant(body: CreateTenantInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenant(body: TenantEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockTenantAdmin(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberActivityOutput.fromJS(resultData200) : new GetMemberActivityOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDashboardDataOutput.fromJS(resultData200) : new GetDashboardDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getTopStats(): Observable<GetTopStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetTopStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStats(<any>response_);
                } catch (e) {
                    return <Observable<GetTopStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTopStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopStats(response: HttpResponseBase): Observable<GetTopStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTopStatsOutput.fromJS(resultData200) : new GetTopStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTopStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfitShare(): Observable<GetProfitShareOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetProfitShare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfitShare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfitShare(<any>response_);
                } catch (e) {
                    return <Observable<GetProfitShareOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfitShareOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfitShare(response: HttpResponseBase): Observable<GetProfitShareOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfitShareOutput.fromJS(resultData200) : new GetProfitShareOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfitShareOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDailySales(): Observable<GetDailySalesOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDailySales";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDailySales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDailySales(<any>response_);
                } catch (e) {
                    return <Observable<GetDailySalesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDailySalesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDailySales(response: HttpResponseBase): Observable<GetDailySalesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDailySalesOutput.fromJS(resultData200) : new GetDailySalesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDailySalesOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSalesSummaryOutput.fromJS(resultData200) : new GetSalesSummaryOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRegionalStatsOutput.fromJS(resultData200) : new GetRegionalStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetGeneralStatsOutput.fromJS(resultData200) : new GetGeneralStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTenant(body: RegisterTenantInput | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterTenantOutput.fromJS(resultData200) : new RegisterTenantOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionsSelectOutput.fromJS(resultData200) : new EditionsSelectOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionSelectDto.fromJS(resultData200) : new EditionSelectDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: TenantSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TextBooksServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllTextBook(): Observable<GetDataAndColumnConfig_TextBook> {
        let url_ = this.baseUrl + "/api/services/app/TextBooks/GetAllTextBook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTextBook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTextBook(<any>response_);
                } catch (e) {
                    return <Observable<GetDataAndColumnConfig_TextBook>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDataAndColumnConfig_TextBook>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTextBook(response: HttpResponseBase): Observable<GetDataAndColumnConfig_TextBook> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDataAndColumnConfig_TextBook.fromJS(resultData200) : new GetDataAndColumnConfig_TextBook();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDataAndColumnConfig_TextBook>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxSoDenFilter (optional) 
     * @param minSoDenFilter (optional) 
     * @param maxNgayDenFilter (optional) 
     * @param minNgayDenFilter (optional) 
     * @param soHieuGocFilter (optional) 
     * @param coQuanBanHanhFilter (optional) 
     * @param trichYeuFilter (optional) 
     * @param nguoiChiDaoFilter (optional) 
     * @param nguoi_DonViFilter (optional) 
     * @param fileDinhKemFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxSoDenFilter: number | undefined, minSoDenFilter: number | undefined, maxNgayDenFilter: moment.Moment | undefined, minNgayDenFilter: moment.Moment | undefined, soHieuGocFilter: string | undefined, coQuanBanHanhFilter: string | undefined, trichYeuFilter: string | undefined, nguoiChiDaoFilter: string | undefined, nguoi_DonViFilter: string | undefined, fileDinhKemFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTextBookForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TextBooks/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxSoDenFilter === null)
            throw new Error("The parameter 'maxSoDenFilter' cannot be null.");
        else if (maxSoDenFilter !== undefined)
            url_ += "MaxSoDenFilter=" + encodeURIComponent("" + maxSoDenFilter) + "&"; 
        if (minSoDenFilter === null)
            throw new Error("The parameter 'minSoDenFilter' cannot be null.");
        else if (minSoDenFilter !== undefined)
            url_ += "MinSoDenFilter=" + encodeURIComponent("" + minSoDenFilter) + "&"; 
        if (maxNgayDenFilter === null)
            throw new Error("The parameter 'maxNgayDenFilter' cannot be null.");
        else if (maxNgayDenFilter !== undefined)
            url_ += "MaxNgayDenFilter=" + encodeURIComponent(maxNgayDenFilter ? "" + maxNgayDenFilter.toJSON() : "") + "&"; 
        if (minNgayDenFilter === null)
            throw new Error("The parameter 'minNgayDenFilter' cannot be null.");
        else if (minNgayDenFilter !== undefined)
            url_ += "MinNgayDenFilter=" + encodeURIComponent(minNgayDenFilter ? "" + minNgayDenFilter.toJSON() : "") + "&"; 
        if (soHieuGocFilter === null)
            throw new Error("The parameter 'soHieuGocFilter' cannot be null.");
        else if (soHieuGocFilter !== undefined)
            url_ += "SoHieuGocFilter=" + encodeURIComponent("" + soHieuGocFilter) + "&"; 
        if (coQuanBanHanhFilter === null)
            throw new Error("The parameter 'coQuanBanHanhFilter' cannot be null.");
        else if (coQuanBanHanhFilter !== undefined)
            url_ += "CoQuanBanHanhFilter=" + encodeURIComponent("" + coQuanBanHanhFilter) + "&"; 
        if (trichYeuFilter === null)
            throw new Error("The parameter 'trichYeuFilter' cannot be null.");
        else if (trichYeuFilter !== undefined)
            url_ += "TrichYeuFilter=" + encodeURIComponent("" + trichYeuFilter) + "&"; 
        if (nguoiChiDaoFilter === null)
            throw new Error("The parameter 'nguoiChiDaoFilter' cannot be null.");
        else if (nguoiChiDaoFilter !== undefined)
            url_ += "NguoiChiDaoFilter=" + encodeURIComponent("" + nguoiChiDaoFilter) + "&"; 
        if (nguoi_DonViFilter === null)
            throw new Error("The parameter 'nguoi_DonViFilter' cannot be null.");
        else if (nguoi_DonViFilter !== undefined)
            url_ += "Nguoi_DonViFilter=" + encodeURIComponent("" + nguoi_DonViFilter) + "&"; 
        if (fileDinhKemFilter === null)
            throw new Error("The parameter 'fileDinhKemFilter' cannot be null.");
        else if (fileDinhKemFilter !== undefined)
            url_ += "FileDinhKemFilter=" + encodeURIComponent("" + fileDinhKemFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTextBookForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTextBookForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTextBookForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTextBookForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetTextBookForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTextBookForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTextBookForView(id: number | undefined): Observable<GetTextBookForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TextBooks/GetTextBookForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTextBookForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTextBookForView(<any>response_);
                } catch (e) {
                    return <Observable<GetTextBookForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTextBookForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTextBookForView(response: HttpResponseBase): Observable<GetTextBookForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTextBookForViewDto.fromJS(resultData200) : new GetTextBookForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTextBookForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTextBookForEdit(id: number | undefined): Observable<GetTextBookForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TextBooks/GetTextBookForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTextBookForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTextBookForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTextBookForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTextBookForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTextBookForEdit(response: HttpResponseBase): Observable<GetTextBookForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTextBookForEditOutput.fromJS(resultData200) : new GetTextBookForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTextBookForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTextBookDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TextBooks/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TextBooks/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxSoDenFilter (optional) 
     * @param minSoDenFilter (optional) 
     * @param maxNgayDenFilter (optional) 
     * @param minNgayDenFilter (optional) 
     * @param soHieuGocFilter (optional) 
     * @param coQuanBanHanhFilter (optional) 
     * @param trichYeuFilter (optional) 
     * @param nguoiChiDaoFilter (optional) 
     * @param nguoi_DonViFilter (optional) 
     * @param fileDinhKemFilter (optional) 
     * @return Success
     */
    getTextBooksToExcel(filter: string | undefined, maxSoDenFilter: number | undefined, minSoDenFilter: number | undefined, maxNgayDenFilter: moment.Moment | undefined, minNgayDenFilter: moment.Moment | undefined, soHieuGocFilter: string | undefined, coQuanBanHanhFilter: string | undefined, trichYeuFilter: string | undefined, nguoiChiDaoFilter: string | undefined, nguoi_DonViFilter: string | undefined, fileDinhKemFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TextBooks/GetTextBooksToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxSoDenFilter === null)
            throw new Error("The parameter 'maxSoDenFilter' cannot be null.");
        else if (maxSoDenFilter !== undefined)
            url_ += "MaxSoDenFilter=" + encodeURIComponent("" + maxSoDenFilter) + "&"; 
        if (minSoDenFilter === null)
            throw new Error("The parameter 'minSoDenFilter' cannot be null.");
        else if (minSoDenFilter !== undefined)
            url_ += "MinSoDenFilter=" + encodeURIComponent("" + minSoDenFilter) + "&"; 
        if (maxNgayDenFilter === null)
            throw new Error("The parameter 'maxNgayDenFilter' cannot be null.");
        else if (maxNgayDenFilter !== undefined)
            url_ += "MaxNgayDenFilter=" + encodeURIComponent(maxNgayDenFilter ? "" + maxNgayDenFilter.toJSON() : "") + "&"; 
        if (minNgayDenFilter === null)
            throw new Error("The parameter 'minNgayDenFilter' cannot be null.");
        else if (minNgayDenFilter !== undefined)
            url_ += "MinNgayDenFilter=" + encodeURIComponent(minNgayDenFilter ? "" + minNgayDenFilter.toJSON() : "") + "&"; 
        if (soHieuGocFilter === null)
            throw new Error("The parameter 'soHieuGocFilter' cannot be null.");
        else if (soHieuGocFilter !== undefined)
            url_ += "SoHieuGocFilter=" + encodeURIComponent("" + soHieuGocFilter) + "&"; 
        if (coQuanBanHanhFilter === null)
            throw new Error("The parameter 'coQuanBanHanhFilter' cannot be null.");
        else if (coQuanBanHanhFilter !== undefined)
            url_ += "CoQuanBanHanhFilter=" + encodeURIComponent("" + coQuanBanHanhFilter) + "&"; 
        if (trichYeuFilter === null)
            throw new Error("The parameter 'trichYeuFilter' cannot be null.");
        else if (trichYeuFilter !== undefined)
            url_ += "TrichYeuFilter=" + encodeURIComponent("" + trichYeuFilter) + "&"; 
        if (nguoiChiDaoFilter === null)
            throw new Error("The parameter 'nguoiChiDaoFilter' cannot be null.");
        else if (nguoiChiDaoFilter !== undefined)
            url_ += "NguoiChiDaoFilter=" + encodeURIComponent("" + nguoiChiDaoFilter) + "&"; 
        if (nguoi_DonViFilter === null)
            throw new Error("The parameter 'nguoi_DonViFilter' cannot be null.");
        else if (nguoi_DonViFilter !== undefined)
            url_ += "Nguoi_DonViFilter=" + encodeURIComponent("" + nguoi_DonViFilter) + "&"; 
        if (fileDinhKemFilter === null)
            throw new Error("The parameter 'fileDinhKemFilter' cannot be null.");
        else if (fileDinhKemFilter !== undefined)
            url_ += "FileDinhKemFilter=" + encodeURIComponent("" + fileDinhKemFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTextBooksToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTextBooksToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTextBooksToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId === null)
            throw new Error("The parameter 'selectedTimezoneId' cannot be null.");
        else if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TinhThanhsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenTinh (optional) 
     * @return Success
     */
    checkTenTinhThanh(tenTinh: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/TinhThanhs/CheckTenTinhThanh?";
        if (tenTinh === null)
            throw new Error("The parameter 'tenTinh' cannot be null.");
        else if (tenTinh !== undefined)
            url_ += "tenTinh=" + encodeURIComponent("" + tenTinh) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckTenTinhThanh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTenTinhThanh(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckTenTinhThanh(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTinhThanh(): Observable<TinhThanhDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TinhThanhs/GetAllTinhThanh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTinhThanh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTinhThanh(<any>response_);
                } catch (e) {
                    return <Observable<TinhThanhDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TinhThanhDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTinhThanh(response: HttpResponseBase): Observable<TinhThanhDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TinhThanhDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinhThanhDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenTinhThanhFilter (optional) 
     * @param maTinhThanhFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, tenTinhThanhFilter: string | undefined, maTinhThanhFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTinhThanhForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TinhThanhs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenTinhThanhFilter === null)
            throw new Error("The parameter 'tenTinhThanhFilter' cannot be null.");
        else if (tenTinhThanhFilter !== undefined)
            url_ += "TenTinhThanhFilter=" + encodeURIComponent("" + tenTinhThanhFilter) + "&"; 
        if (maTinhThanhFilter === null)
            throw new Error("The parameter 'maTinhThanhFilter' cannot be null.");
        else if (maTinhThanhFilter !== undefined)
            url_ += "MaTinhThanhFilter=" + encodeURIComponent("" + maTinhThanhFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTinhThanhForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTinhThanhForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTinhThanhForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTinhThanhForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetTinhThanhForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTinhThanhForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTinhThanhForView(id: number | undefined): Observable<GetTinhThanhForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TinhThanhs/GetTinhThanhForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTinhThanhForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTinhThanhForView(<any>response_);
                } catch (e) {
                    return <Observable<GetTinhThanhForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTinhThanhForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTinhThanhForView(response: HttpResponseBase): Observable<GetTinhThanhForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTinhThanhForViewDto.fromJS(resultData200) : new GetTinhThanhForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTinhThanhForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTinhThanhForEdit(id: number | undefined): Observable<GetTinhThanhForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TinhThanhs/GetTinhThanhForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTinhThanhForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTinhThanhForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTinhThanhForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTinhThanhForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTinhThanhForEdit(response: HttpResponseBase): Observable<GetTinhThanhForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTinhThanhForEditOutput.fromJS(resultData200) : new GetTinhThanhForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTinhThanhForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTinhThanhDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TinhThanhs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TinhThanhs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenTinhThanhFilter (optional) 
     * @param maTinhThanhFilter (optional) 
     * @return Success
     */
    getTinhThanhsToExcel(filter: string | undefined, tenTinhThanhFilter: string | undefined, maTinhThanhFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TinhThanhs/GetTinhThanhsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenTinhThanhFilter === null)
            throw new Error("The parameter 'tenTinhThanhFilter' cannot be null.");
        else if (tenTinhThanhFilter !== undefined)
            url_ += "TenTinhThanhFilter=" + encodeURIComponent("" + tenTinhThanhFilter) + "&"; 
        if (maTinhThanhFilter === null)
            throw new Error("The parameter 'maTinhThanhFilter' cannot be null.");
        else if (maTinhThanhFilter !== undefined)
            url_ += "MaTinhThanhFilter=" + encodeURIComponent("" + maTinhThanhFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTinhThanhsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTinhThanhsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTinhThanhsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken === null)
            throw new Error("The parameter 'refreshToken' cannot be null.");
        else if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<RefreshTokenResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RefreshTokenResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RefreshTokenResult.fromJS(resultData200) : new RefreshTokenResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RefreshTokenResult>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(body: SendTwoFactorAuthCodeModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken === null)
            throw new Error("The parameter 'impersonationToken' cannot be null.");
        else if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken === null)
            throw new Error("The parameter 'switchAccountToken' cannot be null.");
        else if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | undefined, severity: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message === null)
            throw new Error("The parameter 'message' cannot be null.");
        else if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        if (severity === null)
            throw new Error("The parameter 'severity' cannot be null.");
        else if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TypeHandesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTypeHandeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TypeHandes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTypeHandeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTypeHandeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTypeHandeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTypeHandeForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetTypeHandeForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTypeHandeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTypeHandeForView(id: number | undefined): Observable<GetTypeHandeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TypeHandes/GetTypeHandeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTypeHandeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTypeHandeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetTypeHandeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTypeHandeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTypeHandeForView(response: HttpResponseBase): Observable<GetTypeHandeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTypeHandeForViewDto.fromJS(resultData200) : new GetTypeHandeForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTypeHandeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTypeHandeForEdit(id: number | undefined): Observable<GetTypeHandeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TypeHandes/GetTypeHandeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTypeHandeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTypeHandeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTypeHandeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTypeHandeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTypeHandeForEdit(response: HttpResponseBase): Observable<GetTypeHandeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTypeHandeForEditOutput.fromJS(resultData200) : new GetTypeHandeForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTypeHandeForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTypeHandeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TypeHandes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TypeHandes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @return Success
     */
    getTypeHandesToExcel(filter: string | undefined, nameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TypeHandes/GetTypeHandesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTypeHandesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTypeHandesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTypeHandesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class TransferAndHandingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param documentId (optional) 
     * @return Success
     */
    getListHandlingByDocumentId(documentId: number | undefined): Observable<DocumentHandlingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TransferAndHanding/GetListHandlingByDocumentId?";
        if (documentId === null)
            throw new Error("The parameter 'documentId' cannot be null.");
        else if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListHandlingByDocumentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListHandlingByDocumentId(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHandlingDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHandlingDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListHandlingByDocumentId(response: HttpResponseBase): Observable<DocumentHandlingDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentHandlingDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHandlingDto[]>(<any>null);
    }
}

@Injectable()
export class TruongGiaoDichsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllTruongGiaoDich(): Observable<TruongGiaoDichDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TruongGiaoDichs/GetAllTruongGiaoDich";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTruongGiaoDich(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTruongGiaoDich(<any>response_);
                } catch (e) {
                    return <Observable<TruongGiaoDichDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TruongGiaoDichDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTruongGiaoDich(response: HttpResponseBase): Observable<TruongGiaoDichDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TruongGiaoDichDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TruongGiaoDichDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param cDNameFilter (optional) 
     * @param valueFilter (optional) 
     * @param ghiChuFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, codeFilter: string | undefined, cDNameFilter: string | undefined, valueFilter: string | undefined, ghiChuFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTruongGiaoDichForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TruongGiaoDichs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (cDNameFilter === null)
            throw new Error("The parameter 'cDNameFilter' cannot be null.");
        else if (cDNameFilter !== undefined)
            url_ += "CDNameFilter=" + encodeURIComponent("" + cDNameFilter) + "&"; 
        if (valueFilter === null)
            throw new Error("The parameter 'valueFilter' cannot be null.");
        else if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (ghiChuFilter === null)
            throw new Error("The parameter 'ghiChuFilter' cannot be null.");
        else if (ghiChuFilter !== undefined)
            url_ += "GhiChuFilter=" + encodeURIComponent("" + ghiChuFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTruongGiaoDichForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTruongGiaoDichForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTruongGiaoDichForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTruongGiaoDichForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetTruongGiaoDichForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTruongGiaoDichForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTruongGiaoDichForView(id: number | undefined): Observable<GetTruongGiaoDichForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TruongGiaoDichs/GetTruongGiaoDichForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTruongGiaoDichForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTruongGiaoDichForView(<any>response_);
                } catch (e) {
                    return <Observable<GetTruongGiaoDichForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTruongGiaoDichForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTruongGiaoDichForView(response: HttpResponseBase): Observable<GetTruongGiaoDichForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTruongGiaoDichForViewDto.fromJS(resultData200) : new GetTruongGiaoDichForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTruongGiaoDichForViewDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setDefaultValue(body: TruongGiaoDichDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TruongGiaoDichs/SetDefaultValue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultValue(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultValue(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTruongGiaoDichForEdit(id: number | undefined): Observable<GetTruongGiaoDichForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TruongGiaoDichs/GetTruongGiaoDichForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTruongGiaoDichForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTruongGiaoDichForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTruongGiaoDichForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTruongGiaoDichForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTruongGiaoDichForEdit(response: HttpResponseBase): Observable<GetTruongGiaoDichForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTruongGiaoDichForEditOutput.fromJS(resultData200) : new GetTruongGiaoDichForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTruongGiaoDichForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTruongGiaoDichDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TruongGiaoDichs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TruongGiaoDichs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param cDNameFilter (optional) 
     * @param valueFilter (optional) 
     * @param ghiChuFilter (optional) 
     * @return Success
     */
    getTruongGiaoDichsToExcel(filter: string | undefined, codeFilter: string | undefined, cDNameFilter: string | undefined, valueFilter: string | undefined, ghiChuFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TruongGiaoDichs/GetTruongGiaoDichsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (cDNameFilter === null)
            throw new Error("The parameter 'cDNameFilter' cannot be null.");
        else if (cDNameFilter !== undefined)
            url_ += "CDNameFilter=" + encodeURIComponent("" + cDNameFilter) + "&"; 
        if (valueFilter === null)
            throw new Error("The parameter 'valueFilter' cannot be null.");
        else if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (ghiChuFilter === null)
            throw new Error("The parameter 'ghiChuFilter' cannot be null.");
        else if (ghiChuFilter !== undefined)
            url_ += "GhiChuFilter=" + encodeURIComponent("" + ghiChuFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTruongGiaoDichsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTruongGiaoDichsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTruongGiaoDichsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<ThemeSettingsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThemeSettingsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ThemeSettingsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThemeSettingsDto[]>(<any>null);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName === null)
            throw new Error("The parameter 'themeName' cannot be null.");
        else if (themeName !== undefined)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UngViensServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param cmnd (optional) 
     * @return Success
     */
    checkCMND(cmnd: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/CheckCMND?";
        if (cmnd === null)
            throw new Error("The parameter 'cmnd' cannot be null.");
        else if (cmnd !== undefined)
            url_ += "cmnd=" + encodeURIComponent("" + cmnd) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCMND(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCMND(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckCMND(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailKH(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/SendEmailKH";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailKH(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailKH(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailKH(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCMND(): Observable<UngVienDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/GetAllCMND";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCMND(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCMND(<any>response_);
                } catch (e) {
                    return <Observable<UngVienDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UngVienDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCMND(response: HttpResponseBase): Observable<UngVienDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UngVienDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UngVienDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maUngVienFilter (optional) 
     * @param hoVaTenFilter (optional) 
     * @param viTriUngTuyenCodeFilter (optional) 
     * @param kenhTuyenDungCodeFilter (optional) 
     * @param gioiTinhCodeFilter (optional) 
     * @param trangThaiCodeFilter (optional) 
     * @param startDateFilter (optional) 
     * @param endDateFilter (optional) 
     * @param isCheckTimeFilter (optional) 
     * @param createTimeFilter (optional) 
     * @param lastModificationTimeFilter (optional) 
     * @param tienDoTuyenDungCodeFilter (optional) 
     * @param minDay1Filter (optional) 
     * @param maxDay1Filter (optional) 
     * @param minDay2Filter (optional) 
     * @param maxDay2Filter (optional) 
     * @param minDay3Filter (optional) 
     * @param maxDay3Filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maUngVienFilter: string | undefined, hoVaTenFilter: string | undefined, viTriUngTuyenCodeFilter: string | undefined, kenhTuyenDungCodeFilter: string | undefined, gioiTinhCodeFilter: string | undefined, trangThaiCodeFilter: string | undefined, startDateFilter: moment.Moment | undefined, endDateFilter: moment.Moment | undefined, isCheckTimeFilter: boolean | undefined, createTimeFilter: moment.Moment | undefined, lastModificationTimeFilter: moment.Moment | undefined, tienDoTuyenDungCodeFilter: string | undefined, minDay1Filter: moment.Moment | undefined, maxDay1Filter: moment.Moment | undefined, minDay2Filter: moment.Moment | undefined, maxDay2Filter: moment.Moment | undefined, minDay3Filter: moment.Moment | undefined, maxDay3Filter: moment.Moment | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedFilterResultDtoOfGetUngVienForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maUngVienFilter === null)
            throw new Error("The parameter 'maUngVienFilter' cannot be null.");
        else if (maUngVienFilter !== undefined)
            url_ += "MaUngVienFilter=" + encodeURIComponent("" + maUngVienFilter) + "&"; 
        if (hoVaTenFilter === null)
            throw new Error("The parameter 'hoVaTenFilter' cannot be null.");
        else if (hoVaTenFilter !== undefined)
            url_ += "HoVaTenFilter=" + encodeURIComponent("" + hoVaTenFilter) + "&"; 
        if (viTriUngTuyenCodeFilter === null)
            throw new Error("The parameter 'viTriUngTuyenCodeFilter' cannot be null.");
        else if (viTriUngTuyenCodeFilter !== undefined)
            url_ += "ViTriUngTuyenCodeFilter=" + encodeURIComponent("" + viTriUngTuyenCodeFilter) + "&"; 
        if (kenhTuyenDungCodeFilter === null)
            throw new Error("The parameter 'kenhTuyenDungCodeFilter' cannot be null.");
        else if (kenhTuyenDungCodeFilter !== undefined)
            url_ += "KenhTuyenDungCodeFilter=" + encodeURIComponent("" + kenhTuyenDungCodeFilter) + "&"; 
        if (gioiTinhCodeFilter === null)
            throw new Error("The parameter 'gioiTinhCodeFilter' cannot be null.");
        else if (gioiTinhCodeFilter !== undefined)
            url_ += "GioiTinhCodeFilter=" + encodeURIComponent("" + gioiTinhCodeFilter) + "&"; 
        if (trangThaiCodeFilter === null)
            throw new Error("The parameter 'trangThaiCodeFilter' cannot be null.");
        else if (trangThaiCodeFilter !== undefined)
            url_ += "TrangThaiCodeFilter=" + encodeURIComponent("" + trangThaiCodeFilter) + "&"; 
        if (startDateFilter === null)
            throw new Error("The parameter 'startDateFilter' cannot be null.");
        else if (startDateFilter !== undefined)
            url_ += "StartDateFilter=" + encodeURIComponent(startDateFilter ? "" + startDateFilter.toJSON() : "") + "&"; 
        if (endDateFilter === null)
            throw new Error("The parameter 'endDateFilter' cannot be null.");
        else if (endDateFilter !== undefined)
            url_ += "EndDateFilter=" + encodeURIComponent(endDateFilter ? "" + endDateFilter.toJSON() : "") + "&"; 
        if (isCheckTimeFilter === null)
            throw new Error("The parameter 'isCheckTimeFilter' cannot be null.");
        else if (isCheckTimeFilter !== undefined)
            url_ += "isCheckTimeFilter=" + encodeURIComponent("" + isCheckTimeFilter) + "&"; 
        if (createTimeFilter === null)
            throw new Error("The parameter 'createTimeFilter' cannot be null.");
        else if (createTimeFilter !== undefined)
            url_ += "CreateTimeFilter=" + encodeURIComponent(createTimeFilter ? "" + createTimeFilter.toJSON() : "") + "&"; 
        if (lastModificationTimeFilter === null)
            throw new Error("The parameter 'lastModificationTimeFilter' cannot be null.");
        else if (lastModificationTimeFilter !== undefined)
            url_ += "LastModificationTimeFilter=" + encodeURIComponent(lastModificationTimeFilter ? "" + lastModificationTimeFilter.toJSON() : "") + "&"; 
        if (tienDoTuyenDungCodeFilter === null)
            throw new Error("The parameter 'tienDoTuyenDungCodeFilter' cannot be null.");
        else if (tienDoTuyenDungCodeFilter !== undefined)
            url_ += "TienDoTuyenDungCodeFilter=" + encodeURIComponent("" + tienDoTuyenDungCodeFilter) + "&"; 
        if (minDay1Filter === null)
            throw new Error("The parameter 'minDay1Filter' cannot be null.");
        else if (minDay1Filter !== undefined)
            url_ += "MinDay1Filter=" + encodeURIComponent(minDay1Filter ? "" + minDay1Filter.toJSON() : "") + "&"; 
        if (maxDay1Filter === null)
            throw new Error("The parameter 'maxDay1Filter' cannot be null.");
        else if (maxDay1Filter !== undefined)
            url_ += "MaxDay1Filter=" + encodeURIComponent(maxDay1Filter ? "" + maxDay1Filter.toJSON() : "") + "&"; 
        if (minDay2Filter === null)
            throw new Error("The parameter 'minDay2Filter' cannot be null.");
        else if (minDay2Filter !== undefined)
            url_ += "MinDay2Filter=" + encodeURIComponent(minDay2Filter ? "" + minDay2Filter.toJSON() : "") + "&"; 
        if (maxDay2Filter === null)
            throw new Error("The parameter 'maxDay2Filter' cannot be null.");
        else if (maxDay2Filter !== undefined)
            url_ += "MaxDay2Filter=" + encodeURIComponent(maxDay2Filter ? "" + maxDay2Filter.toJSON() : "") + "&"; 
        if (minDay3Filter === null)
            throw new Error("The parameter 'minDay3Filter' cannot be null.");
        else if (minDay3Filter !== undefined)
            url_ += "MinDay3Filter=" + encodeURIComponent(minDay3Filter ? "" + minDay3Filter.toJSON() : "") + "&"; 
        if (maxDay3Filter === null)
            throw new Error("The parameter 'maxDay3Filter' cannot be null.");
        else if (maxDay3Filter !== undefined)
            url_ += "MaxDay3Filter=" + encodeURIComponent(maxDay3Filter ? "" + maxDay3Filter.toJSON() : "") + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedFilterResultDtoOfGetUngVienForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedFilterResultDtoOfGetUngVienForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedFilterResultDtoOfGetUngVienForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedFilterResultDtoOfGetUngVienForViewDto.fromJS(resultData200) : new PagedFilterResultDtoOfGetUngVienForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedFilterResultDtoOfGetUngVienForViewDto>(<any>null);
    }

    /**
     * @return Success
     */
    getListItemSearch(): Observable<GetUngVienForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/GetListItemSearch";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListItemSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListItemSearch(<any>response_);
                } catch (e) {
                    return <Observable<GetUngVienForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUngVienForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetListItemSearch(response: HttpResponseBase): Observable<GetUngVienForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUngVienForEditOutput.fromJS(resultData200) : new GetUngVienForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUngVienForEditOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUngVien(): Observable<UngVienDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/GetAllUngVien";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUngVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUngVien(<any>response_);
                } catch (e) {
                    return <Observable<UngVienDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UngVienDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUngVien(response: HttpResponseBase): Observable<UngVienDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UngVienDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UngVienDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUngVienForView(id: number | undefined): Observable<GetUngVienForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/GetUngVienForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUngVienForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUngVienForView(<any>response_);
                } catch (e) {
                    return <Observable<GetUngVienForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUngVienForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUngVienForView(response: HttpResponseBase): Observable<GetUngVienForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUngVienForViewDto.fromJS(resultData200) : new GetUngVienForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUngVienForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUngVienForEdit(id: number | undefined): Observable<GetUngVienForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/GetUngVienForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUngVienForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUngVienForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUngVienForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUngVienForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUngVienForEdit(response: HttpResponseBase): Observable<GetUngVienForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUngVienForEditOutput.fromJS(resultData200) : new GetUngVienForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUngVienForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUngVienForUpdate(id: number | undefined): Observable<GetUngVienForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/GetUngVienForUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUngVienForUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUngVienForUpdate(<any>response_);
                } catch (e) {
                    return <Observable<GetUngVienForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUngVienForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUngVienForUpdate(response: HttpResponseBase): Observable<GetUngVienForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUngVienForEditOutput.fromJS(resultData200) : new GetUngVienForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUngVienForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditUngVienInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenTP (optional) 
     * @return Success
     */
    getMaTinhThanh(tenTP: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/GetMaTinhThanh?";
        if (tenTP === null)
            throw new Error("The parameter 'tenTP' cannot be null.");
        else if (tenTP !== undefined)
            url_ += "tenTP=" + encodeURIComponent("" + tenTP) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaTinhThanh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaTinhThanh(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaTinhThanh(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenNDT (optional) 
     * @return Success
     */
    getMaNoiDaotao(tenNDT: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/GetMaNoiDaotao?";
        if (tenNDT === null)
            throw new Error("The parameter 'tenNDT' cannot be null.");
        else if (tenNDT !== undefined)
            url_ += "tenNDT=" + encodeURIComponent("" + tenNDT) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaNoiDaotao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaNoiDaotao(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaNoiDaotao(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param currentTime (optional) 
     * @param path (optional) 
     * @return Success
     */
    importToExcel(currentTime: string | undefined, path: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/UngViens/importToExcel?";
        if (currentTime === null)
            throw new Error("The parameter 'currentTime' cannot be null.");
        else if (currentTime !== undefined)
            url_ += "currentTime=" + encodeURIComponent("" + currentTime) + "&"; 
        if (path === null)
            throw new Error("The parameter 'path' cannot be null.");
        else if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | undefined, permissions: string[] | undefined, role: number | undefined, onlyLockedUsers: boolean | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permissions === null)
            throw new Error("The parameter 'permissions' cannot be null.");
        else if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserListDto.fromJS(resultData200) : new PagedResultDtoOfUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getUsersToExcel(filter: string | undefined, permissions: string[] | undefined, role: number | undefined, onlyLockedUsers: boolean | undefined, sorting: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permissions === null)
            throw new Error("The parameter 'permissions' cannot be null.");
        else if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getListUsersToExcel(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetListUsersToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetListUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param value (optional) 
     * @return Success
     */
    convertToUnSign(value: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/User/ConvertToUnSign?";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConvertToUnSign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConvertToUnSign(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processConvertToUnSign(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserPermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUser(body: CreateOrUpdateUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockUser(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleNameOfUser(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoleNameOfUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleNameOfUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleNameOfUser(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleNameOfUser(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleIdOfUser(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoleIdOfUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleIdOfUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleIdOfUser(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleIdOfUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getProfileStatus(): Observable<TruongGiaoDichDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetProfileStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfileStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfileStatus(<any>response_);
                } catch (e) {
                    return <Observable<TruongGiaoDichDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TruongGiaoDichDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfileStatus(response: HttpResponseBase): Observable<TruongGiaoDichDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TruongGiaoDichDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TruongGiaoDichDto[]>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    linkToUser(body: LinkToUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLinkedUserDto.fromJS(resultData200) : new PagedResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLinkedUserDto.fromJS(resultData200) : new ListResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200) : new ListResultDtoOfUserLoginAttemptDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForView(id: number | undefined): Observable<GetUserLoginForEdit> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetUserForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForView(<any>response_);
                } catch (e) {
                    return <Observable<GetUserLoginForEdit>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserLoginForEdit>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForView(response: HttpResponseBase): Observable<GetUserLoginForEdit> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserLoginForEdit.fromJS(resultData200) : new GetUserLoginForEdit();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserLoginForEdit>(<any>null);
    }
}

@Injectable()
export class VanbansServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllVanBan(): Observable<GetDataAndColumnConfig> {
        let url_ = this.baseUrl + "/api/services/app/Vanbans/GetAllVanBan";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVanBan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVanBan(<any>response_);
                } catch (e) {
                    return <Observable<GetDataAndColumnConfig>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDataAndColumnConfig>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVanBan(response: HttpResponseBase): Observable<GetDataAndColumnConfig> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDataAndColumnConfig.fromJS(resultData200) : new GetDataAndColumnConfig();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDataAndColumnConfig>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenCongViecFilter (optional) 
     * @param maxNgayGiaoViecFilter (optional) 
     * @param minNgayGiaoViecFilter (optional) 
     * @param maxHanKetThucFilter (optional) 
     * @param minHanKetThucFilter (optional) 
     * @param nguoiXuLyFilter (optional) 
     * @param maxTienDoChungFilter (optional) 
     * @param minTienDoChungFilter (optional) 
     * @param tinhTrangFilter (optional) 
     * @param noiDungFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, tenCongViecFilter: string | undefined, maxNgayGiaoViecFilter: moment.Moment | undefined, minNgayGiaoViecFilter: moment.Moment | undefined, maxHanKetThucFilter: moment.Moment | undefined, minHanKetThucFilter: moment.Moment | undefined, nguoiXuLyFilter: string | undefined, maxTienDoChungFilter: number | undefined, minTienDoChungFilter: number | undefined, tinhTrangFilter: string | undefined, noiDungFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetVanbanForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Vanbans/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenCongViecFilter === null)
            throw new Error("The parameter 'tenCongViecFilter' cannot be null.");
        else if (tenCongViecFilter !== undefined)
            url_ += "TenCongViecFilter=" + encodeURIComponent("" + tenCongViecFilter) + "&"; 
        if (maxNgayGiaoViecFilter === null)
            throw new Error("The parameter 'maxNgayGiaoViecFilter' cannot be null.");
        else if (maxNgayGiaoViecFilter !== undefined)
            url_ += "MaxNgayGiaoViecFilter=" + encodeURIComponent(maxNgayGiaoViecFilter ? "" + maxNgayGiaoViecFilter.toJSON() : "") + "&"; 
        if (minNgayGiaoViecFilter === null)
            throw new Error("The parameter 'minNgayGiaoViecFilter' cannot be null.");
        else if (minNgayGiaoViecFilter !== undefined)
            url_ += "MinNgayGiaoViecFilter=" + encodeURIComponent(minNgayGiaoViecFilter ? "" + minNgayGiaoViecFilter.toJSON() : "") + "&"; 
        if (maxHanKetThucFilter === null)
            throw new Error("The parameter 'maxHanKetThucFilter' cannot be null.");
        else if (maxHanKetThucFilter !== undefined)
            url_ += "MaxHanKetThucFilter=" + encodeURIComponent(maxHanKetThucFilter ? "" + maxHanKetThucFilter.toJSON() : "") + "&"; 
        if (minHanKetThucFilter === null)
            throw new Error("The parameter 'minHanKetThucFilter' cannot be null.");
        else if (minHanKetThucFilter !== undefined)
            url_ += "MinHanKetThucFilter=" + encodeURIComponent(minHanKetThucFilter ? "" + minHanKetThucFilter.toJSON() : "") + "&"; 
        if (nguoiXuLyFilter === null)
            throw new Error("The parameter 'nguoiXuLyFilter' cannot be null.");
        else if (nguoiXuLyFilter !== undefined)
            url_ += "NguoiXuLyFilter=" + encodeURIComponent("" + nguoiXuLyFilter) + "&"; 
        if (maxTienDoChungFilter === null)
            throw new Error("The parameter 'maxTienDoChungFilter' cannot be null.");
        else if (maxTienDoChungFilter !== undefined)
            url_ += "MaxTienDoChungFilter=" + encodeURIComponent("" + maxTienDoChungFilter) + "&"; 
        if (minTienDoChungFilter === null)
            throw new Error("The parameter 'minTienDoChungFilter' cannot be null.");
        else if (minTienDoChungFilter !== undefined)
            url_ += "MinTienDoChungFilter=" + encodeURIComponent("" + minTienDoChungFilter) + "&"; 
        if (tinhTrangFilter === null)
            throw new Error("The parameter 'tinhTrangFilter' cannot be null.");
        else if (tinhTrangFilter !== undefined)
            url_ += "TinhTrangFilter=" + encodeURIComponent("" + tinhTrangFilter) + "&"; 
        if (noiDungFilter === null)
            throw new Error("The parameter 'noiDungFilter' cannot be null.");
        else if (noiDungFilter !== undefined)
            url_ += "NoiDungFilter=" + encodeURIComponent("" + noiDungFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetVanbanForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetVanbanForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetVanbanForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetVanbanForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetVanbanForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetVanbanForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVanbanForView(id: number | undefined): Observable<GetVanbanForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Vanbans/GetVanbanForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVanbanForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVanbanForView(<any>response_);
                } catch (e) {
                    return <Observable<GetVanbanForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVanbanForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVanbanForView(response: HttpResponseBase): Observable<GetVanbanForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetVanbanForViewDto.fromJS(resultData200) : new GetVanbanForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVanbanForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVanbanForEdit(id: number | undefined): Observable<GetVanbanForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Vanbans/GetVanbanForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVanbanForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVanbanForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetVanbanForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVanbanForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetVanbanForEdit(response: HttpResponseBase): Observable<GetVanbanForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetVanbanForEditOutput.fromJS(resultData200) : new GetVanbanForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVanbanForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditVanbanDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vanbans/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vanbans/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenCongViecFilter (optional) 
     * @param maxNgayGiaoViecFilter (optional) 
     * @param minNgayGiaoViecFilter (optional) 
     * @param maxHanKetThucFilter (optional) 
     * @param minHanKetThucFilter (optional) 
     * @param nguoiXuLyFilter (optional) 
     * @param maxTienDoChungFilter (optional) 
     * @param minTienDoChungFilter (optional) 
     * @param tinhTrangFilter (optional) 
     * @param noiDungFilter (optional) 
     * @return Success
     */
    getVanbansToExcel(filter: string | undefined, tenCongViecFilter: string | undefined, maxNgayGiaoViecFilter: moment.Moment | undefined, minNgayGiaoViecFilter: moment.Moment | undefined, maxHanKetThucFilter: moment.Moment | undefined, minHanKetThucFilter: moment.Moment | undefined, nguoiXuLyFilter: string | undefined, maxTienDoChungFilter: number | undefined, minTienDoChungFilter: number | undefined, tinhTrangFilter: string | undefined, noiDungFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Vanbans/GetVanbansToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenCongViecFilter === null)
            throw new Error("The parameter 'tenCongViecFilter' cannot be null.");
        else if (tenCongViecFilter !== undefined)
            url_ += "TenCongViecFilter=" + encodeURIComponent("" + tenCongViecFilter) + "&"; 
        if (maxNgayGiaoViecFilter === null)
            throw new Error("The parameter 'maxNgayGiaoViecFilter' cannot be null.");
        else if (maxNgayGiaoViecFilter !== undefined)
            url_ += "MaxNgayGiaoViecFilter=" + encodeURIComponent(maxNgayGiaoViecFilter ? "" + maxNgayGiaoViecFilter.toJSON() : "") + "&"; 
        if (minNgayGiaoViecFilter === null)
            throw new Error("The parameter 'minNgayGiaoViecFilter' cannot be null.");
        else if (minNgayGiaoViecFilter !== undefined)
            url_ += "MinNgayGiaoViecFilter=" + encodeURIComponent(minNgayGiaoViecFilter ? "" + minNgayGiaoViecFilter.toJSON() : "") + "&"; 
        if (maxHanKetThucFilter === null)
            throw new Error("The parameter 'maxHanKetThucFilter' cannot be null.");
        else if (maxHanKetThucFilter !== undefined)
            url_ += "MaxHanKetThucFilter=" + encodeURIComponent(maxHanKetThucFilter ? "" + maxHanKetThucFilter.toJSON() : "") + "&"; 
        if (minHanKetThucFilter === null)
            throw new Error("The parameter 'minHanKetThucFilter' cannot be null.");
        else if (minHanKetThucFilter !== undefined)
            url_ += "MinHanKetThucFilter=" + encodeURIComponent(minHanKetThucFilter ? "" + minHanKetThucFilter.toJSON() : "") + "&"; 
        if (nguoiXuLyFilter === null)
            throw new Error("The parameter 'nguoiXuLyFilter' cannot be null.");
        else if (nguoiXuLyFilter !== undefined)
            url_ += "NguoiXuLyFilter=" + encodeURIComponent("" + nguoiXuLyFilter) + "&"; 
        if (maxTienDoChungFilter === null)
            throw new Error("The parameter 'maxTienDoChungFilter' cannot be null.");
        else if (maxTienDoChungFilter !== undefined)
            url_ += "MaxTienDoChungFilter=" + encodeURIComponent("" + maxTienDoChungFilter) + "&"; 
        if (minTienDoChungFilter === null)
            throw new Error("The parameter 'minTienDoChungFilter' cannot be null.");
        else if (minTienDoChungFilter !== undefined)
            url_ += "MinTienDoChungFilter=" + encodeURIComponent("" + minTienDoChungFilter) + "&"; 
        if (tinhTrangFilter === null)
            throw new Error("The parameter 'tinhTrangFilter' cannot be null.");
        else if (tinhTrangFilter !== undefined)
            url_ += "TinhTrangFilter=" + encodeURIComponent("" + tinhTrangFilter) + "&"; 
        if (noiDungFilter === null)
            throw new Error("The parameter 'noiDungFilter' cannot be null.");
        else if (noiDungFilter !== undefined)
            url_ += "NoiDungFilter=" + encodeURIComponent("" + noiDungFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVanbansToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVanbansToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVanbansToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getListAsyncById(id: number | undefined): Observable<VanbanListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Vanbans/GetListAsyncById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListAsyncById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListAsyncById(<any>response_);
                } catch (e) {
                    return <Observable<VanbanListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<VanbanListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListAsyncById(response: HttpResponseBase): Observable<VanbanListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(VanbanListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VanbanListDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadFile(body: Body | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vanbans/UploadFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ViTriCongViecsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param tenCtyFilter (optional) 
     * @param hopDongHienTaiFilter (optional) 
     * @param soHDFilter (optional) 
     * @param donViCongTacNameFilter (optional) 
     * @param choNgoiFilter (optional) 
     * @param maxNoiDaoTaoIDFilter (optional) 
     * @param minNoiDaoTaoIDFilter (optional) 
     * @param maxLoaiHopDongIDFilter (optional) 
     * @param minLoaiHopDongIDFilter (optional) 
     * @param maSoNoiKCBFilter (optional) 
     * @param maxNoiDangKyKCBIDFilter (optional) 
     * @param minNoiDangKyKCBIDFilter (optional) 
     * @param maxNgayHetHanBHYTFilter (optional) 
     * @param minNgayHetHanBHYTFilter (optional) 
     * @param soTheBHYTFilter (optional) 
     * @param maTinhCapFilter (optional) 
     * @param maSoBHXHFilter (optional) 
     * @param soSoBHXHFilter (optional) 
     * @param maxTyLeDongBHFilter (optional) 
     * @param minTyLeDongBHFilter (optional) 
     * @param maxNgayThamGiaBHFilter (optional) 
     * @param minNgayThamGiaBHFilter (optional) 
     * @param thamGiaCongDoanFilter (optional) 
     * @param nganHangCodeFilter (optional) 
     * @param tkNganHangFilter (optional) 
     * @param donViSoCongChuanCodeFilter (optional) 
     * @param soCongChuanFilter (optional) 
     * @param luongDongBHFilter (optional) 
     * @param luongCoBanFilter (optional) 
     * @param bacLuongCodeFilter (optional) 
     * @param maxSoNgayPhepFilter (optional) 
     * @param minSoNgayPhepFilter (optional) 
     * @param maxNgayChinhThucFilter (optional) 
     * @param minNgayChinhThucFilter (optional) 
     * @param maxNgayThuViecFilter (optional) 
     * @param minNgayThuViecFilter (optional) 
     * @param maxNgayTapSuFilter (optional) 
     * @param minNgayTapSuFilter (optional) 
     * @param soSoQLLaoDongFilter (optional) 
     * @param diaDiemLamViecCodeFilter (optional) 
     * @param quanLyGianTiepFilter (optional) 
     * @param quanLyTrucTiepFilter (optional) 
     * @param trangThaiLamViecCodeFilter (optional) 
     * @param bacFilter (optional) 
     * @param capFilter (optional) 
     * @param chucDanhFilter (optional) 
     * @param maChamCongFilter (optional) 
     * @param diaChiLHKCFilter (optional) 
     * @param emailLHKCFilter (optional) 
     * @param dtDiDongLHKCFilter (optional) 
     * @param dtNhaRiengLHKCFilter (optional) 
     * @param quanHeLHKCFilter (optional) 
     * @param hoVaTenLHKCFilter (optional) 
     * @param diaChiHNFilter (optional) 
     * @param maxTinhThanhIDHNFilter (optional) 
     * @param minTinhThanhIDHNFilter (optional) 
     * @param quocGiaHNFilter (optional) 
     * @param laChuHoFilter (optional) 
     * @param maSoHoGiaDinhFilter (optional) 
     * @param soSoHoKhauFilter (optional) 
     * @param diaChiHKTTFilter (optional) 
     * @param maxTinhThanhIDHKTTFilter (optional) 
     * @param minTinhThanhIDHKTTFilter (optional) 
     * @param quocGiaHKTTFilter (optional) 
     * @param facebookFilter (optional) 
     * @param skypeFilter (optional) 
     * @param noiSinhFilter (optional) 
     * @param maxTinhThanhIDFilter (optional) 
     * @param minTinhThanhIDFilter (optional) 
     * @param nguyenQuanFilter (optional) 
     * @param emailKhacFilter (optional) 
     * @param emailCoQuanFilter (optional) 
     * @param emailCaNhanFilter (optional) 
     * @param dtKhacFilter (optional) 
     * @param dtNhaRiengFilter (optional) 
     * @param dtCoQuanFilter (optional) 
     * @param dtDiDongFilter (optional) 
     * @param tepDinhKemFilter (optional) 
     * @param tinhTrangHonNhanCodeFilter (optional) 
     * @param xepLoaiCodeFilter (optional) 
     * @param maxNamTotNghiepFilter (optional) 
     * @param minNamTotNghiepFilter (optional) 
     * @param chuyenNganhFilter (optional) 
     * @param khoaFilter (optional) 
     * @param trinhDoDaoTaoCodeFilter (optional) 
     * @param trinhDoVanHoaFilter (optional) 
     * @param maxNgayHetHanFilter (optional) 
     * @param minNgayHetHanFilter (optional) 
     * @param noiCapFilter (optional) 
     * @param maxNgayCapFilter (optional) 
     * @param minNgayCapFilter (optional) 
     * @param soCMNDFilter (optional) 
     * @param quocTichFilter (optional) 
     * @param tonGiaoFilter (optional) 
     * @param danTocFilter (optional) 
     * @param viTriCongViecCodeFilter (optional) 
     * @param maxDonViCongTacIDFilter (optional) 
     * @param minDonViCongTacIDFilter (optional) 
     * @param mSTCaNhanFilter (optional) 
     * @param maxNgaySinhFilter (optional) 
     * @param minNgaySinhFilter (optional) 
     * @param gioiTinhCodeFilter (optional) 
     * @param anhDaiDienFilter (optional) 
     * @param hoVaTenFilter (optional) 
     * @param maNhanVienFilter (optional) 
     * @param chiNhanhFilter (optional) 
     * @param dVTFilter (optional) 
     * @param maxNgayKyHDKTHFilter (optional) 
     * @param minNgayKyHDKTHFilter (optional) 
     * @param maxNgayKyHD36THFilter (optional) 
     * @param minNgayKyHD36THFilter (optional) 
     * @param maxNgayKyHD12THFilter (optional) 
     * @param minNgayKyHD12THFilter (optional) 
     * @param maxNgayKyHDTVFilter (optional) 
     * @param minNgayKyHDTVFilter (optional) 
     * @param maxNgayKYHDCTVFilter (optional) 
     * @param minNgayKYHDCTVFilter (optional) 
     * @param maxNgayKyHDKVFilter (optional) 
     * @param minNgayKyHDKVFilter (optional) 
     * @param maxNgayKYHDTTFilter (optional) 
     * @param minNgayKYHDTTFilter (optional) 
     * @param maxNgayKyHDFilter (optional) 
     * @param minNgayKyHDFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, tenCtyFilter: string | undefined, hopDongHienTaiFilter: string | undefined, soHDFilter: string | undefined, donViCongTacNameFilter: string | undefined, choNgoiFilter: string | undefined, maxNoiDaoTaoIDFilter: number | undefined, minNoiDaoTaoIDFilter: number | undefined, maxLoaiHopDongIDFilter: number | undefined, minLoaiHopDongIDFilter: number | undefined, maSoNoiKCBFilter: string | undefined, maxNoiDangKyKCBIDFilter: number | undefined, minNoiDangKyKCBIDFilter: number | undefined, maxNgayHetHanBHYTFilter: moment.Moment | undefined, minNgayHetHanBHYTFilter: moment.Moment | undefined, soTheBHYTFilter: string | undefined, maTinhCapFilter: string | undefined, maSoBHXHFilter: string | undefined, soSoBHXHFilter: string | undefined, maxTyLeDongBHFilter: number | undefined, minTyLeDongBHFilter: number | undefined, maxNgayThamGiaBHFilter: moment.Moment | undefined, minNgayThamGiaBHFilter: moment.Moment | undefined, thamGiaCongDoanFilter: number | undefined, nganHangCodeFilter: string | undefined, tkNganHangFilter: string | undefined, donViSoCongChuanCodeFilter: string | undefined, soCongChuanFilter: string | undefined, luongDongBHFilter: string | undefined, luongCoBanFilter: string | undefined, bacLuongCodeFilter: string | undefined, maxSoNgayPhepFilter: number | undefined, minSoNgayPhepFilter: number | undefined, maxNgayChinhThucFilter: moment.Moment | undefined, minNgayChinhThucFilter: moment.Moment | undefined, maxNgayThuViecFilter: moment.Moment | undefined, minNgayThuViecFilter: moment.Moment | undefined, maxNgayTapSuFilter: moment.Moment | undefined, minNgayTapSuFilter: moment.Moment | undefined, soSoQLLaoDongFilter: string | undefined, diaDiemLamViecCodeFilter: string | undefined, quanLyGianTiepFilter: string | undefined, quanLyTrucTiepFilter: string | undefined, trangThaiLamViecCodeFilter: string | undefined, bacFilter: string | undefined, capFilter: string | undefined, chucDanhFilter: string | undefined, maChamCongFilter: string | undefined, diaChiLHKCFilter: string | undefined, emailLHKCFilter: string | undefined, dtDiDongLHKCFilter: string | undefined, dtNhaRiengLHKCFilter: string | undefined, quanHeLHKCFilter: string | undefined, hoVaTenLHKCFilter: string | undefined, diaChiHNFilter: string | undefined, maxTinhThanhIDHNFilter: number | undefined, minTinhThanhIDHNFilter: number | undefined, quocGiaHNFilter: string | undefined, laChuHoFilter: number | undefined, maSoHoGiaDinhFilter: string | undefined, soSoHoKhauFilter: string | undefined, diaChiHKTTFilter: string | undefined, maxTinhThanhIDHKTTFilter: number | undefined, minTinhThanhIDHKTTFilter: number | undefined, quocGiaHKTTFilter: string | undefined, facebookFilter: string | undefined, skypeFilter: string | undefined, noiSinhFilter: string | undefined, maxTinhThanhIDFilter: number | undefined, minTinhThanhIDFilter: number | undefined, nguyenQuanFilter: string | undefined, emailKhacFilter: string | undefined, emailCoQuanFilter: string | undefined, emailCaNhanFilter: string | undefined, dtKhacFilter: string | undefined, dtNhaRiengFilter: string | undefined, dtCoQuanFilter: string | undefined, dtDiDongFilter: string | undefined, tepDinhKemFilter: string | undefined, tinhTrangHonNhanCodeFilter: string | undefined, xepLoaiCodeFilter: string | undefined, maxNamTotNghiepFilter: number | undefined, minNamTotNghiepFilter: number | undefined, chuyenNganhFilter: string | undefined, khoaFilter: string | undefined, trinhDoDaoTaoCodeFilter: string | undefined, trinhDoVanHoaFilter: string | undefined, maxNgayHetHanFilter: moment.Moment | undefined, minNgayHetHanFilter: moment.Moment | undefined, noiCapFilter: string | undefined, maxNgayCapFilter: moment.Moment | undefined, minNgayCapFilter: moment.Moment | undefined, soCMNDFilter: string | undefined, quocTichFilter: string | undefined, tonGiaoFilter: string | undefined, danTocFilter: string | undefined, viTriCongViecCodeFilter: string | undefined, maxDonViCongTacIDFilter: number | undefined, minDonViCongTacIDFilter: number | undefined, mSTCaNhanFilter: string | undefined, maxNgaySinhFilter: moment.Moment | undefined, minNgaySinhFilter: moment.Moment | undefined, gioiTinhCodeFilter: string | undefined, anhDaiDienFilter: string | undefined, hoVaTenFilter: string | undefined, maNhanVienFilter: string | undefined, chiNhanhFilter: string | undefined, dVTFilter: string | undefined, maxNgayKyHDKTHFilter: moment.Moment | undefined, minNgayKyHDKTHFilter: moment.Moment | undefined, maxNgayKyHD36THFilter: moment.Moment | undefined, minNgayKyHD36THFilter: moment.Moment | undefined, maxNgayKyHD12THFilter: moment.Moment | undefined, minNgayKyHD12THFilter: moment.Moment | undefined, maxNgayKyHDTVFilter: moment.Moment | undefined, minNgayKyHDTVFilter: moment.Moment | undefined, maxNgayKYHDCTVFilter: moment.Moment | undefined, minNgayKYHDCTVFilter: moment.Moment | undefined, maxNgayKyHDKVFilter: moment.Moment | undefined, minNgayKyHDKVFilter: moment.Moment | undefined, maxNgayKYHDTTFilter: moment.Moment | undefined, minNgayKYHDTTFilter: moment.Moment | undefined, maxNgayKyHDFilter: moment.Moment | undefined, minNgayKyHDFilter: moment.Moment | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetViTriCongViecForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ViTriCongViecs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenCtyFilter === null)
            throw new Error("The parameter 'tenCtyFilter' cannot be null.");
        else if (tenCtyFilter !== undefined)
            url_ += "TenCtyFilter=" + encodeURIComponent("" + tenCtyFilter) + "&"; 
        if (hopDongHienTaiFilter === null)
            throw new Error("The parameter 'hopDongHienTaiFilter' cannot be null.");
        else if (hopDongHienTaiFilter !== undefined)
            url_ += "HopDongHienTaiFilter=" + encodeURIComponent("" + hopDongHienTaiFilter) + "&"; 
        if (soHDFilter === null)
            throw new Error("The parameter 'soHDFilter' cannot be null.");
        else if (soHDFilter !== undefined)
            url_ += "SoHDFilter=" + encodeURIComponent("" + soHDFilter) + "&"; 
        if (donViCongTacNameFilter === null)
            throw new Error("The parameter 'donViCongTacNameFilter' cannot be null.");
        else if (donViCongTacNameFilter !== undefined)
            url_ += "DonViCongTacNameFilter=" + encodeURIComponent("" + donViCongTacNameFilter) + "&"; 
        if (choNgoiFilter === null)
            throw new Error("The parameter 'choNgoiFilter' cannot be null.");
        else if (choNgoiFilter !== undefined)
            url_ += "ChoNgoiFilter=" + encodeURIComponent("" + choNgoiFilter) + "&"; 
        if (maxNoiDaoTaoIDFilter === null)
            throw new Error("The parameter 'maxNoiDaoTaoIDFilter' cannot be null.");
        else if (maxNoiDaoTaoIDFilter !== undefined)
            url_ += "MaxNoiDaoTaoIDFilter=" + encodeURIComponent("" + maxNoiDaoTaoIDFilter) + "&"; 
        if (minNoiDaoTaoIDFilter === null)
            throw new Error("The parameter 'minNoiDaoTaoIDFilter' cannot be null.");
        else if (minNoiDaoTaoIDFilter !== undefined)
            url_ += "MinNoiDaoTaoIDFilter=" + encodeURIComponent("" + minNoiDaoTaoIDFilter) + "&"; 
        if (maxLoaiHopDongIDFilter === null)
            throw new Error("The parameter 'maxLoaiHopDongIDFilter' cannot be null.");
        else if (maxLoaiHopDongIDFilter !== undefined)
            url_ += "MaxLoaiHopDongIDFilter=" + encodeURIComponent("" + maxLoaiHopDongIDFilter) + "&"; 
        if (minLoaiHopDongIDFilter === null)
            throw new Error("The parameter 'minLoaiHopDongIDFilter' cannot be null.");
        else if (minLoaiHopDongIDFilter !== undefined)
            url_ += "MinLoaiHopDongIDFilter=" + encodeURIComponent("" + minLoaiHopDongIDFilter) + "&"; 
        if (maSoNoiKCBFilter === null)
            throw new Error("The parameter 'maSoNoiKCBFilter' cannot be null.");
        else if (maSoNoiKCBFilter !== undefined)
            url_ += "MaSoNoiKCBFilter=" + encodeURIComponent("" + maSoNoiKCBFilter) + "&"; 
        if (maxNoiDangKyKCBIDFilter === null)
            throw new Error("The parameter 'maxNoiDangKyKCBIDFilter' cannot be null.");
        else if (maxNoiDangKyKCBIDFilter !== undefined)
            url_ += "MaxNoiDangKyKCBIDFilter=" + encodeURIComponent("" + maxNoiDangKyKCBIDFilter) + "&"; 
        if (minNoiDangKyKCBIDFilter === null)
            throw new Error("The parameter 'minNoiDangKyKCBIDFilter' cannot be null.");
        else if (minNoiDangKyKCBIDFilter !== undefined)
            url_ += "MinNoiDangKyKCBIDFilter=" + encodeURIComponent("" + minNoiDangKyKCBIDFilter) + "&"; 
        if (maxNgayHetHanBHYTFilter === null)
            throw new Error("The parameter 'maxNgayHetHanBHYTFilter' cannot be null.");
        else if (maxNgayHetHanBHYTFilter !== undefined)
            url_ += "MaxNgayHetHanBHYTFilter=" + encodeURIComponent(maxNgayHetHanBHYTFilter ? "" + maxNgayHetHanBHYTFilter.toJSON() : "") + "&"; 
        if (minNgayHetHanBHYTFilter === null)
            throw new Error("The parameter 'minNgayHetHanBHYTFilter' cannot be null.");
        else if (minNgayHetHanBHYTFilter !== undefined)
            url_ += "MinNgayHetHanBHYTFilter=" + encodeURIComponent(minNgayHetHanBHYTFilter ? "" + minNgayHetHanBHYTFilter.toJSON() : "") + "&"; 
        if (soTheBHYTFilter === null)
            throw new Error("The parameter 'soTheBHYTFilter' cannot be null.");
        else if (soTheBHYTFilter !== undefined)
            url_ += "SoTheBHYTFilter=" + encodeURIComponent("" + soTheBHYTFilter) + "&"; 
        if (maTinhCapFilter === null)
            throw new Error("The parameter 'maTinhCapFilter' cannot be null.");
        else if (maTinhCapFilter !== undefined)
            url_ += "MaTinhCapFilter=" + encodeURIComponent("" + maTinhCapFilter) + "&"; 
        if (maSoBHXHFilter === null)
            throw new Error("The parameter 'maSoBHXHFilter' cannot be null.");
        else if (maSoBHXHFilter !== undefined)
            url_ += "MaSoBHXHFilter=" + encodeURIComponent("" + maSoBHXHFilter) + "&"; 
        if (soSoBHXHFilter === null)
            throw new Error("The parameter 'soSoBHXHFilter' cannot be null.");
        else if (soSoBHXHFilter !== undefined)
            url_ += "SoSoBHXHFilter=" + encodeURIComponent("" + soSoBHXHFilter) + "&"; 
        if (maxTyLeDongBHFilter === null)
            throw new Error("The parameter 'maxTyLeDongBHFilter' cannot be null.");
        else if (maxTyLeDongBHFilter !== undefined)
            url_ += "MaxTyLeDongBHFilter=" + encodeURIComponent("" + maxTyLeDongBHFilter) + "&"; 
        if (minTyLeDongBHFilter === null)
            throw new Error("The parameter 'minTyLeDongBHFilter' cannot be null.");
        else if (minTyLeDongBHFilter !== undefined)
            url_ += "MinTyLeDongBHFilter=" + encodeURIComponent("" + minTyLeDongBHFilter) + "&"; 
        if (maxNgayThamGiaBHFilter === null)
            throw new Error("The parameter 'maxNgayThamGiaBHFilter' cannot be null.");
        else if (maxNgayThamGiaBHFilter !== undefined)
            url_ += "MaxNgayThamGiaBHFilter=" + encodeURIComponent(maxNgayThamGiaBHFilter ? "" + maxNgayThamGiaBHFilter.toJSON() : "") + "&"; 
        if (minNgayThamGiaBHFilter === null)
            throw new Error("The parameter 'minNgayThamGiaBHFilter' cannot be null.");
        else if (minNgayThamGiaBHFilter !== undefined)
            url_ += "MinNgayThamGiaBHFilter=" + encodeURIComponent(minNgayThamGiaBHFilter ? "" + minNgayThamGiaBHFilter.toJSON() : "") + "&"; 
        if (thamGiaCongDoanFilter === null)
            throw new Error("The parameter 'thamGiaCongDoanFilter' cannot be null.");
        else if (thamGiaCongDoanFilter !== undefined)
            url_ += "ThamGiaCongDoanFilter=" + encodeURIComponent("" + thamGiaCongDoanFilter) + "&"; 
        if (nganHangCodeFilter === null)
            throw new Error("The parameter 'nganHangCodeFilter' cannot be null.");
        else if (nganHangCodeFilter !== undefined)
            url_ += "NganHangCodeFilter=" + encodeURIComponent("" + nganHangCodeFilter) + "&"; 
        if (tkNganHangFilter === null)
            throw new Error("The parameter 'tkNganHangFilter' cannot be null.");
        else if (tkNganHangFilter !== undefined)
            url_ += "TkNganHangFilter=" + encodeURIComponent("" + tkNganHangFilter) + "&"; 
        if (donViSoCongChuanCodeFilter === null)
            throw new Error("The parameter 'donViSoCongChuanCodeFilter' cannot be null.");
        else if (donViSoCongChuanCodeFilter !== undefined)
            url_ += "DonViSoCongChuanCodeFilter=" + encodeURIComponent("" + donViSoCongChuanCodeFilter) + "&"; 
        if (soCongChuanFilter === null)
            throw new Error("The parameter 'soCongChuanFilter' cannot be null.");
        else if (soCongChuanFilter !== undefined)
            url_ += "SoCongChuanFilter=" + encodeURIComponent("" + soCongChuanFilter) + "&"; 
        if (luongDongBHFilter === null)
            throw new Error("The parameter 'luongDongBHFilter' cannot be null.");
        else if (luongDongBHFilter !== undefined)
            url_ += "LuongDongBHFilter=" + encodeURIComponent("" + luongDongBHFilter) + "&"; 
        if (luongCoBanFilter === null)
            throw new Error("The parameter 'luongCoBanFilter' cannot be null.");
        else if (luongCoBanFilter !== undefined)
            url_ += "LuongCoBanFilter=" + encodeURIComponent("" + luongCoBanFilter) + "&"; 
        if (bacLuongCodeFilter === null)
            throw new Error("The parameter 'bacLuongCodeFilter' cannot be null.");
        else if (bacLuongCodeFilter !== undefined)
            url_ += "BacLuongCodeFilter=" + encodeURIComponent("" + bacLuongCodeFilter) + "&"; 
        if (maxSoNgayPhepFilter === null)
            throw new Error("The parameter 'maxSoNgayPhepFilter' cannot be null.");
        else if (maxSoNgayPhepFilter !== undefined)
            url_ += "MaxSoNgayPhepFilter=" + encodeURIComponent("" + maxSoNgayPhepFilter) + "&"; 
        if (minSoNgayPhepFilter === null)
            throw new Error("The parameter 'minSoNgayPhepFilter' cannot be null.");
        else if (minSoNgayPhepFilter !== undefined)
            url_ += "MinSoNgayPhepFilter=" + encodeURIComponent("" + minSoNgayPhepFilter) + "&"; 
        if (maxNgayChinhThucFilter === null)
            throw new Error("The parameter 'maxNgayChinhThucFilter' cannot be null.");
        else if (maxNgayChinhThucFilter !== undefined)
            url_ += "MaxNgayChinhThucFilter=" + encodeURIComponent(maxNgayChinhThucFilter ? "" + maxNgayChinhThucFilter.toJSON() : "") + "&"; 
        if (minNgayChinhThucFilter === null)
            throw new Error("The parameter 'minNgayChinhThucFilter' cannot be null.");
        else if (minNgayChinhThucFilter !== undefined)
            url_ += "MinNgayChinhThucFilter=" + encodeURIComponent(minNgayChinhThucFilter ? "" + minNgayChinhThucFilter.toJSON() : "") + "&"; 
        if (maxNgayThuViecFilter === null)
            throw new Error("The parameter 'maxNgayThuViecFilter' cannot be null.");
        else if (maxNgayThuViecFilter !== undefined)
            url_ += "MaxNgayThuViecFilter=" + encodeURIComponent(maxNgayThuViecFilter ? "" + maxNgayThuViecFilter.toJSON() : "") + "&"; 
        if (minNgayThuViecFilter === null)
            throw new Error("The parameter 'minNgayThuViecFilter' cannot be null.");
        else if (minNgayThuViecFilter !== undefined)
            url_ += "MinNgayThuViecFilter=" + encodeURIComponent(minNgayThuViecFilter ? "" + minNgayThuViecFilter.toJSON() : "") + "&"; 
        if (maxNgayTapSuFilter === null)
            throw new Error("The parameter 'maxNgayTapSuFilter' cannot be null.");
        else if (maxNgayTapSuFilter !== undefined)
            url_ += "MaxNgayTapSuFilter=" + encodeURIComponent(maxNgayTapSuFilter ? "" + maxNgayTapSuFilter.toJSON() : "") + "&"; 
        if (minNgayTapSuFilter === null)
            throw new Error("The parameter 'minNgayTapSuFilter' cannot be null.");
        else if (minNgayTapSuFilter !== undefined)
            url_ += "MinNgayTapSuFilter=" + encodeURIComponent(minNgayTapSuFilter ? "" + minNgayTapSuFilter.toJSON() : "") + "&"; 
        if (soSoQLLaoDongFilter === null)
            throw new Error("The parameter 'soSoQLLaoDongFilter' cannot be null.");
        else if (soSoQLLaoDongFilter !== undefined)
            url_ += "SoSoQLLaoDongFilter=" + encodeURIComponent("" + soSoQLLaoDongFilter) + "&"; 
        if (diaDiemLamViecCodeFilter === null)
            throw new Error("The parameter 'diaDiemLamViecCodeFilter' cannot be null.");
        else if (diaDiemLamViecCodeFilter !== undefined)
            url_ += "DiaDiemLamViecCodeFilter=" + encodeURIComponent("" + diaDiemLamViecCodeFilter) + "&"; 
        if (quanLyGianTiepFilter === null)
            throw new Error("The parameter 'quanLyGianTiepFilter' cannot be null.");
        else if (quanLyGianTiepFilter !== undefined)
            url_ += "QuanLyGianTiepFilter=" + encodeURIComponent("" + quanLyGianTiepFilter) + "&"; 
        if (quanLyTrucTiepFilter === null)
            throw new Error("The parameter 'quanLyTrucTiepFilter' cannot be null.");
        else if (quanLyTrucTiepFilter !== undefined)
            url_ += "QuanLyTrucTiepFilter=" + encodeURIComponent("" + quanLyTrucTiepFilter) + "&"; 
        if (trangThaiLamViecCodeFilter === null)
            throw new Error("The parameter 'trangThaiLamViecCodeFilter' cannot be null.");
        else if (trangThaiLamViecCodeFilter !== undefined)
            url_ += "TrangThaiLamViecCodeFilter=" + encodeURIComponent("" + trangThaiLamViecCodeFilter) + "&"; 
        if (bacFilter === null)
            throw new Error("The parameter 'bacFilter' cannot be null.");
        else if (bacFilter !== undefined)
            url_ += "BacFilter=" + encodeURIComponent("" + bacFilter) + "&"; 
        if (capFilter === null)
            throw new Error("The parameter 'capFilter' cannot be null.");
        else if (capFilter !== undefined)
            url_ += "CapFilter=" + encodeURIComponent("" + capFilter) + "&"; 
        if (chucDanhFilter === null)
            throw new Error("The parameter 'chucDanhFilter' cannot be null.");
        else if (chucDanhFilter !== undefined)
            url_ += "ChucDanhFilter=" + encodeURIComponent("" + chucDanhFilter) + "&"; 
        if (maChamCongFilter === null)
            throw new Error("The parameter 'maChamCongFilter' cannot be null.");
        else if (maChamCongFilter !== undefined)
            url_ += "MaChamCongFilter=" + encodeURIComponent("" + maChamCongFilter) + "&"; 
        if (diaChiLHKCFilter === null)
            throw new Error("The parameter 'diaChiLHKCFilter' cannot be null.");
        else if (diaChiLHKCFilter !== undefined)
            url_ += "DiaChiLHKCFilter=" + encodeURIComponent("" + diaChiLHKCFilter) + "&"; 
        if (emailLHKCFilter === null)
            throw new Error("The parameter 'emailLHKCFilter' cannot be null.");
        else if (emailLHKCFilter !== undefined)
            url_ += "EmailLHKCFilter=" + encodeURIComponent("" + emailLHKCFilter) + "&"; 
        if (dtDiDongLHKCFilter === null)
            throw new Error("The parameter 'dtDiDongLHKCFilter' cannot be null.");
        else if (dtDiDongLHKCFilter !== undefined)
            url_ += "DtDiDongLHKCFilter=" + encodeURIComponent("" + dtDiDongLHKCFilter) + "&"; 
        if (dtNhaRiengLHKCFilter === null)
            throw new Error("The parameter 'dtNhaRiengLHKCFilter' cannot be null.");
        else if (dtNhaRiengLHKCFilter !== undefined)
            url_ += "DtNhaRiengLHKCFilter=" + encodeURIComponent("" + dtNhaRiengLHKCFilter) + "&"; 
        if (quanHeLHKCFilter === null)
            throw new Error("The parameter 'quanHeLHKCFilter' cannot be null.");
        else if (quanHeLHKCFilter !== undefined)
            url_ += "QuanHeLHKCFilter=" + encodeURIComponent("" + quanHeLHKCFilter) + "&"; 
        if (hoVaTenLHKCFilter === null)
            throw new Error("The parameter 'hoVaTenLHKCFilter' cannot be null.");
        else if (hoVaTenLHKCFilter !== undefined)
            url_ += "HoVaTenLHKCFilter=" + encodeURIComponent("" + hoVaTenLHKCFilter) + "&"; 
        if (diaChiHNFilter === null)
            throw new Error("The parameter 'diaChiHNFilter' cannot be null.");
        else if (diaChiHNFilter !== undefined)
            url_ += "DiaChiHNFilter=" + encodeURIComponent("" + diaChiHNFilter) + "&"; 
        if (maxTinhThanhIDHNFilter === null)
            throw new Error("The parameter 'maxTinhThanhIDHNFilter' cannot be null.");
        else if (maxTinhThanhIDHNFilter !== undefined)
            url_ += "MaxTinhThanhIDHNFilter=" + encodeURIComponent("" + maxTinhThanhIDHNFilter) + "&"; 
        if (minTinhThanhIDHNFilter === null)
            throw new Error("The parameter 'minTinhThanhIDHNFilter' cannot be null.");
        else if (minTinhThanhIDHNFilter !== undefined)
            url_ += "MinTinhThanhIDHNFilter=" + encodeURIComponent("" + minTinhThanhIDHNFilter) + "&"; 
        if (quocGiaHNFilter === null)
            throw new Error("The parameter 'quocGiaHNFilter' cannot be null.");
        else if (quocGiaHNFilter !== undefined)
            url_ += "QuocGiaHNFilter=" + encodeURIComponent("" + quocGiaHNFilter) + "&"; 
        if (laChuHoFilter === null)
            throw new Error("The parameter 'laChuHoFilter' cannot be null.");
        else if (laChuHoFilter !== undefined)
            url_ += "LaChuHoFilter=" + encodeURIComponent("" + laChuHoFilter) + "&"; 
        if (maSoHoGiaDinhFilter === null)
            throw new Error("The parameter 'maSoHoGiaDinhFilter' cannot be null.");
        else if (maSoHoGiaDinhFilter !== undefined)
            url_ += "MaSoHoGiaDinhFilter=" + encodeURIComponent("" + maSoHoGiaDinhFilter) + "&"; 
        if (soSoHoKhauFilter === null)
            throw new Error("The parameter 'soSoHoKhauFilter' cannot be null.");
        else if (soSoHoKhauFilter !== undefined)
            url_ += "SoSoHoKhauFilter=" + encodeURIComponent("" + soSoHoKhauFilter) + "&"; 
        if (diaChiHKTTFilter === null)
            throw new Error("The parameter 'diaChiHKTTFilter' cannot be null.");
        else if (diaChiHKTTFilter !== undefined)
            url_ += "DiaChiHKTTFilter=" + encodeURIComponent("" + diaChiHKTTFilter) + "&"; 
        if (maxTinhThanhIDHKTTFilter === null)
            throw new Error("The parameter 'maxTinhThanhIDHKTTFilter' cannot be null.");
        else if (maxTinhThanhIDHKTTFilter !== undefined)
            url_ += "MaxTinhThanhIDHKTTFilter=" + encodeURIComponent("" + maxTinhThanhIDHKTTFilter) + "&"; 
        if (minTinhThanhIDHKTTFilter === null)
            throw new Error("The parameter 'minTinhThanhIDHKTTFilter' cannot be null.");
        else if (minTinhThanhIDHKTTFilter !== undefined)
            url_ += "MinTinhThanhIDHKTTFilter=" + encodeURIComponent("" + minTinhThanhIDHKTTFilter) + "&"; 
        if (quocGiaHKTTFilter === null)
            throw new Error("The parameter 'quocGiaHKTTFilter' cannot be null.");
        else if (quocGiaHKTTFilter !== undefined)
            url_ += "QuocGiaHKTTFilter=" + encodeURIComponent("" + quocGiaHKTTFilter) + "&"; 
        if (facebookFilter === null)
            throw new Error("The parameter 'facebookFilter' cannot be null.");
        else if (facebookFilter !== undefined)
            url_ += "FacebookFilter=" + encodeURIComponent("" + facebookFilter) + "&"; 
        if (skypeFilter === null)
            throw new Error("The parameter 'skypeFilter' cannot be null.");
        else if (skypeFilter !== undefined)
            url_ += "SkypeFilter=" + encodeURIComponent("" + skypeFilter) + "&"; 
        if (noiSinhFilter === null)
            throw new Error("The parameter 'noiSinhFilter' cannot be null.");
        else if (noiSinhFilter !== undefined)
            url_ += "NoiSinhFilter=" + encodeURIComponent("" + noiSinhFilter) + "&"; 
        if (maxTinhThanhIDFilter === null)
            throw new Error("The parameter 'maxTinhThanhIDFilter' cannot be null.");
        else if (maxTinhThanhIDFilter !== undefined)
            url_ += "MaxTinhThanhIDFilter=" + encodeURIComponent("" + maxTinhThanhIDFilter) + "&"; 
        if (minTinhThanhIDFilter === null)
            throw new Error("The parameter 'minTinhThanhIDFilter' cannot be null.");
        else if (minTinhThanhIDFilter !== undefined)
            url_ += "MinTinhThanhIDFilter=" + encodeURIComponent("" + minTinhThanhIDFilter) + "&"; 
        if (nguyenQuanFilter === null)
            throw new Error("The parameter 'nguyenQuanFilter' cannot be null.");
        else if (nguyenQuanFilter !== undefined)
            url_ += "NguyenQuanFilter=" + encodeURIComponent("" + nguyenQuanFilter) + "&"; 
        if (emailKhacFilter === null)
            throw new Error("The parameter 'emailKhacFilter' cannot be null.");
        else if (emailKhacFilter !== undefined)
            url_ += "EmailKhacFilter=" + encodeURIComponent("" + emailKhacFilter) + "&"; 
        if (emailCoQuanFilter === null)
            throw new Error("The parameter 'emailCoQuanFilter' cannot be null.");
        else if (emailCoQuanFilter !== undefined)
            url_ += "EmailCoQuanFilter=" + encodeURIComponent("" + emailCoQuanFilter) + "&"; 
        if (emailCaNhanFilter === null)
            throw new Error("The parameter 'emailCaNhanFilter' cannot be null.");
        else if (emailCaNhanFilter !== undefined)
            url_ += "EmailCaNhanFilter=" + encodeURIComponent("" + emailCaNhanFilter) + "&"; 
        if (dtKhacFilter === null)
            throw new Error("The parameter 'dtKhacFilter' cannot be null.");
        else if (dtKhacFilter !== undefined)
            url_ += "DtKhacFilter=" + encodeURIComponent("" + dtKhacFilter) + "&"; 
        if (dtNhaRiengFilter === null)
            throw new Error("The parameter 'dtNhaRiengFilter' cannot be null.");
        else if (dtNhaRiengFilter !== undefined)
            url_ += "DtNhaRiengFilter=" + encodeURIComponent("" + dtNhaRiengFilter) + "&"; 
        if (dtCoQuanFilter === null)
            throw new Error("The parameter 'dtCoQuanFilter' cannot be null.");
        else if (dtCoQuanFilter !== undefined)
            url_ += "DtCoQuanFilter=" + encodeURIComponent("" + dtCoQuanFilter) + "&"; 
        if (dtDiDongFilter === null)
            throw new Error("The parameter 'dtDiDongFilter' cannot be null.");
        else if (dtDiDongFilter !== undefined)
            url_ += "DtDiDongFilter=" + encodeURIComponent("" + dtDiDongFilter) + "&"; 
        if (tepDinhKemFilter === null)
            throw new Error("The parameter 'tepDinhKemFilter' cannot be null.");
        else if (tepDinhKemFilter !== undefined)
            url_ += "TepDinhKemFilter=" + encodeURIComponent("" + tepDinhKemFilter) + "&"; 
        if (tinhTrangHonNhanCodeFilter === null)
            throw new Error("The parameter 'tinhTrangHonNhanCodeFilter' cannot be null.");
        else if (tinhTrangHonNhanCodeFilter !== undefined)
            url_ += "TinhTrangHonNhanCodeFilter=" + encodeURIComponent("" + tinhTrangHonNhanCodeFilter) + "&"; 
        if (xepLoaiCodeFilter === null)
            throw new Error("The parameter 'xepLoaiCodeFilter' cannot be null.");
        else if (xepLoaiCodeFilter !== undefined)
            url_ += "XepLoaiCodeFilter=" + encodeURIComponent("" + xepLoaiCodeFilter) + "&"; 
        if (maxNamTotNghiepFilter === null)
            throw new Error("The parameter 'maxNamTotNghiepFilter' cannot be null.");
        else if (maxNamTotNghiepFilter !== undefined)
            url_ += "MaxNamTotNghiepFilter=" + encodeURIComponent("" + maxNamTotNghiepFilter) + "&"; 
        if (minNamTotNghiepFilter === null)
            throw new Error("The parameter 'minNamTotNghiepFilter' cannot be null.");
        else if (minNamTotNghiepFilter !== undefined)
            url_ += "MinNamTotNghiepFilter=" + encodeURIComponent("" + minNamTotNghiepFilter) + "&"; 
        if (chuyenNganhFilter === null)
            throw new Error("The parameter 'chuyenNganhFilter' cannot be null.");
        else if (chuyenNganhFilter !== undefined)
            url_ += "ChuyenNganhFilter=" + encodeURIComponent("" + chuyenNganhFilter) + "&"; 
        if (khoaFilter === null)
            throw new Error("The parameter 'khoaFilter' cannot be null.");
        else if (khoaFilter !== undefined)
            url_ += "KhoaFilter=" + encodeURIComponent("" + khoaFilter) + "&"; 
        if (trinhDoDaoTaoCodeFilter === null)
            throw new Error("The parameter 'trinhDoDaoTaoCodeFilter' cannot be null.");
        else if (trinhDoDaoTaoCodeFilter !== undefined)
            url_ += "TrinhDoDaoTaoCodeFilter=" + encodeURIComponent("" + trinhDoDaoTaoCodeFilter) + "&"; 
        if (trinhDoVanHoaFilter === null)
            throw new Error("The parameter 'trinhDoVanHoaFilter' cannot be null.");
        else if (trinhDoVanHoaFilter !== undefined)
            url_ += "TrinhDoVanHoaFilter=" + encodeURIComponent("" + trinhDoVanHoaFilter) + "&"; 
        if (maxNgayHetHanFilter === null)
            throw new Error("The parameter 'maxNgayHetHanFilter' cannot be null.");
        else if (maxNgayHetHanFilter !== undefined)
            url_ += "MaxNgayHetHanFilter=" + encodeURIComponent(maxNgayHetHanFilter ? "" + maxNgayHetHanFilter.toJSON() : "") + "&"; 
        if (minNgayHetHanFilter === null)
            throw new Error("The parameter 'minNgayHetHanFilter' cannot be null.");
        else if (minNgayHetHanFilter !== undefined)
            url_ += "MinNgayHetHanFilter=" + encodeURIComponent(minNgayHetHanFilter ? "" + minNgayHetHanFilter.toJSON() : "") + "&"; 
        if (noiCapFilter === null)
            throw new Error("The parameter 'noiCapFilter' cannot be null.");
        else if (noiCapFilter !== undefined)
            url_ += "NoiCapFilter=" + encodeURIComponent("" + noiCapFilter) + "&"; 
        if (maxNgayCapFilter === null)
            throw new Error("The parameter 'maxNgayCapFilter' cannot be null.");
        else if (maxNgayCapFilter !== undefined)
            url_ += "MaxNgayCapFilter=" + encodeURIComponent(maxNgayCapFilter ? "" + maxNgayCapFilter.toJSON() : "") + "&"; 
        if (minNgayCapFilter === null)
            throw new Error("The parameter 'minNgayCapFilter' cannot be null.");
        else if (minNgayCapFilter !== undefined)
            url_ += "MinNgayCapFilter=" + encodeURIComponent(minNgayCapFilter ? "" + minNgayCapFilter.toJSON() : "") + "&"; 
        if (soCMNDFilter === null)
            throw new Error("The parameter 'soCMNDFilter' cannot be null.");
        else if (soCMNDFilter !== undefined)
            url_ += "SoCMNDFilter=" + encodeURIComponent("" + soCMNDFilter) + "&"; 
        if (quocTichFilter === null)
            throw new Error("The parameter 'quocTichFilter' cannot be null.");
        else if (quocTichFilter !== undefined)
            url_ += "QuocTichFilter=" + encodeURIComponent("" + quocTichFilter) + "&"; 
        if (tonGiaoFilter === null)
            throw new Error("The parameter 'tonGiaoFilter' cannot be null.");
        else if (tonGiaoFilter !== undefined)
            url_ += "TonGiaoFilter=" + encodeURIComponent("" + tonGiaoFilter) + "&"; 
        if (danTocFilter === null)
            throw new Error("The parameter 'danTocFilter' cannot be null.");
        else if (danTocFilter !== undefined)
            url_ += "DanTocFilter=" + encodeURIComponent("" + danTocFilter) + "&"; 
        if (viTriCongViecCodeFilter === null)
            throw new Error("The parameter 'viTriCongViecCodeFilter' cannot be null.");
        else if (viTriCongViecCodeFilter !== undefined)
            url_ += "ViTriCongViecCodeFilter=" + encodeURIComponent("" + viTriCongViecCodeFilter) + "&"; 
        if (maxDonViCongTacIDFilter === null)
            throw new Error("The parameter 'maxDonViCongTacIDFilter' cannot be null.");
        else if (maxDonViCongTacIDFilter !== undefined)
            url_ += "MaxDonViCongTacIDFilter=" + encodeURIComponent("" + maxDonViCongTacIDFilter) + "&"; 
        if (minDonViCongTacIDFilter === null)
            throw new Error("The parameter 'minDonViCongTacIDFilter' cannot be null.");
        else if (minDonViCongTacIDFilter !== undefined)
            url_ += "MinDonViCongTacIDFilter=" + encodeURIComponent("" + minDonViCongTacIDFilter) + "&"; 
        if (mSTCaNhanFilter === null)
            throw new Error("The parameter 'mSTCaNhanFilter' cannot be null.");
        else if (mSTCaNhanFilter !== undefined)
            url_ += "MSTCaNhanFilter=" + encodeURIComponent("" + mSTCaNhanFilter) + "&"; 
        if (maxNgaySinhFilter === null)
            throw new Error("The parameter 'maxNgaySinhFilter' cannot be null.");
        else if (maxNgaySinhFilter !== undefined)
            url_ += "MaxNgaySinhFilter=" + encodeURIComponent(maxNgaySinhFilter ? "" + maxNgaySinhFilter.toJSON() : "") + "&"; 
        if (minNgaySinhFilter === null)
            throw new Error("The parameter 'minNgaySinhFilter' cannot be null.");
        else if (minNgaySinhFilter !== undefined)
            url_ += "MinNgaySinhFilter=" + encodeURIComponent(minNgaySinhFilter ? "" + minNgaySinhFilter.toJSON() : "") + "&"; 
        if (gioiTinhCodeFilter === null)
            throw new Error("The parameter 'gioiTinhCodeFilter' cannot be null.");
        else if (gioiTinhCodeFilter !== undefined)
            url_ += "GioiTinhCodeFilter=" + encodeURIComponent("" + gioiTinhCodeFilter) + "&"; 
        if (anhDaiDienFilter === null)
            throw new Error("The parameter 'anhDaiDienFilter' cannot be null.");
        else if (anhDaiDienFilter !== undefined)
            url_ += "AnhDaiDienFilter=" + encodeURIComponent("" + anhDaiDienFilter) + "&"; 
        if (hoVaTenFilter === null)
            throw new Error("The parameter 'hoVaTenFilter' cannot be null.");
        else if (hoVaTenFilter !== undefined)
            url_ += "HoVaTenFilter=" + encodeURIComponent("" + hoVaTenFilter) + "&"; 
        if (maNhanVienFilter === null)
            throw new Error("The parameter 'maNhanVienFilter' cannot be null.");
        else if (maNhanVienFilter !== undefined)
            url_ += "MaNhanVienFilter=" + encodeURIComponent("" + maNhanVienFilter) + "&"; 
        if (chiNhanhFilter === null)
            throw new Error("The parameter 'chiNhanhFilter' cannot be null.");
        else if (chiNhanhFilter !== undefined)
            url_ += "ChiNhanhFilter=" + encodeURIComponent("" + chiNhanhFilter) + "&"; 
        if (dVTFilter === null)
            throw new Error("The parameter 'dVTFilter' cannot be null.");
        else if (dVTFilter !== undefined)
            url_ += "DVTFilter=" + encodeURIComponent("" + dVTFilter) + "&"; 
        if (maxNgayKyHDKTHFilter === null)
            throw new Error("The parameter 'maxNgayKyHDKTHFilter' cannot be null.");
        else if (maxNgayKyHDKTHFilter !== undefined)
            url_ += "MaxNgayKyHDKTHFilter=" + encodeURIComponent(maxNgayKyHDKTHFilter ? "" + maxNgayKyHDKTHFilter.toJSON() : "") + "&"; 
        if (minNgayKyHDKTHFilter === null)
            throw new Error("The parameter 'minNgayKyHDKTHFilter' cannot be null.");
        else if (minNgayKyHDKTHFilter !== undefined)
            url_ += "MinNgayKyHDKTHFilter=" + encodeURIComponent(minNgayKyHDKTHFilter ? "" + minNgayKyHDKTHFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHD36THFilter === null)
            throw new Error("The parameter 'maxNgayKyHD36THFilter' cannot be null.");
        else if (maxNgayKyHD36THFilter !== undefined)
            url_ += "MaxNgayKyHD36THFilter=" + encodeURIComponent(maxNgayKyHD36THFilter ? "" + maxNgayKyHD36THFilter.toJSON() : "") + "&"; 
        if (minNgayKyHD36THFilter === null)
            throw new Error("The parameter 'minNgayKyHD36THFilter' cannot be null.");
        else if (minNgayKyHD36THFilter !== undefined)
            url_ += "MinNgayKyHD36THFilter=" + encodeURIComponent(minNgayKyHD36THFilter ? "" + minNgayKyHD36THFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHD12THFilter === null)
            throw new Error("The parameter 'maxNgayKyHD12THFilter' cannot be null.");
        else if (maxNgayKyHD12THFilter !== undefined)
            url_ += "MaxNgayKyHD12THFilter=" + encodeURIComponent(maxNgayKyHD12THFilter ? "" + maxNgayKyHD12THFilter.toJSON() : "") + "&"; 
        if (minNgayKyHD12THFilter === null)
            throw new Error("The parameter 'minNgayKyHD12THFilter' cannot be null.");
        else if (minNgayKyHD12THFilter !== undefined)
            url_ += "MinNgayKyHD12THFilter=" + encodeURIComponent(minNgayKyHD12THFilter ? "" + minNgayKyHD12THFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHDTVFilter === null)
            throw new Error("The parameter 'maxNgayKyHDTVFilter' cannot be null.");
        else if (maxNgayKyHDTVFilter !== undefined)
            url_ += "MaxNgayKyHDTVFilter=" + encodeURIComponent(maxNgayKyHDTVFilter ? "" + maxNgayKyHDTVFilter.toJSON() : "") + "&"; 
        if (minNgayKyHDTVFilter === null)
            throw new Error("The parameter 'minNgayKyHDTVFilter' cannot be null.");
        else if (minNgayKyHDTVFilter !== undefined)
            url_ += "MinNgayKyHDTVFilter=" + encodeURIComponent(minNgayKyHDTVFilter ? "" + minNgayKyHDTVFilter.toJSON() : "") + "&"; 
        if (maxNgayKYHDCTVFilter === null)
            throw new Error("The parameter 'maxNgayKYHDCTVFilter' cannot be null.");
        else if (maxNgayKYHDCTVFilter !== undefined)
            url_ += "MaxNgayKYHDCTVFilter=" + encodeURIComponent(maxNgayKYHDCTVFilter ? "" + maxNgayKYHDCTVFilter.toJSON() : "") + "&"; 
        if (minNgayKYHDCTVFilter === null)
            throw new Error("The parameter 'minNgayKYHDCTVFilter' cannot be null.");
        else if (minNgayKYHDCTVFilter !== undefined)
            url_ += "MinNgayKYHDCTVFilter=" + encodeURIComponent(minNgayKYHDCTVFilter ? "" + minNgayKYHDCTVFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHDKVFilter === null)
            throw new Error("The parameter 'maxNgayKyHDKVFilter' cannot be null.");
        else if (maxNgayKyHDKVFilter !== undefined)
            url_ += "MaxNgayKyHDKVFilter=" + encodeURIComponent(maxNgayKyHDKVFilter ? "" + maxNgayKyHDKVFilter.toJSON() : "") + "&"; 
        if (minNgayKyHDKVFilter === null)
            throw new Error("The parameter 'minNgayKyHDKVFilter' cannot be null.");
        else if (minNgayKyHDKVFilter !== undefined)
            url_ += "MinNgayKyHDKVFilter=" + encodeURIComponent(minNgayKyHDKVFilter ? "" + minNgayKyHDKVFilter.toJSON() : "") + "&"; 
        if (maxNgayKYHDTTFilter === null)
            throw new Error("The parameter 'maxNgayKYHDTTFilter' cannot be null.");
        else if (maxNgayKYHDTTFilter !== undefined)
            url_ += "MaxNgayKYHDTTFilter=" + encodeURIComponent(maxNgayKYHDTTFilter ? "" + maxNgayKYHDTTFilter.toJSON() : "") + "&"; 
        if (minNgayKYHDTTFilter === null)
            throw new Error("The parameter 'minNgayKYHDTTFilter' cannot be null.");
        else if (minNgayKYHDTTFilter !== undefined)
            url_ += "MinNgayKYHDTTFilter=" + encodeURIComponent(minNgayKYHDTTFilter ? "" + minNgayKYHDTTFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHDFilter === null)
            throw new Error("The parameter 'maxNgayKyHDFilter' cannot be null.");
        else if (maxNgayKyHDFilter !== undefined)
            url_ += "MaxNgayKyHDFilter=" + encodeURIComponent(maxNgayKyHDFilter ? "" + maxNgayKyHDFilter.toJSON() : "") + "&"; 
        if (minNgayKyHDFilter === null)
            throw new Error("The parameter 'minNgayKyHDFilter' cannot be null.");
        else if (minNgayKyHDFilter !== undefined)
            url_ += "MinNgayKyHDFilter=" + encodeURIComponent(minNgayKyHDFilter ? "" + minNgayKyHDFilter.toJSON() : "") + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetViTriCongViecForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetViTriCongViecForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetViTriCongViecForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetViTriCongViecForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetViTriCongViecForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetViTriCongViecForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getViTriCongViecForView(id: number | undefined): Observable<GetViTriCongViecForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ViTriCongViecs/GetViTriCongViecForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViTriCongViecForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViTriCongViecForView(<any>response_);
                } catch (e) {
                    return <Observable<GetViTriCongViecForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetViTriCongViecForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetViTriCongViecForView(response: HttpResponseBase): Observable<GetViTriCongViecForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetViTriCongViecForViewDto.fromJS(resultData200) : new GetViTriCongViecForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetViTriCongViecForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getViTriCongViecForEdit(id: number | undefined): Observable<GetViTriCongViecForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ViTriCongViecs/GetViTriCongViecForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViTriCongViecForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViTriCongViecForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetViTriCongViecForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetViTriCongViecForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetViTriCongViecForEdit(response: HttpResponseBase): Observable<GetViTriCongViecForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetViTriCongViecForEditOutput.fromJS(resultData200) : new GetViTriCongViecForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetViTriCongViecForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditViTriCongViecDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ViTriCongViecs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ViTriCongViecs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tenCtyFilter (optional) 
     * @param hopDongHienTaiFilter (optional) 
     * @param soHDFilter (optional) 
     * @param donViCongTacNameFilter (optional) 
     * @param choNgoiFilter (optional) 
     * @param maxNoiDaoTaoIDFilter (optional) 
     * @param minNoiDaoTaoIDFilter (optional) 
     * @param maxLoaiHopDongIDFilter (optional) 
     * @param minLoaiHopDongIDFilter (optional) 
     * @param maSoNoiKCBFilter (optional) 
     * @param maxNoiDangKyKCBIDFilter (optional) 
     * @param minNoiDangKyKCBIDFilter (optional) 
     * @param maxNgayHetHanBHYTFilter (optional) 
     * @param minNgayHetHanBHYTFilter (optional) 
     * @param soTheBHYTFilter (optional) 
     * @param maTinhCapFilter (optional) 
     * @param maSoBHXHFilter (optional) 
     * @param soSoBHXHFilter (optional) 
     * @param maxTyLeDongBHFilter (optional) 
     * @param minTyLeDongBHFilter (optional) 
     * @param maxNgayThamGiaBHFilter (optional) 
     * @param minNgayThamGiaBHFilter (optional) 
     * @param thamGiaCongDoanFilter (optional) 
     * @param nganHangCodeFilter (optional) 
     * @param tkNganHangFilter (optional) 
     * @param donViSoCongChuanCodeFilter (optional) 
     * @param soCongChuanFilter (optional) 
     * @param luongDongBHFilter (optional) 
     * @param luongCoBanFilter (optional) 
     * @param bacLuongCodeFilter (optional) 
     * @param maxSoNgayPhepFilter (optional) 
     * @param minSoNgayPhepFilter (optional) 
     * @param maxNgayChinhThucFilter (optional) 
     * @param minNgayChinhThucFilter (optional) 
     * @param maxNgayThuViecFilter (optional) 
     * @param minNgayThuViecFilter (optional) 
     * @param maxNgayTapSuFilter (optional) 
     * @param minNgayTapSuFilter (optional) 
     * @param soSoQLLaoDongFilter (optional) 
     * @param diaDiemLamViecCodeFilter (optional) 
     * @param quanLyGianTiepFilter (optional) 
     * @param quanLyTrucTiepFilter (optional) 
     * @param trangThaiLamViecCodeFilter (optional) 
     * @param bacFilter (optional) 
     * @param capFilter (optional) 
     * @param chucDanhFilter (optional) 
     * @param maChamCongFilter (optional) 
     * @param diaChiLHKCFilter (optional) 
     * @param emailLHKCFilter (optional) 
     * @param dtDiDongLHKCFilter (optional) 
     * @param dtNhaRiengLHKCFilter (optional) 
     * @param quanHeLHKCFilter (optional) 
     * @param hoVaTenLHKCFilter (optional) 
     * @param diaChiHNFilter (optional) 
     * @param maxTinhThanhIDHNFilter (optional) 
     * @param minTinhThanhIDHNFilter (optional) 
     * @param quocGiaHNFilter (optional) 
     * @param laChuHoFilter (optional) 
     * @param maSoHoGiaDinhFilter (optional) 
     * @param soSoHoKhauFilter (optional) 
     * @param diaChiHKTTFilter (optional) 
     * @param maxTinhThanhIDHKTTFilter (optional) 
     * @param minTinhThanhIDHKTTFilter (optional) 
     * @param quocGiaHKTTFilter (optional) 
     * @param facebookFilter (optional) 
     * @param skypeFilter (optional) 
     * @param noiSinhFilter (optional) 
     * @param maxTinhThanhIDFilter (optional) 
     * @param minTinhThanhIDFilter (optional) 
     * @param nguyenQuanFilter (optional) 
     * @param emailKhacFilter (optional) 
     * @param emailCoQuanFilter (optional) 
     * @param emailCaNhanFilter (optional) 
     * @param dtKhacFilter (optional) 
     * @param dtNhaRiengFilter (optional) 
     * @param dtCoQuanFilter (optional) 
     * @param dtDiDongFilter (optional) 
     * @param tepDinhKemFilter (optional) 
     * @param tinhTrangHonNhanCodeFilter (optional) 
     * @param xepLoaiCodeFilter (optional) 
     * @param maxNamTotNghiepFilter (optional) 
     * @param minNamTotNghiepFilter (optional) 
     * @param chuyenNganhFilter (optional) 
     * @param khoaFilter (optional) 
     * @param trinhDoDaoTaoCodeFilter (optional) 
     * @param trinhDoVanHoaFilter (optional) 
     * @param maxNgayHetHanFilter (optional) 
     * @param minNgayHetHanFilter (optional) 
     * @param noiCapFilter (optional) 
     * @param maxNgayCapFilter (optional) 
     * @param minNgayCapFilter (optional) 
     * @param soCMNDFilter (optional) 
     * @param quocTichFilter (optional) 
     * @param tonGiaoFilter (optional) 
     * @param danTocFilter (optional) 
     * @param viTriCongViecCodeFilter (optional) 
     * @param maxDonViCongTacIDFilter (optional) 
     * @param minDonViCongTacIDFilter (optional) 
     * @param mSTCaNhanFilter (optional) 
     * @param maxNgaySinhFilter (optional) 
     * @param minNgaySinhFilter (optional) 
     * @param gioiTinhCodeFilter (optional) 
     * @param anhDaiDienFilter (optional) 
     * @param hoVaTenFilter (optional) 
     * @param maNhanVienFilter (optional) 
     * @param chiNhanhFilter (optional) 
     * @param dVTFilter (optional) 
     * @param maxNgayKyHDKTHFilter (optional) 
     * @param minNgayKyHDKTHFilter (optional) 
     * @param maxNgayKyHD36THFilter (optional) 
     * @param minNgayKyHD36THFilter (optional) 
     * @param maxNgayKyHD12THFilter (optional) 
     * @param minNgayKyHD12THFilter (optional) 
     * @param maxNgayKyHDTVFilter (optional) 
     * @param minNgayKyHDTVFilter (optional) 
     * @param maxNgayKYHDCTVFilter (optional) 
     * @param minNgayKYHDCTVFilter (optional) 
     * @param maxNgayKyHDKVFilter (optional) 
     * @param minNgayKyHDKVFilter (optional) 
     * @param maxNgayKYHDTTFilter (optional) 
     * @param minNgayKYHDTTFilter (optional) 
     * @param maxNgayKyHDFilter (optional) 
     * @param minNgayKyHDFilter (optional) 
     * @return Success
     */
    getViTriCongViecsToExcel(filter: string | undefined, tenCtyFilter: string | undefined, hopDongHienTaiFilter: string | undefined, soHDFilter: string | undefined, donViCongTacNameFilter: string | undefined, choNgoiFilter: string | undefined, maxNoiDaoTaoIDFilter: number | undefined, minNoiDaoTaoIDFilter: number | undefined, maxLoaiHopDongIDFilter: number | undefined, minLoaiHopDongIDFilter: number | undefined, maSoNoiKCBFilter: string | undefined, maxNoiDangKyKCBIDFilter: number | undefined, minNoiDangKyKCBIDFilter: number | undefined, maxNgayHetHanBHYTFilter: moment.Moment | undefined, minNgayHetHanBHYTFilter: moment.Moment | undefined, soTheBHYTFilter: string | undefined, maTinhCapFilter: string | undefined, maSoBHXHFilter: string | undefined, soSoBHXHFilter: string | undefined, maxTyLeDongBHFilter: number | undefined, minTyLeDongBHFilter: number | undefined, maxNgayThamGiaBHFilter: moment.Moment | undefined, minNgayThamGiaBHFilter: moment.Moment | undefined, thamGiaCongDoanFilter: number | undefined, nganHangCodeFilter: string | undefined, tkNganHangFilter: string | undefined, donViSoCongChuanCodeFilter: string | undefined, soCongChuanFilter: string | undefined, luongDongBHFilter: string | undefined, luongCoBanFilter: string | undefined, bacLuongCodeFilter: string | undefined, maxSoNgayPhepFilter: number | undefined, minSoNgayPhepFilter: number | undefined, maxNgayChinhThucFilter: moment.Moment | undefined, minNgayChinhThucFilter: moment.Moment | undefined, maxNgayThuViecFilter: moment.Moment | undefined, minNgayThuViecFilter: moment.Moment | undefined, maxNgayTapSuFilter: moment.Moment | undefined, minNgayTapSuFilter: moment.Moment | undefined, soSoQLLaoDongFilter: string | undefined, diaDiemLamViecCodeFilter: string | undefined, quanLyGianTiepFilter: string | undefined, quanLyTrucTiepFilter: string | undefined, trangThaiLamViecCodeFilter: string | undefined, bacFilter: string | undefined, capFilter: string | undefined, chucDanhFilter: string | undefined, maChamCongFilter: string | undefined, diaChiLHKCFilter: string | undefined, emailLHKCFilter: string | undefined, dtDiDongLHKCFilter: string | undefined, dtNhaRiengLHKCFilter: string | undefined, quanHeLHKCFilter: string | undefined, hoVaTenLHKCFilter: string | undefined, diaChiHNFilter: string | undefined, maxTinhThanhIDHNFilter: number | undefined, minTinhThanhIDHNFilter: number | undefined, quocGiaHNFilter: string | undefined, laChuHoFilter: number | undefined, maSoHoGiaDinhFilter: string | undefined, soSoHoKhauFilter: string | undefined, diaChiHKTTFilter: string | undefined, maxTinhThanhIDHKTTFilter: number | undefined, minTinhThanhIDHKTTFilter: number | undefined, quocGiaHKTTFilter: string | undefined, facebookFilter: string | undefined, skypeFilter: string | undefined, noiSinhFilter: string | undefined, maxTinhThanhIDFilter: number | undefined, minTinhThanhIDFilter: number | undefined, nguyenQuanFilter: string | undefined, emailKhacFilter: string | undefined, emailCoQuanFilter: string | undefined, emailCaNhanFilter: string | undefined, dtKhacFilter: string | undefined, dtNhaRiengFilter: string | undefined, dtCoQuanFilter: string | undefined, dtDiDongFilter: string | undefined, tepDinhKemFilter: string | undefined, tinhTrangHonNhanCodeFilter: string | undefined, xepLoaiCodeFilter: string | undefined, maxNamTotNghiepFilter: number | undefined, minNamTotNghiepFilter: number | undefined, chuyenNganhFilter: string | undefined, khoaFilter: string | undefined, trinhDoDaoTaoCodeFilter: string | undefined, trinhDoVanHoaFilter: string | undefined, maxNgayHetHanFilter: moment.Moment | undefined, minNgayHetHanFilter: moment.Moment | undefined, noiCapFilter: string | undefined, maxNgayCapFilter: moment.Moment | undefined, minNgayCapFilter: moment.Moment | undefined, soCMNDFilter: string | undefined, quocTichFilter: string | undefined, tonGiaoFilter: string | undefined, danTocFilter: string | undefined, viTriCongViecCodeFilter: string | undefined, maxDonViCongTacIDFilter: number | undefined, minDonViCongTacIDFilter: number | undefined, mSTCaNhanFilter: string | undefined, maxNgaySinhFilter: moment.Moment | undefined, minNgaySinhFilter: moment.Moment | undefined, gioiTinhCodeFilter: string | undefined, anhDaiDienFilter: string | undefined, hoVaTenFilter: string | undefined, maNhanVienFilter: string | undefined, chiNhanhFilter: string | undefined, dVTFilter: string | undefined, maxNgayKyHDKTHFilter: moment.Moment | undefined, minNgayKyHDKTHFilter: moment.Moment | undefined, maxNgayKyHD36THFilter: moment.Moment | undefined, minNgayKyHD36THFilter: moment.Moment | undefined, maxNgayKyHD12THFilter: moment.Moment | undefined, minNgayKyHD12THFilter: moment.Moment | undefined, maxNgayKyHDTVFilter: moment.Moment | undefined, minNgayKyHDTVFilter: moment.Moment | undefined, maxNgayKYHDCTVFilter: moment.Moment | undefined, minNgayKYHDCTVFilter: moment.Moment | undefined, maxNgayKyHDKVFilter: moment.Moment | undefined, minNgayKyHDKVFilter: moment.Moment | undefined, maxNgayKYHDTTFilter: moment.Moment | undefined, minNgayKYHDTTFilter: moment.Moment | undefined, maxNgayKyHDFilter: moment.Moment | undefined, minNgayKyHDFilter: moment.Moment | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ViTriCongViecs/GetViTriCongViecsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenCtyFilter === null)
            throw new Error("The parameter 'tenCtyFilter' cannot be null.");
        else if (tenCtyFilter !== undefined)
            url_ += "TenCtyFilter=" + encodeURIComponent("" + tenCtyFilter) + "&"; 
        if (hopDongHienTaiFilter === null)
            throw new Error("The parameter 'hopDongHienTaiFilter' cannot be null.");
        else if (hopDongHienTaiFilter !== undefined)
            url_ += "HopDongHienTaiFilter=" + encodeURIComponent("" + hopDongHienTaiFilter) + "&"; 
        if (soHDFilter === null)
            throw new Error("The parameter 'soHDFilter' cannot be null.");
        else if (soHDFilter !== undefined)
            url_ += "SoHDFilter=" + encodeURIComponent("" + soHDFilter) + "&"; 
        if (donViCongTacNameFilter === null)
            throw new Error("The parameter 'donViCongTacNameFilter' cannot be null.");
        else if (donViCongTacNameFilter !== undefined)
            url_ += "DonViCongTacNameFilter=" + encodeURIComponent("" + donViCongTacNameFilter) + "&"; 
        if (choNgoiFilter === null)
            throw new Error("The parameter 'choNgoiFilter' cannot be null.");
        else if (choNgoiFilter !== undefined)
            url_ += "ChoNgoiFilter=" + encodeURIComponent("" + choNgoiFilter) + "&"; 
        if (maxNoiDaoTaoIDFilter === null)
            throw new Error("The parameter 'maxNoiDaoTaoIDFilter' cannot be null.");
        else if (maxNoiDaoTaoIDFilter !== undefined)
            url_ += "MaxNoiDaoTaoIDFilter=" + encodeURIComponent("" + maxNoiDaoTaoIDFilter) + "&"; 
        if (minNoiDaoTaoIDFilter === null)
            throw new Error("The parameter 'minNoiDaoTaoIDFilter' cannot be null.");
        else if (minNoiDaoTaoIDFilter !== undefined)
            url_ += "MinNoiDaoTaoIDFilter=" + encodeURIComponent("" + minNoiDaoTaoIDFilter) + "&"; 
        if (maxLoaiHopDongIDFilter === null)
            throw new Error("The parameter 'maxLoaiHopDongIDFilter' cannot be null.");
        else if (maxLoaiHopDongIDFilter !== undefined)
            url_ += "MaxLoaiHopDongIDFilter=" + encodeURIComponent("" + maxLoaiHopDongIDFilter) + "&"; 
        if (minLoaiHopDongIDFilter === null)
            throw new Error("The parameter 'minLoaiHopDongIDFilter' cannot be null.");
        else if (minLoaiHopDongIDFilter !== undefined)
            url_ += "MinLoaiHopDongIDFilter=" + encodeURIComponent("" + minLoaiHopDongIDFilter) + "&"; 
        if (maSoNoiKCBFilter === null)
            throw new Error("The parameter 'maSoNoiKCBFilter' cannot be null.");
        else if (maSoNoiKCBFilter !== undefined)
            url_ += "MaSoNoiKCBFilter=" + encodeURIComponent("" + maSoNoiKCBFilter) + "&"; 
        if (maxNoiDangKyKCBIDFilter === null)
            throw new Error("The parameter 'maxNoiDangKyKCBIDFilter' cannot be null.");
        else if (maxNoiDangKyKCBIDFilter !== undefined)
            url_ += "MaxNoiDangKyKCBIDFilter=" + encodeURIComponent("" + maxNoiDangKyKCBIDFilter) + "&"; 
        if (minNoiDangKyKCBIDFilter === null)
            throw new Error("The parameter 'minNoiDangKyKCBIDFilter' cannot be null.");
        else if (minNoiDangKyKCBIDFilter !== undefined)
            url_ += "MinNoiDangKyKCBIDFilter=" + encodeURIComponent("" + minNoiDangKyKCBIDFilter) + "&"; 
        if (maxNgayHetHanBHYTFilter === null)
            throw new Error("The parameter 'maxNgayHetHanBHYTFilter' cannot be null.");
        else if (maxNgayHetHanBHYTFilter !== undefined)
            url_ += "MaxNgayHetHanBHYTFilter=" + encodeURIComponent(maxNgayHetHanBHYTFilter ? "" + maxNgayHetHanBHYTFilter.toJSON() : "") + "&"; 
        if (minNgayHetHanBHYTFilter === null)
            throw new Error("The parameter 'minNgayHetHanBHYTFilter' cannot be null.");
        else if (minNgayHetHanBHYTFilter !== undefined)
            url_ += "MinNgayHetHanBHYTFilter=" + encodeURIComponent(minNgayHetHanBHYTFilter ? "" + minNgayHetHanBHYTFilter.toJSON() : "") + "&"; 
        if (soTheBHYTFilter === null)
            throw new Error("The parameter 'soTheBHYTFilter' cannot be null.");
        else if (soTheBHYTFilter !== undefined)
            url_ += "SoTheBHYTFilter=" + encodeURIComponent("" + soTheBHYTFilter) + "&"; 
        if (maTinhCapFilter === null)
            throw new Error("The parameter 'maTinhCapFilter' cannot be null.");
        else if (maTinhCapFilter !== undefined)
            url_ += "MaTinhCapFilter=" + encodeURIComponent("" + maTinhCapFilter) + "&"; 
        if (maSoBHXHFilter === null)
            throw new Error("The parameter 'maSoBHXHFilter' cannot be null.");
        else if (maSoBHXHFilter !== undefined)
            url_ += "MaSoBHXHFilter=" + encodeURIComponent("" + maSoBHXHFilter) + "&"; 
        if (soSoBHXHFilter === null)
            throw new Error("The parameter 'soSoBHXHFilter' cannot be null.");
        else if (soSoBHXHFilter !== undefined)
            url_ += "SoSoBHXHFilter=" + encodeURIComponent("" + soSoBHXHFilter) + "&"; 
        if (maxTyLeDongBHFilter === null)
            throw new Error("The parameter 'maxTyLeDongBHFilter' cannot be null.");
        else if (maxTyLeDongBHFilter !== undefined)
            url_ += "MaxTyLeDongBHFilter=" + encodeURIComponent("" + maxTyLeDongBHFilter) + "&"; 
        if (minTyLeDongBHFilter === null)
            throw new Error("The parameter 'minTyLeDongBHFilter' cannot be null.");
        else if (minTyLeDongBHFilter !== undefined)
            url_ += "MinTyLeDongBHFilter=" + encodeURIComponent("" + minTyLeDongBHFilter) + "&"; 
        if (maxNgayThamGiaBHFilter === null)
            throw new Error("The parameter 'maxNgayThamGiaBHFilter' cannot be null.");
        else if (maxNgayThamGiaBHFilter !== undefined)
            url_ += "MaxNgayThamGiaBHFilter=" + encodeURIComponent(maxNgayThamGiaBHFilter ? "" + maxNgayThamGiaBHFilter.toJSON() : "") + "&"; 
        if (minNgayThamGiaBHFilter === null)
            throw new Error("The parameter 'minNgayThamGiaBHFilter' cannot be null.");
        else if (minNgayThamGiaBHFilter !== undefined)
            url_ += "MinNgayThamGiaBHFilter=" + encodeURIComponent(minNgayThamGiaBHFilter ? "" + minNgayThamGiaBHFilter.toJSON() : "") + "&"; 
        if (thamGiaCongDoanFilter === null)
            throw new Error("The parameter 'thamGiaCongDoanFilter' cannot be null.");
        else if (thamGiaCongDoanFilter !== undefined)
            url_ += "ThamGiaCongDoanFilter=" + encodeURIComponent("" + thamGiaCongDoanFilter) + "&"; 
        if (nganHangCodeFilter === null)
            throw new Error("The parameter 'nganHangCodeFilter' cannot be null.");
        else if (nganHangCodeFilter !== undefined)
            url_ += "NganHangCodeFilter=" + encodeURIComponent("" + nganHangCodeFilter) + "&"; 
        if (tkNganHangFilter === null)
            throw new Error("The parameter 'tkNganHangFilter' cannot be null.");
        else if (tkNganHangFilter !== undefined)
            url_ += "TkNganHangFilter=" + encodeURIComponent("" + tkNganHangFilter) + "&"; 
        if (donViSoCongChuanCodeFilter === null)
            throw new Error("The parameter 'donViSoCongChuanCodeFilter' cannot be null.");
        else if (donViSoCongChuanCodeFilter !== undefined)
            url_ += "DonViSoCongChuanCodeFilter=" + encodeURIComponent("" + donViSoCongChuanCodeFilter) + "&"; 
        if (soCongChuanFilter === null)
            throw new Error("The parameter 'soCongChuanFilter' cannot be null.");
        else if (soCongChuanFilter !== undefined)
            url_ += "SoCongChuanFilter=" + encodeURIComponent("" + soCongChuanFilter) + "&"; 
        if (luongDongBHFilter === null)
            throw new Error("The parameter 'luongDongBHFilter' cannot be null.");
        else if (luongDongBHFilter !== undefined)
            url_ += "LuongDongBHFilter=" + encodeURIComponent("" + luongDongBHFilter) + "&"; 
        if (luongCoBanFilter === null)
            throw new Error("The parameter 'luongCoBanFilter' cannot be null.");
        else if (luongCoBanFilter !== undefined)
            url_ += "LuongCoBanFilter=" + encodeURIComponent("" + luongCoBanFilter) + "&"; 
        if (bacLuongCodeFilter === null)
            throw new Error("The parameter 'bacLuongCodeFilter' cannot be null.");
        else if (bacLuongCodeFilter !== undefined)
            url_ += "BacLuongCodeFilter=" + encodeURIComponent("" + bacLuongCodeFilter) + "&"; 
        if (maxSoNgayPhepFilter === null)
            throw new Error("The parameter 'maxSoNgayPhepFilter' cannot be null.");
        else if (maxSoNgayPhepFilter !== undefined)
            url_ += "MaxSoNgayPhepFilter=" + encodeURIComponent("" + maxSoNgayPhepFilter) + "&"; 
        if (minSoNgayPhepFilter === null)
            throw new Error("The parameter 'minSoNgayPhepFilter' cannot be null.");
        else if (minSoNgayPhepFilter !== undefined)
            url_ += "MinSoNgayPhepFilter=" + encodeURIComponent("" + minSoNgayPhepFilter) + "&"; 
        if (maxNgayChinhThucFilter === null)
            throw new Error("The parameter 'maxNgayChinhThucFilter' cannot be null.");
        else if (maxNgayChinhThucFilter !== undefined)
            url_ += "MaxNgayChinhThucFilter=" + encodeURIComponent(maxNgayChinhThucFilter ? "" + maxNgayChinhThucFilter.toJSON() : "") + "&"; 
        if (minNgayChinhThucFilter === null)
            throw new Error("The parameter 'minNgayChinhThucFilter' cannot be null.");
        else if (minNgayChinhThucFilter !== undefined)
            url_ += "MinNgayChinhThucFilter=" + encodeURIComponent(minNgayChinhThucFilter ? "" + minNgayChinhThucFilter.toJSON() : "") + "&"; 
        if (maxNgayThuViecFilter === null)
            throw new Error("The parameter 'maxNgayThuViecFilter' cannot be null.");
        else if (maxNgayThuViecFilter !== undefined)
            url_ += "MaxNgayThuViecFilter=" + encodeURIComponent(maxNgayThuViecFilter ? "" + maxNgayThuViecFilter.toJSON() : "") + "&"; 
        if (minNgayThuViecFilter === null)
            throw new Error("The parameter 'minNgayThuViecFilter' cannot be null.");
        else if (minNgayThuViecFilter !== undefined)
            url_ += "MinNgayThuViecFilter=" + encodeURIComponent(minNgayThuViecFilter ? "" + minNgayThuViecFilter.toJSON() : "") + "&"; 
        if (maxNgayTapSuFilter === null)
            throw new Error("The parameter 'maxNgayTapSuFilter' cannot be null.");
        else if (maxNgayTapSuFilter !== undefined)
            url_ += "MaxNgayTapSuFilter=" + encodeURIComponent(maxNgayTapSuFilter ? "" + maxNgayTapSuFilter.toJSON() : "") + "&"; 
        if (minNgayTapSuFilter === null)
            throw new Error("The parameter 'minNgayTapSuFilter' cannot be null.");
        else if (minNgayTapSuFilter !== undefined)
            url_ += "MinNgayTapSuFilter=" + encodeURIComponent(minNgayTapSuFilter ? "" + minNgayTapSuFilter.toJSON() : "") + "&"; 
        if (soSoQLLaoDongFilter === null)
            throw new Error("The parameter 'soSoQLLaoDongFilter' cannot be null.");
        else if (soSoQLLaoDongFilter !== undefined)
            url_ += "SoSoQLLaoDongFilter=" + encodeURIComponent("" + soSoQLLaoDongFilter) + "&"; 
        if (diaDiemLamViecCodeFilter === null)
            throw new Error("The parameter 'diaDiemLamViecCodeFilter' cannot be null.");
        else if (diaDiemLamViecCodeFilter !== undefined)
            url_ += "DiaDiemLamViecCodeFilter=" + encodeURIComponent("" + diaDiemLamViecCodeFilter) + "&"; 
        if (quanLyGianTiepFilter === null)
            throw new Error("The parameter 'quanLyGianTiepFilter' cannot be null.");
        else if (quanLyGianTiepFilter !== undefined)
            url_ += "QuanLyGianTiepFilter=" + encodeURIComponent("" + quanLyGianTiepFilter) + "&"; 
        if (quanLyTrucTiepFilter === null)
            throw new Error("The parameter 'quanLyTrucTiepFilter' cannot be null.");
        else if (quanLyTrucTiepFilter !== undefined)
            url_ += "QuanLyTrucTiepFilter=" + encodeURIComponent("" + quanLyTrucTiepFilter) + "&"; 
        if (trangThaiLamViecCodeFilter === null)
            throw new Error("The parameter 'trangThaiLamViecCodeFilter' cannot be null.");
        else if (trangThaiLamViecCodeFilter !== undefined)
            url_ += "TrangThaiLamViecCodeFilter=" + encodeURIComponent("" + trangThaiLamViecCodeFilter) + "&"; 
        if (bacFilter === null)
            throw new Error("The parameter 'bacFilter' cannot be null.");
        else if (bacFilter !== undefined)
            url_ += "BacFilter=" + encodeURIComponent("" + bacFilter) + "&"; 
        if (capFilter === null)
            throw new Error("The parameter 'capFilter' cannot be null.");
        else if (capFilter !== undefined)
            url_ += "CapFilter=" + encodeURIComponent("" + capFilter) + "&"; 
        if (chucDanhFilter === null)
            throw new Error("The parameter 'chucDanhFilter' cannot be null.");
        else if (chucDanhFilter !== undefined)
            url_ += "ChucDanhFilter=" + encodeURIComponent("" + chucDanhFilter) + "&"; 
        if (maChamCongFilter === null)
            throw new Error("The parameter 'maChamCongFilter' cannot be null.");
        else if (maChamCongFilter !== undefined)
            url_ += "MaChamCongFilter=" + encodeURIComponent("" + maChamCongFilter) + "&"; 
        if (diaChiLHKCFilter === null)
            throw new Error("The parameter 'diaChiLHKCFilter' cannot be null.");
        else if (diaChiLHKCFilter !== undefined)
            url_ += "DiaChiLHKCFilter=" + encodeURIComponent("" + diaChiLHKCFilter) + "&"; 
        if (emailLHKCFilter === null)
            throw new Error("The parameter 'emailLHKCFilter' cannot be null.");
        else if (emailLHKCFilter !== undefined)
            url_ += "EmailLHKCFilter=" + encodeURIComponent("" + emailLHKCFilter) + "&"; 
        if (dtDiDongLHKCFilter === null)
            throw new Error("The parameter 'dtDiDongLHKCFilter' cannot be null.");
        else if (dtDiDongLHKCFilter !== undefined)
            url_ += "DtDiDongLHKCFilter=" + encodeURIComponent("" + dtDiDongLHKCFilter) + "&"; 
        if (dtNhaRiengLHKCFilter === null)
            throw new Error("The parameter 'dtNhaRiengLHKCFilter' cannot be null.");
        else if (dtNhaRiengLHKCFilter !== undefined)
            url_ += "DtNhaRiengLHKCFilter=" + encodeURIComponent("" + dtNhaRiengLHKCFilter) + "&"; 
        if (quanHeLHKCFilter === null)
            throw new Error("The parameter 'quanHeLHKCFilter' cannot be null.");
        else if (quanHeLHKCFilter !== undefined)
            url_ += "QuanHeLHKCFilter=" + encodeURIComponent("" + quanHeLHKCFilter) + "&"; 
        if (hoVaTenLHKCFilter === null)
            throw new Error("The parameter 'hoVaTenLHKCFilter' cannot be null.");
        else if (hoVaTenLHKCFilter !== undefined)
            url_ += "HoVaTenLHKCFilter=" + encodeURIComponent("" + hoVaTenLHKCFilter) + "&"; 
        if (diaChiHNFilter === null)
            throw new Error("The parameter 'diaChiHNFilter' cannot be null.");
        else if (diaChiHNFilter !== undefined)
            url_ += "DiaChiHNFilter=" + encodeURIComponent("" + diaChiHNFilter) + "&"; 
        if (maxTinhThanhIDHNFilter === null)
            throw new Error("The parameter 'maxTinhThanhIDHNFilter' cannot be null.");
        else if (maxTinhThanhIDHNFilter !== undefined)
            url_ += "MaxTinhThanhIDHNFilter=" + encodeURIComponent("" + maxTinhThanhIDHNFilter) + "&"; 
        if (minTinhThanhIDHNFilter === null)
            throw new Error("The parameter 'minTinhThanhIDHNFilter' cannot be null.");
        else if (minTinhThanhIDHNFilter !== undefined)
            url_ += "MinTinhThanhIDHNFilter=" + encodeURIComponent("" + minTinhThanhIDHNFilter) + "&"; 
        if (quocGiaHNFilter === null)
            throw new Error("The parameter 'quocGiaHNFilter' cannot be null.");
        else if (quocGiaHNFilter !== undefined)
            url_ += "QuocGiaHNFilter=" + encodeURIComponent("" + quocGiaHNFilter) + "&"; 
        if (laChuHoFilter === null)
            throw new Error("The parameter 'laChuHoFilter' cannot be null.");
        else if (laChuHoFilter !== undefined)
            url_ += "LaChuHoFilter=" + encodeURIComponent("" + laChuHoFilter) + "&"; 
        if (maSoHoGiaDinhFilter === null)
            throw new Error("The parameter 'maSoHoGiaDinhFilter' cannot be null.");
        else if (maSoHoGiaDinhFilter !== undefined)
            url_ += "MaSoHoGiaDinhFilter=" + encodeURIComponent("" + maSoHoGiaDinhFilter) + "&"; 
        if (soSoHoKhauFilter === null)
            throw new Error("The parameter 'soSoHoKhauFilter' cannot be null.");
        else if (soSoHoKhauFilter !== undefined)
            url_ += "SoSoHoKhauFilter=" + encodeURIComponent("" + soSoHoKhauFilter) + "&"; 
        if (diaChiHKTTFilter === null)
            throw new Error("The parameter 'diaChiHKTTFilter' cannot be null.");
        else if (diaChiHKTTFilter !== undefined)
            url_ += "DiaChiHKTTFilter=" + encodeURIComponent("" + diaChiHKTTFilter) + "&"; 
        if (maxTinhThanhIDHKTTFilter === null)
            throw new Error("The parameter 'maxTinhThanhIDHKTTFilter' cannot be null.");
        else if (maxTinhThanhIDHKTTFilter !== undefined)
            url_ += "MaxTinhThanhIDHKTTFilter=" + encodeURIComponent("" + maxTinhThanhIDHKTTFilter) + "&"; 
        if (minTinhThanhIDHKTTFilter === null)
            throw new Error("The parameter 'minTinhThanhIDHKTTFilter' cannot be null.");
        else if (minTinhThanhIDHKTTFilter !== undefined)
            url_ += "MinTinhThanhIDHKTTFilter=" + encodeURIComponent("" + minTinhThanhIDHKTTFilter) + "&"; 
        if (quocGiaHKTTFilter === null)
            throw new Error("The parameter 'quocGiaHKTTFilter' cannot be null.");
        else if (quocGiaHKTTFilter !== undefined)
            url_ += "QuocGiaHKTTFilter=" + encodeURIComponent("" + quocGiaHKTTFilter) + "&"; 
        if (facebookFilter === null)
            throw new Error("The parameter 'facebookFilter' cannot be null.");
        else if (facebookFilter !== undefined)
            url_ += "FacebookFilter=" + encodeURIComponent("" + facebookFilter) + "&"; 
        if (skypeFilter === null)
            throw new Error("The parameter 'skypeFilter' cannot be null.");
        else if (skypeFilter !== undefined)
            url_ += "SkypeFilter=" + encodeURIComponent("" + skypeFilter) + "&"; 
        if (noiSinhFilter === null)
            throw new Error("The parameter 'noiSinhFilter' cannot be null.");
        else if (noiSinhFilter !== undefined)
            url_ += "NoiSinhFilter=" + encodeURIComponent("" + noiSinhFilter) + "&"; 
        if (maxTinhThanhIDFilter === null)
            throw new Error("The parameter 'maxTinhThanhIDFilter' cannot be null.");
        else if (maxTinhThanhIDFilter !== undefined)
            url_ += "MaxTinhThanhIDFilter=" + encodeURIComponent("" + maxTinhThanhIDFilter) + "&"; 
        if (minTinhThanhIDFilter === null)
            throw new Error("The parameter 'minTinhThanhIDFilter' cannot be null.");
        else if (minTinhThanhIDFilter !== undefined)
            url_ += "MinTinhThanhIDFilter=" + encodeURIComponent("" + minTinhThanhIDFilter) + "&"; 
        if (nguyenQuanFilter === null)
            throw new Error("The parameter 'nguyenQuanFilter' cannot be null.");
        else if (nguyenQuanFilter !== undefined)
            url_ += "NguyenQuanFilter=" + encodeURIComponent("" + nguyenQuanFilter) + "&"; 
        if (emailKhacFilter === null)
            throw new Error("The parameter 'emailKhacFilter' cannot be null.");
        else if (emailKhacFilter !== undefined)
            url_ += "EmailKhacFilter=" + encodeURIComponent("" + emailKhacFilter) + "&"; 
        if (emailCoQuanFilter === null)
            throw new Error("The parameter 'emailCoQuanFilter' cannot be null.");
        else if (emailCoQuanFilter !== undefined)
            url_ += "EmailCoQuanFilter=" + encodeURIComponent("" + emailCoQuanFilter) + "&"; 
        if (emailCaNhanFilter === null)
            throw new Error("The parameter 'emailCaNhanFilter' cannot be null.");
        else if (emailCaNhanFilter !== undefined)
            url_ += "EmailCaNhanFilter=" + encodeURIComponent("" + emailCaNhanFilter) + "&"; 
        if (dtKhacFilter === null)
            throw new Error("The parameter 'dtKhacFilter' cannot be null.");
        else if (dtKhacFilter !== undefined)
            url_ += "DtKhacFilter=" + encodeURIComponent("" + dtKhacFilter) + "&"; 
        if (dtNhaRiengFilter === null)
            throw new Error("The parameter 'dtNhaRiengFilter' cannot be null.");
        else if (dtNhaRiengFilter !== undefined)
            url_ += "DtNhaRiengFilter=" + encodeURIComponent("" + dtNhaRiengFilter) + "&"; 
        if (dtCoQuanFilter === null)
            throw new Error("The parameter 'dtCoQuanFilter' cannot be null.");
        else if (dtCoQuanFilter !== undefined)
            url_ += "DtCoQuanFilter=" + encodeURIComponent("" + dtCoQuanFilter) + "&"; 
        if (dtDiDongFilter === null)
            throw new Error("The parameter 'dtDiDongFilter' cannot be null.");
        else if (dtDiDongFilter !== undefined)
            url_ += "DtDiDongFilter=" + encodeURIComponent("" + dtDiDongFilter) + "&"; 
        if (tepDinhKemFilter === null)
            throw new Error("The parameter 'tepDinhKemFilter' cannot be null.");
        else if (tepDinhKemFilter !== undefined)
            url_ += "TepDinhKemFilter=" + encodeURIComponent("" + tepDinhKemFilter) + "&"; 
        if (tinhTrangHonNhanCodeFilter === null)
            throw new Error("The parameter 'tinhTrangHonNhanCodeFilter' cannot be null.");
        else if (tinhTrangHonNhanCodeFilter !== undefined)
            url_ += "TinhTrangHonNhanCodeFilter=" + encodeURIComponent("" + tinhTrangHonNhanCodeFilter) + "&"; 
        if (xepLoaiCodeFilter === null)
            throw new Error("The parameter 'xepLoaiCodeFilter' cannot be null.");
        else if (xepLoaiCodeFilter !== undefined)
            url_ += "XepLoaiCodeFilter=" + encodeURIComponent("" + xepLoaiCodeFilter) + "&"; 
        if (maxNamTotNghiepFilter === null)
            throw new Error("The parameter 'maxNamTotNghiepFilter' cannot be null.");
        else if (maxNamTotNghiepFilter !== undefined)
            url_ += "MaxNamTotNghiepFilter=" + encodeURIComponent("" + maxNamTotNghiepFilter) + "&"; 
        if (minNamTotNghiepFilter === null)
            throw new Error("The parameter 'minNamTotNghiepFilter' cannot be null.");
        else if (minNamTotNghiepFilter !== undefined)
            url_ += "MinNamTotNghiepFilter=" + encodeURIComponent("" + minNamTotNghiepFilter) + "&"; 
        if (chuyenNganhFilter === null)
            throw new Error("The parameter 'chuyenNganhFilter' cannot be null.");
        else if (chuyenNganhFilter !== undefined)
            url_ += "ChuyenNganhFilter=" + encodeURIComponent("" + chuyenNganhFilter) + "&"; 
        if (khoaFilter === null)
            throw new Error("The parameter 'khoaFilter' cannot be null.");
        else if (khoaFilter !== undefined)
            url_ += "KhoaFilter=" + encodeURIComponent("" + khoaFilter) + "&"; 
        if (trinhDoDaoTaoCodeFilter === null)
            throw new Error("The parameter 'trinhDoDaoTaoCodeFilter' cannot be null.");
        else if (trinhDoDaoTaoCodeFilter !== undefined)
            url_ += "TrinhDoDaoTaoCodeFilter=" + encodeURIComponent("" + trinhDoDaoTaoCodeFilter) + "&"; 
        if (trinhDoVanHoaFilter === null)
            throw new Error("The parameter 'trinhDoVanHoaFilter' cannot be null.");
        else if (trinhDoVanHoaFilter !== undefined)
            url_ += "TrinhDoVanHoaFilter=" + encodeURIComponent("" + trinhDoVanHoaFilter) + "&"; 
        if (maxNgayHetHanFilter === null)
            throw new Error("The parameter 'maxNgayHetHanFilter' cannot be null.");
        else if (maxNgayHetHanFilter !== undefined)
            url_ += "MaxNgayHetHanFilter=" + encodeURIComponent(maxNgayHetHanFilter ? "" + maxNgayHetHanFilter.toJSON() : "") + "&"; 
        if (minNgayHetHanFilter === null)
            throw new Error("The parameter 'minNgayHetHanFilter' cannot be null.");
        else if (minNgayHetHanFilter !== undefined)
            url_ += "MinNgayHetHanFilter=" + encodeURIComponent(minNgayHetHanFilter ? "" + minNgayHetHanFilter.toJSON() : "") + "&"; 
        if (noiCapFilter === null)
            throw new Error("The parameter 'noiCapFilter' cannot be null.");
        else if (noiCapFilter !== undefined)
            url_ += "NoiCapFilter=" + encodeURIComponent("" + noiCapFilter) + "&"; 
        if (maxNgayCapFilter === null)
            throw new Error("The parameter 'maxNgayCapFilter' cannot be null.");
        else if (maxNgayCapFilter !== undefined)
            url_ += "MaxNgayCapFilter=" + encodeURIComponent(maxNgayCapFilter ? "" + maxNgayCapFilter.toJSON() : "") + "&"; 
        if (minNgayCapFilter === null)
            throw new Error("The parameter 'minNgayCapFilter' cannot be null.");
        else if (minNgayCapFilter !== undefined)
            url_ += "MinNgayCapFilter=" + encodeURIComponent(minNgayCapFilter ? "" + minNgayCapFilter.toJSON() : "") + "&"; 
        if (soCMNDFilter === null)
            throw new Error("The parameter 'soCMNDFilter' cannot be null.");
        else if (soCMNDFilter !== undefined)
            url_ += "SoCMNDFilter=" + encodeURIComponent("" + soCMNDFilter) + "&"; 
        if (quocTichFilter === null)
            throw new Error("The parameter 'quocTichFilter' cannot be null.");
        else if (quocTichFilter !== undefined)
            url_ += "QuocTichFilter=" + encodeURIComponent("" + quocTichFilter) + "&"; 
        if (tonGiaoFilter === null)
            throw new Error("The parameter 'tonGiaoFilter' cannot be null.");
        else if (tonGiaoFilter !== undefined)
            url_ += "TonGiaoFilter=" + encodeURIComponent("" + tonGiaoFilter) + "&"; 
        if (danTocFilter === null)
            throw new Error("The parameter 'danTocFilter' cannot be null.");
        else if (danTocFilter !== undefined)
            url_ += "DanTocFilter=" + encodeURIComponent("" + danTocFilter) + "&"; 
        if (viTriCongViecCodeFilter === null)
            throw new Error("The parameter 'viTriCongViecCodeFilter' cannot be null.");
        else if (viTriCongViecCodeFilter !== undefined)
            url_ += "ViTriCongViecCodeFilter=" + encodeURIComponent("" + viTriCongViecCodeFilter) + "&"; 
        if (maxDonViCongTacIDFilter === null)
            throw new Error("The parameter 'maxDonViCongTacIDFilter' cannot be null.");
        else if (maxDonViCongTacIDFilter !== undefined)
            url_ += "MaxDonViCongTacIDFilter=" + encodeURIComponent("" + maxDonViCongTacIDFilter) + "&"; 
        if (minDonViCongTacIDFilter === null)
            throw new Error("The parameter 'minDonViCongTacIDFilter' cannot be null.");
        else if (minDonViCongTacIDFilter !== undefined)
            url_ += "MinDonViCongTacIDFilter=" + encodeURIComponent("" + minDonViCongTacIDFilter) + "&"; 
        if (mSTCaNhanFilter === null)
            throw new Error("The parameter 'mSTCaNhanFilter' cannot be null.");
        else if (mSTCaNhanFilter !== undefined)
            url_ += "MSTCaNhanFilter=" + encodeURIComponent("" + mSTCaNhanFilter) + "&"; 
        if (maxNgaySinhFilter === null)
            throw new Error("The parameter 'maxNgaySinhFilter' cannot be null.");
        else if (maxNgaySinhFilter !== undefined)
            url_ += "MaxNgaySinhFilter=" + encodeURIComponent(maxNgaySinhFilter ? "" + maxNgaySinhFilter.toJSON() : "") + "&"; 
        if (minNgaySinhFilter === null)
            throw new Error("The parameter 'minNgaySinhFilter' cannot be null.");
        else if (minNgaySinhFilter !== undefined)
            url_ += "MinNgaySinhFilter=" + encodeURIComponent(minNgaySinhFilter ? "" + minNgaySinhFilter.toJSON() : "") + "&"; 
        if (gioiTinhCodeFilter === null)
            throw new Error("The parameter 'gioiTinhCodeFilter' cannot be null.");
        else if (gioiTinhCodeFilter !== undefined)
            url_ += "GioiTinhCodeFilter=" + encodeURIComponent("" + gioiTinhCodeFilter) + "&"; 
        if (anhDaiDienFilter === null)
            throw new Error("The parameter 'anhDaiDienFilter' cannot be null.");
        else if (anhDaiDienFilter !== undefined)
            url_ += "AnhDaiDienFilter=" + encodeURIComponent("" + anhDaiDienFilter) + "&"; 
        if (hoVaTenFilter === null)
            throw new Error("The parameter 'hoVaTenFilter' cannot be null.");
        else if (hoVaTenFilter !== undefined)
            url_ += "HoVaTenFilter=" + encodeURIComponent("" + hoVaTenFilter) + "&"; 
        if (maNhanVienFilter === null)
            throw new Error("The parameter 'maNhanVienFilter' cannot be null.");
        else if (maNhanVienFilter !== undefined)
            url_ += "MaNhanVienFilter=" + encodeURIComponent("" + maNhanVienFilter) + "&"; 
        if (chiNhanhFilter === null)
            throw new Error("The parameter 'chiNhanhFilter' cannot be null.");
        else if (chiNhanhFilter !== undefined)
            url_ += "ChiNhanhFilter=" + encodeURIComponent("" + chiNhanhFilter) + "&"; 
        if (dVTFilter === null)
            throw new Error("The parameter 'dVTFilter' cannot be null.");
        else if (dVTFilter !== undefined)
            url_ += "DVTFilter=" + encodeURIComponent("" + dVTFilter) + "&"; 
        if (maxNgayKyHDKTHFilter === null)
            throw new Error("The parameter 'maxNgayKyHDKTHFilter' cannot be null.");
        else if (maxNgayKyHDKTHFilter !== undefined)
            url_ += "MaxNgayKyHDKTHFilter=" + encodeURIComponent(maxNgayKyHDKTHFilter ? "" + maxNgayKyHDKTHFilter.toJSON() : "") + "&"; 
        if (minNgayKyHDKTHFilter === null)
            throw new Error("The parameter 'minNgayKyHDKTHFilter' cannot be null.");
        else if (minNgayKyHDKTHFilter !== undefined)
            url_ += "MinNgayKyHDKTHFilter=" + encodeURIComponent(minNgayKyHDKTHFilter ? "" + minNgayKyHDKTHFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHD36THFilter === null)
            throw new Error("The parameter 'maxNgayKyHD36THFilter' cannot be null.");
        else if (maxNgayKyHD36THFilter !== undefined)
            url_ += "MaxNgayKyHD36THFilter=" + encodeURIComponent(maxNgayKyHD36THFilter ? "" + maxNgayKyHD36THFilter.toJSON() : "") + "&"; 
        if (minNgayKyHD36THFilter === null)
            throw new Error("The parameter 'minNgayKyHD36THFilter' cannot be null.");
        else if (minNgayKyHD36THFilter !== undefined)
            url_ += "MinNgayKyHD36THFilter=" + encodeURIComponent(minNgayKyHD36THFilter ? "" + minNgayKyHD36THFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHD12THFilter === null)
            throw new Error("The parameter 'maxNgayKyHD12THFilter' cannot be null.");
        else if (maxNgayKyHD12THFilter !== undefined)
            url_ += "MaxNgayKyHD12THFilter=" + encodeURIComponent(maxNgayKyHD12THFilter ? "" + maxNgayKyHD12THFilter.toJSON() : "") + "&"; 
        if (minNgayKyHD12THFilter === null)
            throw new Error("The parameter 'minNgayKyHD12THFilter' cannot be null.");
        else if (minNgayKyHD12THFilter !== undefined)
            url_ += "MinNgayKyHD12THFilter=" + encodeURIComponent(minNgayKyHD12THFilter ? "" + minNgayKyHD12THFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHDTVFilter === null)
            throw new Error("The parameter 'maxNgayKyHDTVFilter' cannot be null.");
        else if (maxNgayKyHDTVFilter !== undefined)
            url_ += "MaxNgayKyHDTVFilter=" + encodeURIComponent(maxNgayKyHDTVFilter ? "" + maxNgayKyHDTVFilter.toJSON() : "") + "&"; 
        if (minNgayKyHDTVFilter === null)
            throw new Error("The parameter 'minNgayKyHDTVFilter' cannot be null.");
        else if (minNgayKyHDTVFilter !== undefined)
            url_ += "MinNgayKyHDTVFilter=" + encodeURIComponent(minNgayKyHDTVFilter ? "" + minNgayKyHDTVFilter.toJSON() : "") + "&"; 
        if (maxNgayKYHDCTVFilter === null)
            throw new Error("The parameter 'maxNgayKYHDCTVFilter' cannot be null.");
        else if (maxNgayKYHDCTVFilter !== undefined)
            url_ += "MaxNgayKYHDCTVFilter=" + encodeURIComponent(maxNgayKYHDCTVFilter ? "" + maxNgayKYHDCTVFilter.toJSON() : "") + "&"; 
        if (minNgayKYHDCTVFilter === null)
            throw new Error("The parameter 'minNgayKYHDCTVFilter' cannot be null.");
        else if (minNgayKYHDCTVFilter !== undefined)
            url_ += "MinNgayKYHDCTVFilter=" + encodeURIComponent(minNgayKYHDCTVFilter ? "" + minNgayKYHDCTVFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHDKVFilter === null)
            throw new Error("The parameter 'maxNgayKyHDKVFilter' cannot be null.");
        else if (maxNgayKyHDKVFilter !== undefined)
            url_ += "MaxNgayKyHDKVFilter=" + encodeURIComponent(maxNgayKyHDKVFilter ? "" + maxNgayKyHDKVFilter.toJSON() : "") + "&"; 
        if (minNgayKyHDKVFilter === null)
            throw new Error("The parameter 'minNgayKyHDKVFilter' cannot be null.");
        else if (minNgayKyHDKVFilter !== undefined)
            url_ += "MinNgayKyHDKVFilter=" + encodeURIComponent(minNgayKyHDKVFilter ? "" + minNgayKyHDKVFilter.toJSON() : "") + "&"; 
        if (maxNgayKYHDTTFilter === null)
            throw new Error("The parameter 'maxNgayKYHDTTFilter' cannot be null.");
        else if (maxNgayKYHDTTFilter !== undefined)
            url_ += "MaxNgayKYHDTTFilter=" + encodeURIComponent(maxNgayKYHDTTFilter ? "" + maxNgayKYHDTTFilter.toJSON() : "") + "&"; 
        if (minNgayKYHDTTFilter === null)
            throw new Error("The parameter 'minNgayKYHDTTFilter' cannot be null.");
        else if (minNgayKYHDTTFilter !== undefined)
            url_ += "MinNgayKYHDTTFilter=" + encodeURIComponent(minNgayKYHDTTFilter ? "" + minNgayKYHDTTFilter.toJSON() : "") + "&"; 
        if (maxNgayKyHDFilter === null)
            throw new Error("The parameter 'maxNgayKyHDFilter' cannot be null.");
        else if (maxNgayKyHDFilter !== undefined)
            url_ += "MaxNgayKyHDFilter=" + encodeURIComponent(maxNgayKyHDFilter ? "" + maxNgayKyHDFilter.toJSON() : "") + "&"; 
        if (minNgayKyHDFilter === null)
            throw new Error("The parameter 'minNgayKyHDFilter' cannot be null.");
        else if (minNgayKyHDFilter !== undefined)
            url_ += "MinNgayKyHDFilter=" + encodeURIComponent(minNgayKyHDFilter ? "" + minNgayKyHDFilter.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViTriCongViecsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViTriCongViecsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetViTriCongViecsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WordProcessingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param receivePlaceFilter (optional) 
     * @param nameFilter (optional) 
     * @param contentFilter (optional) 
     * @param statusFilter (optional) 
     * @param commentFilter (optional) 
     * @param maxKeyWordIdFilter (optional) 
     * @param minKeyWordIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, receivePlaceFilter: string | undefined, nameFilter: string | undefined, contentFilter: string | undefined, statusFilter: string | undefined, commentFilter: string | undefined, maxKeyWordIdFilter: number | undefined, minKeyWordIdFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetWordProcessingForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WordProcessings/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (receivePlaceFilter === null)
            throw new Error("The parameter 'receivePlaceFilter' cannot be null.");
        else if (receivePlaceFilter !== undefined)
            url_ += "ReceivePlaceFilter=" + encodeURIComponent("" + receivePlaceFilter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (contentFilter === null)
            throw new Error("The parameter 'contentFilter' cannot be null.");
        else if (contentFilter !== undefined)
            url_ += "ContentFilter=" + encodeURIComponent("" + contentFilter) + "&"; 
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (commentFilter === null)
            throw new Error("The parameter 'commentFilter' cannot be null.");
        else if (commentFilter !== undefined)
            url_ += "CommentFilter=" + encodeURIComponent("" + commentFilter) + "&"; 
        if (maxKeyWordIdFilter === null)
            throw new Error("The parameter 'maxKeyWordIdFilter' cannot be null.");
        else if (maxKeyWordIdFilter !== undefined)
            url_ += "MaxKeyWordIdFilter=" + encodeURIComponent("" + maxKeyWordIdFilter) + "&"; 
        if (minKeyWordIdFilter === null)
            throw new Error("The parameter 'minKeyWordIdFilter' cannot be null.");
        else if (minKeyWordIdFilter !== undefined)
            url_ += "MinKeyWordIdFilter=" + encodeURIComponent("" + minKeyWordIdFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWordProcessingForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWordProcessingForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWordProcessingForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWordProcessingForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWordProcessingForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWordProcessingForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWordProcessingForView(id: number | undefined): Observable<GetWordProcessingForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WordProcessings/GetWordProcessingForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWordProcessingForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWordProcessingForView(<any>response_);
                } catch (e) {
                    return <Observable<GetWordProcessingForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWordProcessingForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWordProcessingForView(response: HttpResponseBase): Observable<GetWordProcessingForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWordProcessingForViewDto.fromJS(resultData200) : new GetWordProcessingForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWordProcessingForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWordProcessingForEdit(id: number | undefined): Observable<GetWordProcessingForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WordProcessings/GetWordProcessingForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWordProcessingForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWordProcessingForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWordProcessingForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWordProcessingForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWordProcessingForEdit(response: HttpResponseBase): Observable<GetWordProcessingForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWordProcessingForEditOutput.fromJS(resultData200) : new GetWordProcessingForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWordProcessingForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditWordProcessingDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WordProcessings/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WordProcessings/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param receivePlaceFilter (optional) 
     * @param nameFilter (optional) 
     * @param contentFilter (optional) 
     * @param statusFilter (optional) 
     * @param commentFilter (optional) 
     * @param maxKeyWordIdFilter (optional) 
     * @param minKeyWordIdFilter (optional) 
     * @return Success
     */
    getWordProcessingsToExcel(filter: string | undefined, receivePlaceFilter: string | undefined, nameFilter: string | undefined, contentFilter: string | undefined, statusFilter: string | undefined, commentFilter: string | undefined, maxKeyWordIdFilter: number | undefined, minKeyWordIdFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WordProcessings/GetWordProcessingsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (receivePlaceFilter === null)
            throw new Error("The parameter 'receivePlaceFilter' cannot be null.");
        else if (receivePlaceFilter !== undefined)
            url_ += "ReceivePlaceFilter=" + encodeURIComponent("" + receivePlaceFilter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (contentFilter === null)
            throw new Error("The parameter 'contentFilter' cannot be null.");
        else if (contentFilter !== undefined)
            url_ += "ContentFilter=" + encodeURIComponent("" + contentFilter) + "&"; 
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (commentFilter === null)
            throw new Error("The parameter 'commentFilter' cannot be null.");
        else if (commentFilter !== undefined)
            url_ += "CommentFilter=" + encodeURIComponent("" + commentFilter) + "&"; 
        if (maxKeyWordIdFilter === null)
            throw new Error("The parameter 'maxKeyWordIdFilter' cannot be null.");
        else if (maxKeyWordIdFilter !== undefined)
            url_ += "MaxKeyWordIdFilter=" + encodeURIComponent("" + maxKeyWordIdFilter) + "&"; 
        if (minKeyWordIdFilter === null)
            throw new Error("The parameter 'minKeyWordIdFilter' cannot be null.");
        else if (minKeyWordIdFilter !== undefined)
            url_ += "MinKeyWordIdFilter=" + encodeURIComponent("" + minKeyWordIdFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWordProcessingsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWordProcessingsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWordProcessingsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WorkAssignsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param assigneeFilter (optional) 
     * @param maxProgressFilter (optional) 
     * @param minProgressFilter (optional) 
     * @param statusFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param actionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, maxStartDateFilter: moment.Moment | undefined, minStartDateFilter: moment.Moment | undefined, maxEndDateFilter: moment.Moment | undefined, minEndDateFilter: moment.Moment | undefined, assigneeFilter: string | undefined, maxProgressFilter: number | undefined, minProgressFilter: number | undefined, statusFilter: string | undefined, descriptionFilter: string | undefined, actionFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetWorkAssignForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssigns/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (assigneeFilter === null)
            throw new Error("The parameter 'assigneeFilter' cannot be null.");
        else if (assigneeFilter !== undefined)
            url_ += "AssigneeFilter=" + encodeURIComponent("" + assigneeFilter) + "&"; 
        if (maxProgressFilter === null)
            throw new Error("The parameter 'maxProgressFilter' cannot be null.");
        else if (maxProgressFilter !== undefined)
            url_ += "MaxProgressFilter=" + encodeURIComponent("" + maxProgressFilter) + "&"; 
        if (minProgressFilter === null)
            throw new Error("The parameter 'minProgressFilter' cannot be null.");
        else if (minProgressFilter !== undefined)
            url_ += "MinProgressFilter=" + encodeURIComponent("" + minProgressFilter) + "&"; 
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (actionFilter === null)
            throw new Error("The parameter 'actionFilter' cannot be null.");
        else if (actionFilter !== undefined)
            url_ += "ActionFilter=" + encodeURIComponent("" + actionFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWorkAssignForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWorkAssignForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWorkAssignForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWorkAssignForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWorkAssignForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWorkAssignForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkAssignForView(id: number | undefined): Observable<GetWorkAssignForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssigns/GetWorkAssignForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkAssignForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkAssignForView(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkAssignForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkAssignForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkAssignForView(response: HttpResponseBase): Observable<GetWorkAssignForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWorkAssignForViewDto.fromJS(resultData200) : new GetWorkAssignForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkAssignForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkAssignForEdit(id: number | undefined): Observable<GetWorkAssignForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssigns/GetWorkAssignForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkAssignForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkAssignForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkAssignForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkAssignForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkAssignForEdit(response: HttpResponseBase): Observable<GetWorkAssignForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWorkAssignForEditOutput.fromJS(resultData200) : new GetWorkAssignForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkAssignForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditWorkAssignDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssigns/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssigns/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param assigneeFilter (optional) 
     * @param maxProgressFilter (optional) 
     * @param minProgressFilter (optional) 
     * @param statusFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param actionFilter (optional) 
     * @return Success
     */
    getWorkAssignsToExcel(filter: string | undefined, nameFilter: string | undefined, maxStartDateFilter: moment.Moment | undefined, minStartDateFilter: moment.Moment | undefined, maxEndDateFilter: moment.Moment | undefined, minEndDateFilter: moment.Moment | undefined, assigneeFilter: string | undefined, maxProgressFilter: number | undefined, minProgressFilter: number | undefined, statusFilter: string | undefined, descriptionFilter: string | undefined, actionFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssigns/GetWorkAssignsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (assigneeFilter === null)
            throw new Error("The parameter 'assigneeFilter' cannot be null.");
        else if (assigneeFilter !== undefined)
            url_ += "AssigneeFilter=" + encodeURIComponent("" + assigneeFilter) + "&"; 
        if (maxProgressFilter === null)
            throw new Error("The parameter 'maxProgressFilter' cannot be null.");
        else if (maxProgressFilter !== undefined)
            url_ += "MaxProgressFilter=" + encodeURIComponent("" + maxProgressFilter) + "&"; 
        if (minProgressFilter === null)
            throw new Error("The parameter 'minProgressFilter' cannot be null.");
        else if (minProgressFilter !== undefined)
            url_ += "MinProgressFilter=" + encodeURIComponent("" + minProgressFilter) + "&"; 
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (actionFilter === null)
            throw new Error("The parameter 'actionFilter' cannot be null.");
        else if (actionFilter !== undefined)
            url_ += "ActionFilter=" + encodeURIComponent("" + actionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkAssignsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkAssignsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkAssignsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WorkDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxWorkAssignIdFilter (optional) 
     * @param minWorkAssignIdFilter (optional) 
     * @param maxDonePersentageFilter (optional) 
     * @param minDonePersentageFilter (optional) 
     * @param maxDateFilter (optional) 
     * @param minDateFilter (optional) 
     * @param nameIDFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param repplyFilter (optional) 
     * @param attachmentFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxWorkAssignIdFilter: number | undefined, minWorkAssignIdFilter: number | undefined, maxDonePersentageFilter: number | undefined, minDonePersentageFilter: number | undefined, maxDateFilter: moment.Moment | undefined, minDateFilter: moment.Moment | undefined, nameIDFilter: string | undefined, descriptionFilter: string | undefined, repplyFilter: string | undefined, attachmentFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetWorkDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDetails/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxWorkAssignIdFilter === null)
            throw new Error("The parameter 'maxWorkAssignIdFilter' cannot be null.");
        else if (maxWorkAssignIdFilter !== undefined)
            url_ += "MaxWorkAssignIdFilter=" + encodeURIComponent("" + maxWorkAssignIdFilter) + "&"; 
        if (minWorkAssignIdFilter === null)
            throw new Error("The parameter 'minWorkAssignIdFilter' cannot be null.");
        else if (minWorkAssignIdFilter !== undefined)
            url_ += "MinWorkAssignIdFilter=" + encodeURIComponent("" + minWorkAssignIdFilter) + "&"; 
        if (maxDonePersentageFilter === null)
            throw new Error("The parameter 'maxDonePersentageFilter' cannot be null.");
        else if (maxDonePersentageFilter !== undefined)
            url_ += "MaxDonePersentageFilter=" + encodeURIComponent("" + maxDonePersentageFilter) + "&"; 
        if (minDonePersentageFilter === null)
            throw new Error("The parameter 'minDonePersentageFilter' cannot be null.");
        else if (minDonePersentageFilter !== undefined)
            url_ += "MinDonePersentageFilter=" + encodeURIComponent("" + minDonePersentageFilter) + "&"; 
        if (maxDateFilter === null)
            throw new Error("The parameter 'maxDateFilter' cannot be null.");
        else if (maxDateFilter !== undefined)
            url_ += "MaxDateFilter=" + encodeURIComponent(maxDateFilter ? "" + maxDateFilter.toJSON() : "") + "&"; 
        if (minDateFilter === null)
            throw new Error("The parameter 'minDateFilter' cannot be null.");
        else if (minDateFilter !== undefined)
            url_ += "MinDateFilter=" + encodeURIComponent(minDateFilter ? "" + minDateFilter.toJSON() : "") + "&"; 
        if (nameIDFilter === null)
            throw new Error("The parameter 'nameIDFilter' cannot be null.");
        else if (nameIDFilter !== undefined)
            url_ += "NameIDFilter=" + encodeURIComponent("" + nameIDFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (repplyFilter === null)
            throw new Error("The parameter 'repplyFilter' cannot be null.");
        else if (repplyFilter !== undefined)
            url_ += "RepplyFilter=" + encodeURIComponent("" + repplyFilter) + "&"; 
        if (attachmentFilter === null)
            throw new Error("The parameter 'attachmentFilter' cannot be null.");
        else if (attachmentFilter !== undefined)
            url_ += "AttachmentFilter=" + encodeURIComponent("" + attachmentFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWorkDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWorkDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWorkDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWorkDetailForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWorkDetailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWorkDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkDetailForView(id: number | undefined): Observable<GetWorkDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDetails/GetWorkDetailForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkDetailForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkDetailForView(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkDetailForView(response: HttpResponseBase): Observable<GetWorkDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWorkDetailForViewDto.fromJS(resultData200) : new GetWorkDetailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkDetailForEdit(id: number | undefined): Observable<GetWorkDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WorkDetails/GetWorkDetailForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkDetailForEdit(response: HttpResponseBase): Observable<GetWorkDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWorkDetailForEditOutput.fromJS(resultData200) : new GetWorkDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkDetailForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditWorkDetailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkDetails/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxWorkAssignIdFilter (optional) 
     * @param minWorkAssignIdFilter (optional) 
     * @param maxDonePersentageFilter (optional) 
     * @param minDonePersentageFilter (optional) 
     * @param maxDateFilter (optional) 
     * @param minDateFilter (optional) 
     * @param nameIDFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param repplyFilter (optional) 
     * @param attachmentFilter (optional) 
     * @return Success
     */
    getWorkDetailsToExcel(filter: string | undefined, maxWorkAssignIdFilter: number | undefined, minWorkAssignIdFilter: number | undefined, maxDonePersentageFilter: number | undefined, minDonePersentageFilter: number | undefined, maxDateFilter: moment.Moment | undefined, minDateFilter: moment.Moment | undefined, nameIDFilter: string | undefined, descriptionFilter: string | undefined, repplyFilter: string | undefined, attachmentFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDetails/GetWorkDetailsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxWorkAssignIdFilter === null)
            throw new Error("The parameter 'maxWorkAssignIdFilter' cannot be null.");
        else if (maxWorkAssignIdFilter !== undefined)
            url_ += "MaxWorkAssignIdFilter=" + encodeURIComponent("" + maxWorkAssignIdFilter) + "&"; 
        if (minWorkAssignIdFilter === null)
            throw new Error("The parameter 'minWorkAssignIdFilter' cannot be null.");
        else if (minWorkAssignIdFilter !== undefined)
            url_ += "MinWorkAssignIdFilter=" + encodeURIComponent("" + minWorkAssignIdFilter) + "&"; 
        if (maxDonePersentageFilter === null)
            throw new Error("The parameter 'maxDonePersentageFilter' cannot be null.");
        else if (maxDonePersentageFilter !== undefined)
            url_ += "MaxDonePersentageFilter=" + encodeURIComponent("" + maxDonePersentageFilter) + "&"; 
        if (minDonePersentageFilter === null)
            throw new Error("The parameter 'minDonePersentageFilter' cannot be null.");
        else if (minDonePersentageFilter !== undefined)
            url_ += "MinDonePersentageFilter=" + encodeURIComponent("" + minDonePersentageFilter) + "&"; 
        if (maxDateFilter === null)
            throw new Error("The parameter 'maxDateFilter' cannot be null.");
        else if (maxDateFilter !== undefined)
            url_ += "MaxDateFilter=" + encodeURIComponent(maxDateFilter ? "" + maxDateFilter.toJSON() : "") + "&"; 
        if (minDateFilter === null)
            throw new Error("The parameter 'minDateFilter' cannot be null.");
        else if (minDateFilter !== undefined)
            url_ += "MinDateFilter=" + encodeURIComponent(minDateFilter ? "" + minDateFilter.toJSON() : "") + "&"; 
        if (nameIDFilter === null)
            throw new Error("The parameter 'nameIDFilter' cannot be null.");
        else if (nameIDFilter !== undefined)
            url_ += "NameIDFilter=" + encodeURIComponent("" + nameIDFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (repplyFilter === null)
            throw new Error("The parameter 'repplyFilter' cannot be null.");
        else if (repplyFilter !== undefined)
            url_ += "RepplyFilter=" + encodeURIComponent("" + repplyFilter) + "&"; 
        if (attachmentFilter === null)
            throw new Error("The parameter 'attachmentFilter' cannot be null.");
        else if (attachmentFilter !== undefined)
            url_ += "AttachmentFilter=" + encodeURIComponent("" + attachmentFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkDetailsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkDetailsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkDetailsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string | undefined;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string | undefined;
}

export enum TenantAvailabilityState {
    Available = 1, 
    InActive = 2, 
    NotFound = 3, 
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }

    clone(): ResolveTenantIdInput {
        const json = this.toJSON();
        let result = new ResolveTenantIdInput();
        result.init(json);
        return result;
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    password: string | undefined;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    password: string | undefined;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress: string | undefined;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendPasswordResetCodeInput {
        const json = this.toJSON();
        let result = new SendPasswordResetCodeInput();
        result.init(json);
        return result;
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string | undefined;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data; 
    }

    clone(): ResetPasswordInput {
        const json = this.toJSON();
        let result = new ResetPasswordInput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): ResetPasswordOutput {
        const json = this.toJSON();
        let result = new ResetPasswordOutput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress: string | undefined;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendEmailActivationLinkInput {
        const json = this.toJSON();
        let result = new SendEmailActivationLinkInput();
        result.init(json);
        return result;
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string | undefined;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    c: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }

    clone(): ActivateEmailInput {
        const json = this.toJSON();
        let result = new ActivateEmailInput();
        result.init(json);
        return result;
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId: number | undefined;
    userId: number;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): ImpersonateInput {
        const json = this.toJSON();
        let result = new ImpersonateInput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): ImpersonateOutput {
        const json = this.toJSON();
        let result = new ImpersonateOutput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }

    clone(): SwitchToLinkedAccountInput {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountInput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): SwitchToLinkedAccountOutput {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountOutput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class QueryResult implements IQueryResult {
    isSucceeded: boolean;
    data: Data[] | undefined;
    message: string | undefined;
    code: string | undefined;

    constructor(data?: IQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isSucceeded = data["isSucceeded"];
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(Data.fromJS(item));
            }
            this.message = data["message"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): QueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSucceeded"] = this.isSucceeded;
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["code"] = this.code;
        return data; 
    }

    clone(): QueryResult {
        const json = this.toJSON();
        let result = new QueryResult();
        result.init(json);
        return result;
    }
}

export interface IQueryResult {
    isSucceeded: boolean;
    data: Data[] | undefined;
    message: string | undefined;
    code: string | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }

    clone(): AuditLogListDto {
        const json = this.toJSON();
        let result = new AuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAuditLogListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;
}

export class FileDto implements IFileDto {
    fileName: string | undefined;
    fileType: string | undefined;
    fileToken: string | undefined;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    fileName: string | undefined;
    fileType: string | undefined;
    fileToken: string | undefined;
}

export class NameValueDto implements INameValueDto {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): NameValueDto {
        const json = this.toJSON();
        let result = new NameValueDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export enum EntityChangeType {
    Created = 0, 
    Updated = 1, 
    Deleted = 2, 
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    changeTypeName: string | undefined;
    entityChangeSetId: number;
    id: number;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            this.changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityChangeListDto {
        const json = this.toJSON();
        let result = new EntityChangeListDto();
        result.init(json);
        return result;
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    changeTypeName: string | undefined;
    entityChangeSetId: number;
    id: number;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfEntityChangeListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId: number;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityPropertyChangeDto {
        const json = this.toJSON();
        let result = new EntityPropertyChangeDto();
        result.init(json);
        return result;
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class CacheDto implements ICacheDto {
    name: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CacheDto {
        const json = this.toJSON();
        let result = new CacheDto();
        result.init(json);
        return result;
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfCacheDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfCacheDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfString {
        const json = this.toJSON();
        let result = new EntityDtoOfString();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class CommandDatasourceDto implements ICommandDatasourceDto {
    command: string | undefined;
    key: string | undefined;
    value: string | undefined;
    dynamicDatasourceId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: ICommandDatasourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.command = data["command"];
            this.key = data["key"];
            this.value = data["value"];
            this.dynamicDatasourceId = data["dynamicDatasourceId"];
            this.order = data["order"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CommandDatasourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommandDatasourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["command"] = this.command;
        data["key"] = this.key;
        data["value"] = this.value;
        data["dynamicDatasourceId"] = this.dynamicDatasourceId;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CommandDatasourceDto {
        const json = this.toJSON();
        let result = new CommandDatasourceDto();
        result.init(json);
        return result;
    }
}

export interface ICommandDatasourceDto {
    command: string | undefined;
    key: string | undefined;
    value: string | undefined;
    dynamicDatasourceId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number;
}

export class GetCommandDatasourceForViewDto implements IGetCommandDatasourceForViewDto {
    commandDatasource: CommandDatasourceDto;

    constructor(data?: IGetCommandDatasourceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.commandDatasource = new CommandDatasourceDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.commandDatasource = data["commandDatasource"] ? CommandDatasourceDto.fromJS(data["commandDatasource"]) : new CommandDatasourceDto();
        }
    }

    static fromJS(data: any): GetCommandDatasourceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCommandDatasourceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandDatasource"] = this.commandDatasource ? this.commandDatasource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCommandDatasourceForViewDto {
        const json = this.toJSON();
        let result = new GetCommandDatasourceForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetCommandDatasourceForViewDto {
    commandDatasource: CommandDatasourceDto;
}

export class PagedResultDtoOfGetCommandDatasourceForViewDto implements IPagedResultDtoOfGetCommandDatasourceForViewDto {
    totalCount: number;
    items: GetCommandDatasourceForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCommandDatasourceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetCommandDatasourceForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCommandDatasourceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCommandDatasourceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetCommandDatasourceForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetCommandDatasourceForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetCommandDatasourceForViewDto {
    totalCount: number;
    items: GetCommandDatasourceForViewDto[] | undefined;
}

export class CreateOrEditCommandDatasourceDto implements ICreateOrEditCommandDatasourceDto {
    command: string | undefined;
    key: string | undefined;
    value: string | undefined;
    dynamicDatasourceId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number | undefined;

    constructor(data?: ICreateOrEditCommandDatasourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.command = data["command"];
            this.key = data["key"];
            this.value = data["value"];
            this.dynamicDatasourceId = data["dynamicDatasourceId"];
            this.order = data["order"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCommandDatasourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCommandDatasourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["command"] = this.command;
        data["key"] = this.key;
        data["value"] = this.value;
        data["dynamicDatasourceId"] = this.dynamicDatasourceId;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditCommandDatasourceDto {
        const json = this.toJSON();
        let result = new CreateOrEditCommandDatasourceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditCommandDatasourceDto {
    command: string | undefined;
    key: string | undefined;
    value: string | undefined;
    dynamicDatasourceId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number | undefined;
}

export class GetCommandDatasourceForEditOutput implements IGetCommandDatasourceForEditOutput {
    commandDatasource: CreateOrEditCommandDatasourceDto;

    constructor(data?: IGetCommandDatasourceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.commandDatasource = new CreateOrEditCommandDatasourceDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.commandDatasource = data["commandDatasource"] ? CreateOrEditCommandDatasourceDto.fromJS(data["commandDatasource"]) : new CreateOrEditCommandDatasourceDto();
        }
    }

    static fromJS(data: any): GetCommandDatasourceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCommandDatasourceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandDatasource"] = this.commandDatasource ? this.commandDatasource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCommandDatasourceForEditOutput {
        const json = this.toJSON();
        let result = new GetCommandDatasourceForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCommandDatasourceForEditOutput {
    commandDatasource: CreateOrEditCommandDatasourceDto;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): SubscribableEditionComboboxItemDto {
        const json = this.toJSON();
        let result = new SubscribableEditionComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfSubscribableEditionComboboxItemDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }

    clone(): FindUsersInput {
        const json = this.toJSON();
        let result = new FindUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfNameValueDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): GetDefaultEditionNameOutput {
        const json = this.toJSON();
        let result = new GetDefaultEditionNameOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class ConfigEmailDto implements IConfigEmailDto {
    diaChiEmail: string | undefined;
    tenHienThi: string | undefined;
    diaChiIP: string | undefined;
    congSMTP: number;
    checkSSL: boolean;
    checkThongTin: boolean;
    tenMien: string | undefined;
    tenTruyCap: string | undefined;
    matKhau: string | undefined;
    tenCTY: string | undefined;
    id: number;

    constructor(data?: IConfigEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diaChiEmail = data["diaChiEmail"];
            this.tenHienThi = data["tenHienThi"];
            this.diaChiIP = data["diaChiIP"];
            this.congSMTP = data["congSMTP"];
            this.checkSSL = data["checkSSL"];
            this.checkThongTin = data["checkThongTin"];
            this.tenMien = data["tenMien"];
            this.tenTruyCap = data["tenTruyCap"];
            this.matKhau = data["matKhau"];
            this.tenCTY = data["tenCTY"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ConfigEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diaChiEmail"] = this.diaChiEmail;
        data["tenHienThi"] = this.tenHienThi;
        data["diaChiIP"] = this.diaChiIP;
        data["congSMTP"] = this.congSMTP;
        data["checkSSL"] = this.checkSSL;
        data["checkThongTin"] = this.checkThongTin;
        data["tenMien"] = this.tenMien;
        data["tenTruyCap"] = this.tenTruyCap;
        data["matKhau"] = this.matKhau;
        data["tenCTY"] = this.tenCTY;
        data["id"] = this.id;
        return data; 
    }

    clone(): ConfigEmailDto {
        const json = this.toJSON();
        let result = new ConfigEmailDto();
        result.init(json);
        return result;
    }
}

export interface IConfigEmailDto {
    diaChiEmail: string | undefined;
    tenHienThi: string | undefined;
    diaChiIP: string | undefined;
    congSMTP: number;
    checkSSL: boolean;
    checkThongTin: boolean;
    tenMien: string | undefined;
    tenTruyCap: string | undefined;
    matKhau: string | undefined;
    tenCTY: string | undefined;
    id: number;
}

export class GetConfigEmailForViewDto implements IGetConfigEmailForViewDto {
    configEmail: ConfigEmailDto;

    constructor(data?: IGetConfigEmailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.configEmail = new ConfigEmailDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.configEmail = data["configEmail"] ? ConfigEmailDto.fromJS(data["configEmail"]) : new ConfigEmailDto();
        }
    }

    static fromJS(data: any): GetConfigEmailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetConfigEmailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configEmail"] = this.configEmail ? this.configEmail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetConfigEmailForViewDto {
        const json = this.toJSON();
        let result = new GetConfigEmailForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetConfigEmailForViewDto {
    configEmail: ConfigEmailDto;
}

export class PagedResultDtoOfGetConfigEmailForViewDto implements IPagedResultDtoOfGetConfigEmailForViewDto {
    totalCount: number;
    items: GetConfigEmailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetConfigEmailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetConfigEmailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetConfigEmailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetConfigEmailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetConfigEmailForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetConfigEmailForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetConfigEmailForViewDto {
    totalCount: number;
    items: GetConfigEmailForViewDto[] | undefined;
}

export class CreateOrEditConfigEmailDto implements ICreateOrEditConfigEmailDto {
    diaChiEmail: string | undefined;
    tenHienThi: string | undefined;
    diaChiIP: string | undefined;
    congSMTP: number;
    checkSSL: boolean;
    checkThongTin: boolean;
    tenMien: string | undefined;
    tenTruyCap: string | undefined;
    matKhau: string | undefined;
    tenCTY: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditConfigEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diaChiEmail = data["diaChiEmail"];
            this.tenHienThi = data["tenHienThi"];
            this.diaChiIP = data["diaChiIP"];
            this.congSMTP = data["congSMTP"];
            this.checkSSL = data["checkSSL"];
            this.checkThongTin = data["checkThongTin"];
            this.tenMien = data["tenMien"];
            this.tenTruyCap = data["tenTruyCap"];
            this.matKhau = data["matKhau"];
            this.tenCTY = data["tenCTY"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditConfigEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditConfigEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diaChiEmail"] = this.diaChiEmail;
        data["tenHienThi"] = this.tenHienThi;
        data["diaChiIP"] = this.diaChiIP;
        data["congSMTP"] = this.congSMTP;
        data["checkSSL"] = this.checkSSL;
        data["checkThongTin"] = this.checkThongTin;
        data["tenMien"] = this.tenMien;
        data["tenTruyCap"] = this.tenTruyCap;
        data["matKhau"] = this.matKhau;
        data["tenCTY"] = this.tenCTY;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditConfigEmailDto {
        const json = this.toJSON();
        let result = new CreateOrEditConfigEmailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditConfigEmailDto {
    diaChiEmail: string | undefined;
    tenHienThi: string | undefined;
    diaChiIP: string | undefined;
    congSMTP: number;
    checkSSL: boolean;
    checkThongTin: boolean;
    tenMien: string | undefined;
    tenTruyCap: string | undefined;
    matKhau: string | undefined;
    tenCTY: string | undefined;
    id: number | undefined;
}

export class GetConfigEmailForEditOutput implements IGetConfigEmailForEditOutput {
    configEmail: CreateOrEditConfigEmailDto;

    constructor(data?: IGetConfigEmailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.configEmail = new CreateOrEditConfigEmailDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.configEmail = data["configEmail"] ? CreateOrEditConfigEmailDto.fromJS(data["configEmail"]) : new CreateOrEditConfigEmailDto();
        }
    }

    static fromJS(data: any): GetConfigEmailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetConfigEmailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configEmail"] = this.configEmail ? this.configEmail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetConfigEmailForEditOutput {
        const json = this.toJSON();
        let result = new GetConfigEmailForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetConfigEmailForEditOutput {
    configEmail: CreateOrEditConfigEmailDto;
}

export enum FriendshipState {
    Accepted = 1, 
    Blocked = 2, 
}

export class FriendDto implements IFriendDto {
    friendUserId: number;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendshipState;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }

    clone(): FriendDto {
        const json = this.toJSON();
        let result = new FriendDto();
        result.init(json);
        return result;
    }
}

export interface IFriendDto {
    friendUserId: number;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendshipState;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment;
    friends: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [];
                for (let item of data["friends"])
                    this.friends.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetUserChatFriendsWithSettingsOutput {
        const json = this.toJSON();
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment;
    friends: FriendDto[] | undefined;
}

export enum ChatSide {
    Sender = 1, 
    Receiver = 2, 
}

export enum ChatMessageReadState {
    Unread = 1, 
    Read = 2, 
}

export class ChatMessageDto implements IChatMessageDto {
    userId: number;
    tenantId: number | undefined;
    targetUserId: number;
    targetTenantId: number | undefined;
    side: ChatSide;
    readState: ChatMessageReadState;
    receiverReadState: ChatMessageReadState;
    message: string | undefined;
    creationTime: moment.Moment;
    sharedMessageId: string | undefined;
    id: number;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ChatMessageDto {
        const json = this.toJSON();
        let result = new ChatMessageDto();
        result.init(json);
        return result;
    }
}

export interface IChatMessageDto {
    userId: number;
    tenantId: number | undefined;
    targetUserId: number;
    targetTenantId: number | undefined;
    side: ChatSide;
    readState: ChatMessageReadState;
    receiverReadState: ChatMessageReadState;
    message: string | undefined;
    creationTime: moment.Moment;
    sharedMessageId: string | undefined;
    id: number;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfChatMessageDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfChatMessageDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): MarkAllUnreadMessagesOfUserAsReadInput {
        const json = this.toJSON();
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(json);
        return result;
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number;
}

export class DangKyKCBDto implements IDangKyKCBDto {
    tenNoiKCB: string | undefined;
    maNoiKCB: string | undefined;
    diaChi: string | undefined;
    tinhThanhID: number | undefined;
    ghiChu: string | undefined;
    id: number;

    constructor(data?: IDangKyKCBDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenNoiKCB = data["tenNoiKCB"];
            this.maNoiKCB = data["maNoiKCB"];
            this.diaChi = data["diaChi"];
            this.tinhThanhID = data["tinhThanhID"];
            this.ghiChu = data["ghiChu"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DangKyKCBDto {
        data = typeof data === 'object' ? data : {};
        let result = new DangKyKCBDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenNoiKCB"] = this.tenNoiKCB;
        data["maNoiKCB"] = this.maNoiKCB;
        data["diaChi"] = this.diaChi;
        data["tinhThanhID"] = this.tinhThanhID;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): DangKyKCBDto {
        const json = this.toJSON();
        let result = new DangKyKCBDto();
        result.init(json);
        return result;
    }
}

export interface IDangKyKCBDto {
    tenNoiKCB: string | undefined;
    maNoiKCB: string | undefined;
    diaChi: string | undefined;
    tinhThanhID: number | undefined;
    ghiChu: string | undefined;
    id: number;
}

export class GetDangKyKCBForViewDto implements IGetDangKyKCBForViewDto {
    dangKyKCB: DangKyKCBDto;

    constructor(data?: IGetDangKyKCBForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dangKyKCB = new DangKyKCBDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dangKyKCB = data["dangKyKCB"] ? DangKyKCBDto.fromJS(data["dangKyKCB"]) : new DangKyKCBDto();
        }
    }

    static fromJS(data: any): GetDangKyKCBForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDangKyKCBForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dangKyKCB"] = this.dangKyKCB ? this.dangKyKCB.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDangKyKCBForViewDto {
        const json = this.toJSON();
        let result = new GetDangKyKCBForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetDangKyKCBForViewDto {
    dangKyKCB: DangKyKCBDto;
}

export class PagedResultDtoOfGetDangKyKCBForViewDto implements IPagedResultDtoOfGetDangKyKCBForViewDto {
    totalCount: number;
    items: GetDangKyKCBForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDangKyKCBForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetDangKyKCBForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDangKyKCBForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDangKyKCBForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetDangKyKCBForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetDangKyKCBForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetDangKyKCBForViewDto {
    totalCount: number;
    items: GetDangKyKCBForViewDto[] | undefined;
}

export class CreateOrEditDangKyKCBDto implements ICreateOrEditDangKyKCBDto {
    tenNoiKCB: string | undefined;
    maNoiKCB: string | undefined;
    diaChi: string | undefined;
    tinhThanhID: number | undefined;
    ghiChu: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditDangKyKCBDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenNoiKCB = data["tenNoiKCB"];
            this.maNoiKCB = data["maNoiKCB"];
            this.diaChi = data["diaChi"];
            this.tinhThanhID = data["tinhThanhID"];
            this.ghiChu = data["ghiChu"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDangKyKCBDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDangKyKCBDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenNoiKCB"] = this.tenNoiKCB;
        data["maNoiKCB"] = this.maNoiKCB;
        data["diaChi"] = this.diaChi;
        data["tinhThanhID"] = this.tinhThanhID;
        data["ghiChu"] = this.ghiChu;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDangKyKCBDto {
        const json = this.toJSON();
        let result = new CreateOrEditDangKyKCBDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDangKyKCBDto {
    tenNoiKCB: string | undefined;
    maNoiKCB: string | undefined;
    diaChi: string | undefined;
    tinhThanhID: number | undefined;
    ghiChu: string | undefined;
    id: number | undefined;
}

export class GetDangKyKCBForEditOutput implements IGetDangKyKCBForEditOutput {
    dangKyKCB: CreateOrEditDangKyKCBDto;

    constructor(data?: IGetDangKyKCBForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dangKyKCB = new CreateOrEditDangKyKCBDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dangKyKCB = data["dangKyKCB"] ? CreateOrEditDangKyKCBDto.fromJS(data["dangKyKCB"]) : new CreateOrEditDangKyKCBDto();
        }
    }

    static fromJS(data: any): GetDangKyKCBForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDangKyKCBForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dangKyKCB"] = this.dangKyKCB ? this.dangKyKCB.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDangKyKCBForEditOutput {
        const json = this.toJSON();
        let result = new GetDangKyKCBForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDangKyKCBForEditOutput {
    dangKyKCB: CreateOrEditDangKyKCBDto;
}

export class Widget implements IWidget {
    widgetId: string | undefined;
    height: number;
    width: number;
    positionX: number;
    positionY: number;

    constructor(data?: IWidget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.widgetId = data["widgetId"];
            this.height = data["height"];
            this.width = data["width"];
            this.positionX = data["positionX"];
            this.positionY = data["positionY"];
        }
    }

    static fromJS(data: any): Widget {
        data = typeof data === 'object' ? data : {};
        let result = new Widget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["height"] = this.height;
        data["width"] = this.width;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        return data; 
    }

    clone(): Widget {
        const json = this.toJSON();
        let result = new Widget();
        result.init(json);
        return result;
    }
}

export interface IWidget {
    widgetId: string | undefined;
    height: number;
    width: number;
    positionX: number;
    positionY: number;
}

export class Page implements IPage {
    id: string | undefined;
    name: string | undefined;
    widgets: Widget[] | undefined;

    constructor(data?: IPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            if (data["widgets"] && data["widgets"].constructor === Array) {
                this.widgets = [];
                for (let item of data["widgets"])
                    this.widgets.push(Widget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Page {
        data = typeof data === 'object' ? data : {};
        let result = new Page();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.widgets && this.widgets.constructor === Array) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Page {
        const json = this.toJSON();
        let result = new Page();
        result.init(json);
        return result;
    }
}

export interface IPage {
    id: string | undefined;
    name: string | undefined;
    widgets: Widget[] | undefined;
}

export class Dashboard implements IDashboard {
    dashboardName: string | undefined;
    pages: Page[] | undefined;

    constructor(data?: IDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dashboardName = data["dashboardName"];
            if (data["pages"] && data["pages"].constructor === Array) {
                this.pages = [];
                for (let item of data["pages"])
                    this.pages.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dashboard {
        data = typeof data === 'object' ? data : {};
        let result = new Dashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        if (this.pages && this.pages.constructor === Array) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Dashboard {
        const json = this.toJSON();
        let result = new Dashboard();
        result.init(json);
        return result;
    }
}

export interface IDashboard {
    dashboardName: string | undefined;
    pages: Page[] | undefined;
}

export class SavePageInput implements ISavePageInput {
    dashboardName: string | undefined;
    application: string | undefined;
    pages: Page[] | undefined;

    constructor(data?: ISavePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dashboardName = data["dashboardName"];
            this.application = data["application"];
            if (data["pages"] && data["pages"].constructor === Array) {
                this.pages = [];
                for (let item of data["pages"])
                    this.pages.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SavePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SavePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["application"] = this.application;
        if (this.pages && this.pages.constructor === Array) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SavePageInput {
        const json = this.toJSON();
        let result = new SavePageInput();
        result.init(json);
        return result;
    }
}

export interface ISavePageInput {
    dashboardName: string | undefined;
    application: string | undefined;
    pages: Page[] | undefined;
}

export class RenamePageInput implements IRenamePageInput {
    dashboardName: string | undefined;
    id: string | undefined;
    name: string | undefined;
    application: string | undefined;

    constructor(data?: IRenamePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dashboardName = data["dashboardName"];
            this.id = data["id"];
            this.name = data["name"];
            this.application = data["application"];
        }
    }

    static fromJS(data: any): RenamePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenamePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["id"] = this.id;
        data["name"] = this.name;
        data["application"] = this.application;
        return data; 
    }

    clone(): RenamePageInput {
        const json = this.toJSON();
        let result = new RenamePageInput();
        result.init(json);
        return result;
    }
}

export interface IRenamePageInput {
    dashboardName: string | undefined;
    id: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class AddNewPageInput implements IAddNewPageInput {
    dashboardName: string | undefined;
    name: string | undefined;
    application: string | undefined;

    constructor(data?: IAddNewPageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dashboardName = data["dashboardName"];
            this.name = data["name"];
            this.application = data["application"];
        }
    }

    static fromJS(data: any): AddNewPageInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["name"] = this.name;
        data["application"] = this.application;
        return data; 
    }

    clone(): AddNewPageInput {
        const json = this.toJSON();
        let result = new AddNewPageInput();
        result.init(json);
        return result;
    }
}

export interface IAddNewPageInput {
    dashboardName: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class AddNewPageOutput implements IAddNewPageOutput {
    pageId: string | undefined;

    constructor(data?: IAddNewPageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pageId = data["pageId"];
        }
    }

    static fromJS(data: any): AddNewPageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageId"] = this.pageId;
        return data; 
    }

    clone(): AddNewPageOutput {
        const json = this.toJSON();
        let result = new AddNewPageOutput();
        result.init(json);
        return result;
    }
}

export interface IAddNewPageOutput {
    pageId: string | undefined;
}

export class AddWidgetInput implements IAddWidgetInput {
    widgetId: string | undefined;
    pageId: string | undefined;
    dashboardName: string | undefined;
    width: number;
    height: number;
    application: string | undefined;

    constructor(data?: IAddWidgetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.widgetId = data["widgetId"];
            this.pageId = data["pageId"];
            this.dashboardName = data["dashboardName"];
            this.width = data["width"];
            this.height = data["height"];
            this.application = data["application"];
        }
    }

    static fromJS(data: any): AddWidgetInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddWidgetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["pageId"] = this.pageId;
        data["dashboardName"] = this.dashboardName;
        data["width"] = this.width;
        data["height"] = this.height;
        data["application"] = this.application;
        return data; 
    }

    clone(): AddWidgetInput {
        const json = this.toJSON();
        let result = new AddWidgetInput();
        result.init(json);
        return result;
    }
}

export interface IAddWidgetInput {
    widgetId: string | undefined;
    pageId: string | undefined;
    dashboardName: string | undefined;
    width: number;
    height: number;
    application: string | undefined;
}

export class WidgetFilterOutput implements IWidgetFilterOutput {
    id: string | undefined;
    name: string | undefined;

    constructor(data?: IWidgetFilterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): WidgetFilterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetFilterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): WidgetFilterOutput {
        const json = this.toJSON();
        let result = new WidgetFilterOutput();
        result.init(json);
        return result;
    }
}

export interface IWidgetFilterOutput {
    id: string | undefined;
    name: string | undefined;
}

export class WidgetOutput implements IWidgetOutput {
    id: string | undefined;
    name: string | undefined;
    description: string | undefined;
    filters: WidgetFilterOutput[] | undefined;

    constructor(data?: IWidgetOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            if (data["filters"] && data["filters"].constructor === Array) {
                this.filters = [];
                for (let item of data["filters"])
                    this.filters.push(WidgetFilterOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WidgetOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (this.filters && this.filters.constructor === Array) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data; 
    }

    clone(): WidgetOutput {
        const json = this.toJSON();
        let result = new WidgetOutput();
        result.init(json);
        return result;
    }
}

export interface IWidgetOutput {
    id: string | undefined;
    name: string | undefined;
    description: string | undefined;
    filters: WidgetFilterOutput[] | undefined;
}

export class DashboardOutput implements IDashboardOutput {
    name: string | undefined;
    widgets: WidgetOutput[] | undefined;

    constructor(data?: IDashboardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["widgets"] && data["widgets"].constructor === Array) {
                this.widgets = [];
                for (let item of data["widgets"])
                    this.widgets.push(WidgetOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.widgets && this.widgets.constructor === Array) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DashboardOutput {
        const json = this.toJSON();
        let result = new DashboardOutput();
        result.init(json);
        return result;
    }
}

export interface IDashboardOutput {
    name: string | undefined;
    widgets: WidgetOutput[] | undefined;
}

export class DataChamCongDto implements IDataChamCongDto {
    maChamCong: number;
    processDate: moment.Moment;
    checkTime: string | undefined;
    timeWorkDuration: number | undefined;
    timeViolatingRuleFirstDuration: number | undefined;
    timeViolatingRuleLastDuration: number | undefined;
    timeOTDuration: number | undefined;
    status: string | undefined;
    id: number;

    constructor(data?: IDataChamCongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maChamCong = data["maChamCong"];
            this.processDate = data["processDate"] ? moment(data["processDate"].toString()) : <any>undefined;
            this.checkTime = data["checkTime"];
            this.timeWorkDuration = data["timeWorkDuration"];
            this.timeViolatingRuleFirstDuration = data["timeViolatingRuleFirstDuration"];
            this.timeViolatingRuleLastDuration = data["timeViolatingRuleLastDuration"];
            this.timeOTDuration = data["timeOTDuration"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DataChamCongDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataChamCongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maChamCong"] = this.maChamCong;
        data["processDate"] = this.processDate ? this.processDate.toISOString() : <any>undefined;
        data["checkTime"] = this.checkTime;
        data["timeWorkDuration"] = this.timeWorkDuration;
        data["timeViolatingRuleFirstDuration"] = this.timeViolatingRuleFirstDuration;
        data["timeViolatingRuleLastDuration"] = this.timeViolatingRuleLastDuration;
        data["timeOTDuration"] = this.timeOTDuration;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): DataChamCongDto {
        const json = this.toJSON();
        let result = new DataChamCongDto();
        result.init(json);
        return result;
    }
}

export interface IDataChamCongDto {
    maChamCong: number;
    processDate: moment.Moment;
    checkTime: string | undefined;
    timeWorkDuration: number | undefined;
    timeViolatingRuleFirstDuration: number | undefined;
    timeViolatingRuleLastDuration: number | undefined;
    timeOTDuration: number | undefined;
    status: string | undefined;
    id: number;
}

export class GetDataChamCongForViewDto implements IGetDataChamCongForViewDto {
    dataChamCong: DataChamCongDto;
    rowIndex: number;
    maChamCong: string | undefined;
    maNhanVien: string | undefined;
    hoVaTen: string | undefined;
    tenCTy: string | undefined;
    donViCongTacName: string | undefined;
    chucDanh: string | undefined;
    processDate: moment.Moment;
    checkTime: string | undefined;
    checkTimeIn: string | undefined;
    checkTimeOut: string | undefined;
    timeViolatingRuleFirstDuration: number | undefined;
    timeViolatingRuleLastDuration: number | undefined;
    timeOTDuration: number | undefined;
    timeWorkDuration: number | undefined;
    workOffDate: string | undefined;
    missionDate: string | undefined;

    constructor(data?: IGetDataChamCongForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dataChamCong = new DataChamCongDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dataChamCong = data["dataChamCong"] ? DataChamCongDto.fromJS(data["dataChamCong"]) : new DataChamCongDto();
            this.rowIndex = data["rowIndex"];
            this.maChamCong = data["maChamCong"];
            this.maNhanVien = data["maNhanVien"];
            this.hoVaTen = data["hoVaTen"];
            this.tenCTy = data["tenCTy"];
            this.donViCongTacName = data["donViCongTacName"];
            this.chucDanh = data["chucDanh"];
            this.processDate = data["processDate"] ? moment(data["processDate"].toString()) : <any>undefined;
            this.checkTime = data["checkTime"];
            this.checkTimeIn = data["checkTimeIn"];
            this.checkTimeOut = data["checkTimeOut"];
            this.timeViolatingRuleFirstDuration = data["timeViolatingRuleFirstDuration"];
            this.timeViolatingRuleLastDuration = data["timeViolatingRuleLastDuration"];
            this.timeOTDuration = data["timeOTDuration"];
            this.timeWorkDuration = data["timeWorkDuration"];
            this.workOffDate = data["workOffDate"];
            this.missionDate = data["missionDate"];
        }
    }

    static fromJS(data: any): GetDataChamCongForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataChamCongForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataChamCong"] = this.dataChamCong ? this.dataChamCong.toJSON() : <any>undefined;
        data["rowIndex"] = this.rowIndex;
        data["maChamCong"] = this.maChamCong;
        data["maNhanVien"] = this.maNhanVien;
        data["hoVaTen"] = this.hoVaTen;
        data["tenCTy"] = this.tenCTy;
        data["donViCongTacName"] = this.donViCongTacName;
        data["chucDanh"] = this.chucDanh;
        data["processDate"] = this.processDate ? this.processDate.toISOString() : <any>undefined;
        data["checkTime"] = this.checkTime;
        data["checkTimeIn"] = this.checkTimeIn;
        data["checkTimeOut"] = this.checkTimeOut;
        data["timeViolatingRuleFirstDuration"] = this.timeViolatingRuleFirstDuration;
        data["timeViolatingRuleLastDuration"] = this.timeViolatingRuleLastDuration;
        data["timeOTDuration"] = this.timeOTDuration;
        data["timeWorkDuration"] = this.timeWorkDuration;
        data["workOffDate"] = this.workOffDate;
        data["missionDate"] = this.missionDate;
        return data; 
    }

    clone(): GetDataChamCongForViewDto {
        const json = this.toJSON();
        let result = new GetDataChamCongForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetDataChamCongForViewDto {
    dataChamCong: DataChamCongDto;
    rowIndex: number;
    maChamCong: string | undefined;
    maNhanVien: string | undefined;
    hoVaTen: string | undefined;
    tenCTy: string | undefined;
    donViCongTacName: string | undefined;
    chucDanh: string | undefined;
    processDate: moment.Moment;
    checkTime: string | undefined;
    checkTimeIn: string | undefined;
    checkTimeOut: string | undefined;
    timeViolatingRuleFirstDuration: number | undefined;
    timeViolatingRuleLastDuration: number | undefined;
    timeOTDuration: number | undefined;
    timeWorkDuration: number | undefined;
    workOffDate: string | undefined;
    missionDate: string | undefined;
}

export class PagedResultDtoOfGetDataChamCongForViewDto implements IPagedResultDtoOfGetDataChamCongForViewDto {
    totalCount: number;
    items: GetDataChamCongForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDataChamCongForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetDataChamCongForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDataChamCongForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDataChamCongForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetDataChamCongForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetDataChamCongForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetDataChamCongForViewDto {
    totalCount: number;
    items: GetDataChamCongForViewDto[] | undefined;
}

export class TruongGiaoDichDto implements ITruongGiaoDichDto {
    code: string | undefined;
    cdName: string | undefined;
    value: string | undefined;
    ghiChu: string | undefined;
    setDefault: boolean;
    displayOrder: number | undefined;
    id: number;

    constructor(data?: ITruongGiaoDichDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.cdName = data["cdName"];
            this.value = data["value"];
            this.ghiChu = data["ghiChu"];
            this.setDefault = data["setDefault"];
            this.displayOrder = data["displayOrder"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TruongGiaoDichDto {
        data = typeof data === 'object' ? data : {};
        let result = new TruongGiaoDichDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["cdName"] = this.cdName;
        data["value"] = this.value;
        data["ghiChu"] = this.ghiChu;
        data["setDefault"] = this.setDefault;
        data["displayOrder"] = this.displayOrder;
        data["id"] = this.id;
        return data; 
    }

    clone(): TruongGiaoDichDto {
        const json = this.toJSON();
        let result = new TruongGiaoDichDto();
        result.init(json);
        return result;
    }
}

export interface ITruongGiaoDichDto {
    code: string | undefined;
    cdName: string | undefined;
    value: string | undefined;
    ghiChu: string | undefined;
    setDefault: boolean;
    displayOrder: number | undefined;
    id: number;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.roleCount = data["roleCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DataChamCongFilter implements IDataChamCongFilter {
    congty: TruongGiaoDichDto[] | undefined;
    congViecList: OrganizationUnitDto[] | undefined;
    viTriCongViec: TruongGiaoDichDto[] | undefined;

    constructor(data?: IDataChamCongFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["congty"] && data["congty"].constructor === Array) {
                this.congty = [];
                for (let item of data["congty"])
                    this.congty.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["congViecList"] && data["congViecList"].constructor === Array) {
                this.congViecList = [];
                for (let item of data["congViecList"])
                    this.congViecList.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["viTriCongViec"] && data["viTriCongViec"].constructor === Array) {
                this.viTriCongViec = [];
                for (let item of data["viTriCongViec"])
                    this.viTriCongViec.push(TruongGiaoDichDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataChamCongFilter {
        data = typeof data === 'object' ? data : {};
        let result = new DataChamCongFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.congty && this.congty.constructor === Array) {
            data["congty"] = [];
            for (let item of this.congty)
                data["congty"].push(item.toJSON());
        }
        if (this.congViecList && this.congViecList.constructor === Array) {
            data["congViecList"] = [];
            for (let item of this.congViecList)
                data["congViecList"].push(item.toJSON());
        }
        if (this.viTriCongViec && this.viTriCongViec.constructor === Array) {
            data["viTriCongViec"] = [];
            for (let item of this.viTriCongViec)
                data["viTriCongViec"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DataChamCongFilter {
        const json = this.toJSON();
        let result = new DataChamCongFilter();
        result.init(json);
        return result;
    }
}

export interface IDataChamCongFilter {
    congty: TruongGiaoDichDto[] | undefined;
    congViecList: OrganizationUnitDto[] | undefined;
    viTriCongViec: TruongGiaoDichDto[] | undefined;
}

export class CreateOrEditDataChamCongDto implements ICreateOrEditDataChamCongDto {
    maChamCong: number;
    timeCheck: string | undefined;
    timeCheckDate: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditDataChamCongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maChamCong = data["maChamCong"];
            this.timeCheck = data["timeCheck"];
            this.timeCheckDate = data["timeCheckDate"] ? moment(data["timeCheckDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDataChamCongDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDataChamCongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maChamCong"] = this.maChamCong;
        data["timeCheck"] = this.timeCheck;
        data["timeCheckDate"] = this.timeCheckDate ? this.timeCheckDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDataChamCongDto {
        const json = this.toJSON();
        let result = new CreateOrEditDataChamCongDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDataChamCongDto {
    maChamCong: number;
    timeCheck: string | undefined;
    timeCheckDate: moment.Moment | undefined;
    id: number | undefined;
}

export class GetDataChamCongForEditOutput implements IGetDataChamCongForEditOutput {
    dataChamCong: CreateOrEditDataChamCongDto;

    constructor(data?: IGetDataChamCongForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dataChamCong = new CreateOrEditDataChamCongDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dataChamCong = data["dataChamCong"] ? CreateOrEditDataChamCongDto.fromJS(data["dataChamCong"]) : new CreateOrEditDataChamCongDto();
        }
    }

    static fromJS(data: any): GetDataChamCongForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataChamCongForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataChamCong"] = this.dataChamCong ? this.dataChamCong.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDataChamCongForEditOutput {
        const json = this.toJSON();
        let result = new GetDataChamCongForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDataChamCongForEditOutput {
    dataChamCong: CreateOrEditDataChamCongDto;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }

    clone(): DateToStringOutput {
        const json = this.toJSON();
        let result = new DateToStringOutput();
        result.init(json);
        return result;
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): NameValueOfString {
        const json = this.toJSON();
        let result = new NameValueOfString();
        result.init(json);
        return result;
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }

    clone(): StringOutput {
        const json = this.toJSON();
        let result = new StringOutput();
        result.init(json);
        return result;
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class DocumentsDto implements IDocumentsDto {
    id: number | undefined;
    number: string | undefined;
    documentTypeId: number;
    placeReceive: string | undefined;
    saveTo: string | undefined;
    summary: string | undefined;
    incommingNumber: number;
    priority: number | undefined;
    incommingDate: moment.Moment;
    pages: number;
    author: string | undefined;
    approvedBy: string | undefined;
    attachment: string | undefined;
    typeReceive: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    status: string | undefined;
    note: string | undefined;
    moreInformation: string | undefined;
    isActive: boolean;
    order: number;
    groupAuthor: string | undefined;
    range: string | undefined;
    position: string | undefined;
    linkedDocument: string | undefined;
    stt: number;
    action: number | undefined;

    constructor(data?: IDocumentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.number = data["number"];
            this.documentTypeId = data["documentTypeId"];
            this.placeReceive = data["placeReceive"];
            this.saveTo = data["saveTo"];
            this.summary = data["summary"];
            this.incommingNumber = data["incommingNumber"];
            this.priority = data["priority"];
            this.incommingDate = data["incommingDate"] ? moment(data["incommingDate"].toString()) : <any>undefined;
            this.pages = data["pages"];
            this.author = data["author"];
            this.approvedBy = data["approvedBy"];
            this.attachment = data["attachment"];
            this.typeReceive = data["typeReceive"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.note = data["note"];
            this.moreInformation = data["moreInformation"];
            this.isActive = data["isActive"];
            this.order = data["order"];
            this.groupAuthor = data["groupAuthor"];
            this.range = data["range"];
            this.position = data["position"];
            this.linkedDocument = data["linkedDocument"];
            this.stt = data["stt"];
            this.action = data["action"];
        }
    }

    static fromJS(data: any): DocumentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["documentTypeId"] = this.documentTypeId;
        data["placeReceive"] = this.placeReceive;
        data["saveTo"] = this.saveTo;
        data["summary"] = this.summary;
        data["incommingNumber"] = this.incommingNumber;
        data["priority"] = this.priority;
        data["incommingDate"] = this.incommingDate ? this.incommingDate.toISOString() : <any>undefined;
        data["pages"] = this.pages;
        data["author"] = this.author;
        data["approvedBy"] = this.approvedBy;
        data["attachment"] = this.attachment;
        data["typeReceive"] = this.typeReceive;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["note"] = this.note;
        data["moreInformation"] = this.moreInformation;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        data["groupAuthor"] = this.groupAuthor;
        data["range"] = this.range;
        data["position"] = this.position;
        data["linkedDocument"] = this.linkedDocument;
        data["stt"] = this.stt;
        data["action"] = this.action;
        return data; 
    }

    clone(): DocumentsDto {
        const json = this.toJSON();
        let result = new DocumentsDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentsDto {
    id: number | undefined;
    number: string | undefined;
    documentTypeId: number;
    placeReceive: string | undefined;
    saveTo: string | undefined;
    summary: string | undefined;
    incommingNumber: number;
    priority: number | undefined;
    incommingDate: moment.Moment;
    pages: number;
    author: string | undefined;
    approvedBy: string | undefined;
    attachment: string | undefined;
    typeReceive: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    status: string | undefined;
    note: string | undefined;
    moreInformation: string | undefined;
    isActive: boolean;
    order: number;
    groupAuthor: string | undefined;
    range: string | undefined;
    position: string | undefined;
    linkedDocument: string | undefined;
    stt: number;
    action: number | undefined;
}

export class GetDocumentsForViewDto implements IGetDocumentsForViewDto {
    documents: DocumentsDto;

    constructor(data?: IGetDocumentsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documents = new DocumentsDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.documents = data["documents"] ? DocumentsDto.fromJS(data["documents"]) : new DocumentsDto();
        }
    }

    static fromJS(data: any): GetDocumentsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documents"] = this.documents ? this.documents.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDocumentsForViewDto {
        const json = this.toJSON();
        let result = new GetDocumentsForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentsForViewDto {
    documents: DocumentsDto;
}

export class PagedResultDtoOfGetDocumentsForViewDto implements IPagedResultDtoOfGetDocumentsForViewDto {
    totalCount: number;
    items: GetDocumentsForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDocumentsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetDocumentsForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDocumentsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDocumentsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetDocumentsForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetDocumentsForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetDocumentsForViewDto {
    totalCount: number;
    items: GetDocumentsForViewDto[] | undefined;
}

export class DocumentDetailDto implements IDocumentDetailDto {
    documentId: number;
    datehandle: moment.Moment;
    typehandle: number;
    description: string | undefined;
    status: string | undefined;
    isStared: boolean;
    priority: string | undefined;
    id: number;

    constructor(data?: IDocumentDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.documentId = data["documentId"];
            this.datehandle = data["datehandle"] ? moment(data["datehandle"].toString()) : <any>undefined;
            this.typehandle = data["typehandle"];
            this.description = data["description"];
            this.status = data["status"];
            this.isStared = data["isStared"];
            this.priority = data["priority"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DocumentDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["datehandle"] = this.datehandle ? this.datehandle.toISOString() : <any>undefined;
        data["typehandle"] = this.typehandle;
        data["description"] = this.description;
        data["status"] = this.status;
        data["isStared"] = this.isStared;
        data["priority"] = this.priority;
        data["id"] = this.id;
        return data; 
    }

    clone(): DocumentDetailDto {
        const json = this.toJSON();
        let result = new DocumentDetailDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentDetailDto {
    documentId: number;
    datehandle: moment.Moment;
    typehandle: number;
    description: string | undefined;
    status: string | undefined;
    isStared: boolean;
    priority: string | undefined;
    id: number;
}

export class PagedResultDtoOfDocumentsDto implements IPagedResultDtoOfDocumentsDto {
    totalCount: number;
    items: DocumentsDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDocumentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DocumentsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDocumentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDocumentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDocumentsDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDocumentsDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDocumentsDto {
    totalCount: number;
    items: DocumentsDto[] | undefined;
}

export class CounterDto implements ICounterDto {
    code: string | undefined;
    number: number;

    constructor(data?: ICounterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.number = data["number"];
        }
    }

    static fromJS(data: any): CounterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["number"] = this.number;
        return data; 
    }

    clone(): CounterDto {
        const json = this.toJSON();
        let result = new CounterDto();
        result.init(json);
        return result;
    }
}

export interface ICounterDto {
    code: string | undefined;
    number: number;
}

export class DocumentHandlingDto implements IDocumentHandlingDto {
    documentId: number;
    handler: string | undefined;
    handlingDetailId: number | undefined;
    documentDetailId: number;
    placeReceive: string | undefined;
    content: string | undefined;
    status: string | undefined;
    comment: string | undefined;
    creationTime: moment.Moment;
    endDate: moment.Moment | undefined;
    id: number;

    constructor(data?: IDocumentHandlingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.documentId = data["documentId"];
            this.handler = data["handler"];
            this.handlingDetailId = data["handlingDetailId"];
            this.documentDetailId = data["documentDetailId"];
            this.placeReceive = data["placeReceive"];
            this.content = data["content"];
            this.status = data["status"];
            this.comment = data["comment"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DocumentHandlingDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHandlingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["handler"] = this.handler;
        data["handlingDetailId"] = this.handlingDetailId;
        data["documentDetailId"] = this.documentDetailId;
        data["placeReceive"] = this.placeReceive;
        data["content"] = this.content;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): DocumentHandlingDto {
        const json = this.toJSON();
        let result = new DocumentHandlingDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentHandlingDto {
    documentId: number;
    handler: string | undefined;
    handlingDetailId: number | undefined;
    documentDetailId: number;
    placeReceive: string | undefined;
    content: string | undefined;
    status: string | undefined;
    comment: string | undefined;
    creationTime: moment.Moment;
    endDate: moment.Moment | undefined;
    id: number;
}

export class Document_Waitting implements IDocument_Waitting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: string | undefined;
    lastModificationTime: moment.Moment;
    lastModifierUserId: string | undefined;
    isDeleted: string | undefined;
    deleterUserId: string | undefined;
    deletionTime: moment.Moment;
    tenantId: string | undefined;
    number: string | undefined;
    saveTo: string | undefined;
    summary: string | undefined;
    approvedBy: string | undefined;
    attachment: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    position: string | undefined;
    groupAuthor: string | undefined;
    documentTypeId: string | undefined;
    priority: string | undefined;
    incommingDate: moment.Moment;
    typeReceive: string | undefined;
    placeReceive: string | undefined;
    isActive: string | undefined;
    pages: string | undefined;
    order: string | undefined;
    moreInformation: string | undefined;
    incommingNumber: string | undefined;
    author: string | undefined;
    note: string | undefined;
    status: string | undefined;
    personalComment: string | undefined;
    person: string | undefined;
    group: string | undefined;
    userId: string | undefined;
    beforeStatus: string | undefined;
    handlerBeforeContent: string | undefined;
    handlerBeforeComment: string | undefined;
    handler: string | undefined;
    action: string | undefined;
    linkedDocument: string | undefined;
    range: string | undefined;
    type: string | undefined;
    mainHandling: string | undefined;
    coHandling: string | undefined;
    toKnow: string | undefined;
    stt: number;

    constructor(data?: IDocument_Waitting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = data["tenantId"];
            this.number = data["number"];
            this.saveTo = data["saveTo"];
            this.summary = data["summary"];
            this.approvedBy = data["approvedBy"];
            this.attachment = data["attachment"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.position = data["position"];
            this.groupAuthor = data["groupAuthor"];
            this.documentTypeId = data["documentTypeId"];
            this.priority = data["priority"];
            this.incommingDate = data["incommingDate"] ? moment(data["incommingDate"].toString()) : <any>undefined;
            this.typeReceive = data["typeReceive"];
            this.placeReceive = data["placeReceive"];
            this.isActive = data["isActive"];
            this.pages = data["pages"];
            this.order = data["order"];
            this.moreInformation = data["moreInformation"];
            this.incommingNumber = data["incommingNumber"];
            this.author = data["author"];
            this.note = data["note"];
            this.status = data["status"];
            this.personalComment = data["personalComment"];
            this.person = data["person"];
            this.group = data["group"];
            this.userId = data["userId"];
            this.beforeStatus = data["beforeStatus"];
            this.handlerBeforeContent = data["handlerBeforeContent"];
            this.handlerBeforeComment = data["handlerBeforeComment"];
            this.handler = data["handler"];
            this.action = data["action"];
            this.linkedDocument = data["linkedDocument"];
            this.range = data["range"];
            this.type = data["type"];
            this.mainHandling = data["mainHandling"];
            this.coHandling = data["coHandling"];
            this.toKnow = data["toKnow"];
            this.stt = data["stt"];
        }
    }

    static fromJS(data: any): Document_Waitting {
        data = typeof data === 'object' ? data : {};
        let result = new Document_Waitting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["number"] = this.number;
        data["saveTo"] = this.saveTo;
        data["summary"] = this.summary;
        data["approvedBy"] = this.approvedBy;
        data["attachment"] = this.attachment;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["position"] = this.position;
        data["groupAuthor"] = this.groupAuthor;
        data["documentTypeId"] = this.documentTypeId;
        data["priority"] = this.priority;
        data["incommingDate"] = this.incommingDate ? this.incommingDate.toISOString() : <any>undefined;
        data["typeReceive"] = this.typeReceive;
        data["placeReceive"] = this.placeReceive;
        data["isActive"] = this.isActive;
        data["pages"] = this.pages;
        data["order"] = this.order;
        data["moreInformation"] = this.moreInformation;
        data["incommingNumber"] = this.incommingNumber;
        data["author"] = this.author;
        data["note"] = this.note;
        data["status"] = this.status;
        data["personalComment"] = this.personalComment;
        data["person"] = this.person;
        data["group"] = this.group;
        data["userId"] = this.userId;
        data["beforeStatus"] = this.beforeStatus;
        data["handlerBeforeContent"] = this.handlerBeforeContent;
        data["handlerBeforeComment"] = this.handlerBeforeComment;
        data["handler"] = this.handler;
        data["action"] = this.action;
        data["linkedDocument"] = this.linkedDocument;
        data["range"] = this.range;
        data["type"] = this.type;
        data["mainHandling"] = this.mainHandling;
        data["coHandling"] = this.coHandling;
        data["toKnow"] = this.toKnow;
        data["stt"] = this.stt;
        return data; 
    }

    clone(): Document_Waitting {
        const json = this.toJSON();
        let result = new Document_Waitting();
        result.init(json);
        return result;
    }
}

export interface IDocument_Waitting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: string | undefined;
    lastModificationTime: moment.Moment;
    lastModifierUserId: string | undefined;
    isDeleted: string | undefined;
    deleterUserId: string | undefined;
    deletionTime: moment.Moment;
    tenantId: string | undefined;
    number: string | undefined;
    saveTo: string | undefined;
    summary: string | undefined;
    approvedBy: string | undefined;
    attachment: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    position: string | undefined;
    groupAuthor: string | undefined;
    documentTypeId: string | undefined;
    priority: string | undefined;
    incommingDate: moment.Moment;
    typeReceive: string | undefined;
    placeReceive: string | undefined;
    isActive: string | undefined;
    pages: string | undefined;
    order: string | undefined;
    moreInformation: string | undefined;
    incommingNumber: string | undefined;
    author: string | undefined;
    note: string | undefined;
    status: string | undefined;
    personalComment: string | undefined;
    person: string | undefined;
    group: string | undefined;
    userId: string | undefined;
    beforeStatus: string | undefined;
    handlerBeforeContent: string | undefined;
    handlerBeforeComment: string | undefined;
    handler: string | undefined;
    action: string | undefined;
    linkedDocument: string | undefined;
    range: string | undefined;
    type: string | undefined;
    mainHandling: string | undefined;
    coHandling: string | undefined;
    toKnow: string | undefined;
    stt: number;
}

export class GetDocumentDetailForViewDto implements IGetDocumentDetailForViewDto {
    documentDetail: DocumentDetailDto;

    constructor(data?: IGetDocumentDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documentDetail = new DocumentDetailDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.documentDetail = data["documentDetail"] ? DocumentDetailDto.fromJS(data["documentDetail"]) : new DocumentDetailDto();
        }
    }

    static fromJS(data: any): GetDocumentDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentDetail"] = this.documentDetail ? this.documentDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDocumentDetailForViewDto {
        const json = this.toJSON();
        let result = new GetDocumentDetailForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentDetailForViewDto {
    documentDetail: DocumentDetailDto;
}

export class PagedResultDtoOfGetDocumentDetailForViewDto implements IPagedResultDtoOfGetDocumentDetailForViewDto {
    totalCount: number;
    items: GetDocumentDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDocumentDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetDocumentDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDocumentDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDocumentDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetDocumentDetailForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetDocumentDetailForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetDocumentDetailForViewDto {
    totalCount: number;
    items: GetDocumentDetailForViewDto[] | undefined;
}

export class CreateOrEditDocumentDetailDto implements ICreateOrEditDocumentDetailDto {
    documentId: number;
    incomingNumber: number;
    pages: number;
    dateHandle: moment.Moment;
    typeHandle: string | undefined;
    description: string | undefined;
    status: string | undefined;
    isStared: string | undefined;
    priority: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditDocumentDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.documentId = data["documentId"];
            this.incomingNumber = data["incomingNumber"];
            this.pages = data["pages"];
            this.dateHandle = data["dateHandle"] ? moment(data["dateHandle"].toString()) : <any>undefined;
            this.typeHandle = data["typeHandle"];
            this.description = data["description"];
            this.status = data["status"];
            this.isStared = data["isStared"];
            this.priority = data["priority"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDocumentDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDocumentDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["incomingNumber"] = this.incomingNumber;
        data["pages"] = this.pages;
        data["dateHandle"] = this.dateHandle ? this.dateHandle.toISOString() : <any>undefined;
        data["typeHandle"] = this.typeHandle;
        data["description"] = this.description;
        data["status"] = this.status;
        data["isStared"] = this.isStared;
        data["priority"] = this.priority;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDocumentDetailDto {
        const json = this.toJSON();
        let result = new CreateOrEditDocumentDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDocumentDetailDto {
    documentId: number;
    incomingNumber: number;
    pages: number;
    dateHandle: moment.Moment;
    typeHandle: string | undefined;
    description: string | undefined;
    status: string | undefined;
    isStared: string | undefined;
    priority: string | undefined;
    id: number | undefined;
}

export class GetDocumentDetailForEditOutput implements IGetDocumentDetailForEditOutput {
    documentDetail: CreateOrEditDocumentDetailDto;

    constructor(data?: IGetDocumentDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documentDetail = new CreateOrEditDocumentDetailDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.documentDetail = data["documentDetail"] ? CreateOrEditDocumentDetailDto.fromJS(data["documentDetail"]) : new CreateOrEditDocumentDetailDto();
        }
    }

    static fromJS(data: any): GetDocumentDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentDetail"] = this.documentDetail ? this.documentDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDocumentDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetDocumentDetailForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentDetailForEditOutput {
    documentDetail: CreateOrEditDocumentDetailDto;
}

export class DocumentHandlingDetailDto implements IDocumentHandlingDetailDto {
    group: string | undefined;
    person: string | undefined;
    type: string | undefined;
    superios: string | undefined;
    personalComment: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    documentHandlingId: number;
    mainHandling: boolean;
    coHandling: boolean;
    toKnow: boolean;
    userId: number;
    isHandled: boolean;
    id: number;

    constructor(data?: IDocumentHandlingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.group = data["group"];
            this.person = data["person"];
            this.type = data["type"];
            this.superios = data["superios"];
            this.personalComment = data["personalComment"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.documentHandlingId = data["documentHandlingId"];
            this.mainHandling = data["mainHandling"];
            this.coHandling = data["coHandling"];
            this.toKnow = data["toKnow"];
            this.userId = data["userId"];
            this.isHandled = data["isHandled"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DocumentHandlingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHandlingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["person"] = this.person;
        data["type"] = this.type;
        data["superios"] = this.superios;
        data["personalComment"] = this.personalComment;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["documentHandlingId"] = this.documentHandlingId;
        data["mainHandling"] = this.mainHandling;
        data["coHandling"] = this.coHandling;
        data["toKnow"] = this.toKnow;
        data["userId"] = this.userId;
        data["isHandled"] = this.isHandled;
        data["id"] = this.id;
        return data; 
    }

    clone(): DocumentHandlingDetailDto {
        const json = this.toJSON();
        let result = new DocumentHandlingDetailDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentHandlingDetailDto {
    group: string | undefined;
    person: string | undefined;
    type: string | undefined;
    superios: string | undefined;
    personalComment: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    documentHandlingId: number;
    mainHandling: boolean;
    coHandling: boolean;
    toKnow: boolean;
    userId: number;
    isHandled: boolean;
    id: number;
}

export class GetDocumentHandlingDetailForViewDto implements IGetDocumentHandlingDetailForViewDto {
    documentHandlingDetail: DocumentHandlingDetailDto;

    constructor(data?: IGetDocumentHandlingDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documentHandlingDetail = new DocumentHandlingDetailDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.documentHandlingDetail = data["documentHandlingDetail"] ? DocumentHandlingDetailDto.fromJS(data["documentHandlingDetail"]) : new DocumentHandlingDetailDto();
        }
    }

    static fromJS(data: any): GetDocumentHandlingDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentHandlingDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentHandlingDetail"] = this.documentHandlingDetail ? this.documentHandlingDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDocumentHandlingDetailForViewDto {
        const json = this.toJSON();
        let result = new GetDocumentHandlingDetailForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentHandlingDetailForViewDto {
    documentHandlingDetail: DocumentHandlingDetailDto;
}

export class PagedResultDtoOfGetDocumentHandlingDetailForViewDto implements IPagedResultDtoOfGetDocumentHandlingDetailForViewDto {
    totalCount: number;
    items: GetDocumentHandlingDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDocumentHandlingDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetDocumentHandlingDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDocumentHandlingDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDocumentHandlingDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetDocumentHandlingDetailForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetDocumentHandlingDetailForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetDocumentHandlingDetailForViewDto {
    totalCount: number;
    items: GetDocumentHandlingDetailForViewDto[] | undefined;
}

export class CreateOrEditDocumentHandlingDetailDto implements ICreateOrEditDocumentHandlingDetailDto {
    group: string | undefined;
    person: string | undefined;
    type: string | undefined;
    superios: string | undefined;
    personalComment: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    documentHandlingId: number;
    mainHandling: boolean;
    coHandling: boolean;
    toKnow: boolean;
    userId: number;
    isHandled: boolean;
    id: number | undefined;

    constructor(data?: ICreateOrEditDocumentHandlingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.group = data["group"];
            this.person = data["person"];
            this.type = data["type"];
            this.superios = data["superios"];
            this.personalComment = data["personalComment"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.documentHandlingId = data["documentHandlingId"];
            this.mainHandling = data["mainHandling"];
            this.coHandling = data["coHandling"];
            this.toKnow = data["toKnow"];
            this.userId = data["userId"];
            this.isHandled = data["isHandled"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDocumentHandlingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDocumentHandlingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["person"] = this.person;
        data["type"] = this.type;
        data["superios"] = this.superios;
        data["personalComment"] = this.personalComment;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["documentHandlingId"] = this.documentHandlingId;
        data["mainHandling"] = this.mainHandling;
        data["coHandling"] = this.coHandling;
        data["toKnow"] = this.toKnow;
        data["userId"] = this.userId;
        data["isHandled"] = this.isHandled;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDocumentHandlingDetailDto {
        const json = this.toJSON();
        let result = new CreateOrEditDocumentHandlingDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDocumentHandlingDetailDto {
    group: string | undefined;
    person: string | undefined;
    type: string | undefined;
    superios: string | undefined;
    personalComment: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    documentHandlingId: number;
    mainHandling: boolean;
    coHandling: boolean;
    toKnow: boolean;
    userId: number;
    isHandled: boolean;
    id: number | undefined;
}

export class GetDocumentHandlingDetailForEditOutput implements IGetDocumentHandlingDetailForEditOutput {
    documentHandlingDetail: CreateOrEditDocumentHandlingDetailDto;

    constructor(data?: IGetDocumentHandlingDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documentHandlingDetail = new CreateOrEditDocumentHandlingDetailDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.documentHandlingDetail = data["documentHandlingDetail"] ? CreateOrEditDocumentHandlingDetailDto.fromJS(data["documentHandlingDetail"]) : new CreateOrEditDocumentHandlingDetailDto();
        }
    }

    static fromJS(data: any): GetDocumentHandlingDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentHandlingDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentHandlingDetail"] = this.documentHandlingDetail ? this.documentHandlingDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDocumentHandlingDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetDocumentHandlingDetailForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentHandlingDetailForEditOutput {
    documentHandlingDetail: CreateOrEditDocumentHandlingDetailDto;
}

export class GetDocumentHandlingForViewDto implements IGetDocumentHandlingForViewDto {
    documentHandling: DocumentHandlingDto;

    constructor(data?: IGetDocumentHandlingForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documentHandling = new DocumentHandlingDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.documentHandling = data["documentHandling"] ? DocumentHandlingDto.fromJS(data["documentHandling"]) : new DocumentHandlingDto();
        }
    }

    static fromJS(data: any): GetDocumentHandlingForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentHandlingForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentHandling"] = this.documentHandling ? this.documentHandling.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDocumentHandlingForViewDto {
        const json = this.toJSON();
        let result = new GetDocumentHandlingForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentHandlingForViewDto {
    documentHandling: DocumentHandlingDto;
}

export class PagedResultDtoOfGetDocumentHandlingForViewDto implements IPagedResultDtoOfGetDocumentHandlingForViewDto {
    totalCount: number;
    items: GetDocumentHandlingForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDocumentHandlingForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetDocumentHandlingForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDocumentHandlingForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDocumentHandlingForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetDocumentHandlingForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetDocumentHandlingForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetDocumentHandlingForViewDto {
    totalCount: number;
    items: GetDocumentHandlingForViewDto[] | undefined;
}

export class CreateOrEditDocumentHandlingDto implements ICreateOrEditDocumentHandlingDto {
    documentId: number;
    handler: string | undefined;
    handlingDetailId: number | undefined;
    placeReceive: string | undefined;
    content: string | undefined;
    status: string | undefined;
    comment: string | undefined;
    endDate: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditDocumentHandlingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.documentId = data["documentId"];
            this.handler = data["handler"];
            this.handlingDetailId = data["handlingDetailId"];
            this.placeReceive = data["placeReceive"];
            this.content = data["content"];
            this.status = data["status"];
            this.comment = data["comment"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDocumentHandlingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDocumentHandlingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["handler"] = this.handler;
        data["handlingDetailId"] = this.handlingDetailId;
        data["placeReceive"] = this.placeReceive;
        data["content"] = this.content;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDocumentHandlingDto {
        const json = this.toJSON();
        let result = new CreateOrEditDocumentHandlingDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDocumentHandlingDto {
    documentId: number;
    handler: string | undefined;
    handlingDetailId: number | undefined;
    placeReceive: string | undefined;
    content: string | undefined;
    status: string | undefined;
    comment: string | undefined;
    endDate: moment.Moment | undefined;
    id: number | undefined;
}

export class GetDocumentHandlingForEditOutput implements IGetDocumentHandlingForEditOutput {
    documentHandling: CreateOrEditDocumentHandlingDto;

    constructor(data?: IGetDocumentHandlingForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documentHandling = new CreateOrEditDocumentHandlingDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.documentHandling = data["documentHandling"] ? CreateOrEditDocumentHandlingDto.fromJS(data["documentHandling"]) : new CreateOrEditDocumentHandlingDto();
        }
    }

    static fromJS(data: any): GetDocumentHandlingForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentHandlingForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentHandling"] = this.documentHandling ? this.documentHandling.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDocumentHandlingForEditOutput {
        const json = this.toJSON();
        let result = new GetDocumentHandlingForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentHandlingForEditOutput {
    documentHandling: CreateOrEditDocumentHandlingDto;
}

export class HandlingUser implements IHandlingUser {
    organizationUnitId: number;
    organizationName: string | undefined;
    userId: number;
    fullName: string | undefined;

    constructor(data?: IHandlingUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.organizationName = data["organizationName"];
            this.userId = data["userId"];
            this.fullName = data["fullName"];
        }
    }

    static fromJS(data: any): HandlingUser {
        data = typeof data === 'object' ? data : {};
        let result = new HandlingUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["organizationName"] = this.organizationName;
        data["userId"] = this.userId;
        data["fullName"] = this.fullName;
        return data; 
    }

    clone(): HandlingUser {
        const json = this.toJSON();
        let result = new HandlingUser();
        result.init(json);
        return result;
    }
}

export interface IHandlingUser {
    organizationUnitId: number;
    organizationName: string | undefined;
    userId: number;
    fullName: string | undefined;
}

export class SqlConfigDetailDto implements ISqlConfigDetailDto {
    sqlConfigId: number;
    code: string | undefined;
    name: string | undefined;
    format: string | undefined;
    type: string | undefined;
    width: string | undefined;
    colNum: number | undefined;
    groupLevel: number | undefined;
    isDisplay: boolean;
    order: number | undefined;
    textAlign: string | undefined;
    version: number | undefined;
    isSum: boolean;
    isFreePane: boolean;
    isParent: boolean;
    parentCode: string | undefined;
    groupSort: string | undefined;
    cellTemplate: string | undefined;
    id: number;

    constructor(data?: ISqlConfigDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sqlConfigId = data["sqlConfigId"];
            this.code = data["code"];
            this.name = data["name"];
            this.format = data["format"];
            this.type = data["type"];
            this.width = data["width"];
            this.colNum = data["colNum"];
            this.groupLevel = data["groupLevel"];
            this.isDisplay = data["isDisplay"];
            this.order = data["order"];
            this.textAlign = data["textAlign"];
            this.version = data["version"];
            this.isSum = data["isSum"];
            this.isFreePane = data["isFreePane"];
            this.isParent = data["isParent"];
            this.parentCode = data["parentCode"];
            this.groupSort = data["groupSort"];
            this.cellTemplate = data["cellTemplate"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SqlConfigDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SqlConfigDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sqlConfigId"] = this.sqlConfigId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["format"] = this.format;
        data["type"] = this.type;
        data["width"] = this.width;
        data["colNum"] = this.colNum;
        data["groupLevel"] = this.groupLevel;
        data["isDisplay"] = this.isDisplay;
        data["order"] = this.order;
        data["textAlign"] = this.textAlign;
        data["version"] = this.version;
        data["isSum"] = this.isSum;
        data["isFreePane"] = this.isFreePane;
        data["isParent"] = this.isParent;
        data["parentCode"] = this.parentCode;
        data["groupSort"] = this.groupSort;
        data["cellTemplate"] = this.cellTemplate;
        data["id"] = this.id;
        return data; 
    }

    clone(): SqlConfigDetailDto {
        const json = this.toJSON();
        let result = new SqlConfigDetailDto();
        result.init(json);
        return result;
    }
}

export interface ISqlConfigDetailDto {
    sqlConfigId: number;
    code: string | undefined;
    name: string | undefined;
    format: string | undefined;
    type: string | undefined;
    width: string | undefined;
    colNum: number | undefined;
    groupLevel: number | undefined;
    isDisplay: boolean;
    order: number | undefined;
    textAlign: string | undefined;
    version: number | undefined;
    isSum: boolean;
    isFreePane: boolean;
    isParent: boolean;
    parentCode: string | undefined;
    groupSort: string | undefined;
    cellTemplate: string | undefined;
    id: number;
}

export class GetDataAndColumnConfig_ProcesHanding implements IGetDataAndColumnConfig_ProcesHanding {
    listDocumentHanding: ListDocumentHanding[] | undefined;
    listColumnConfigProcesHanding: SqlConfigDetailDto[] | undefined;

    constructor(data?: IGetDataAndColumnConfig_ProcesHanding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["listDocumentHanding"] && data["listDocumentHanding"].constructor === Array) {
                this.listDocumentHanding = [];
                for (let item of data["listDocumentHanding"])
                    this.listDocumentHanding.push(ListDocumentHanding.fromJS(item));
            }
            if (data["listColumnConfigProcesHanding"] && data["listColumnConfigProcesHanding"].constructor === Array) {
                this.listColumnConfigProcesHanding = [];
                for (let item of data["listColumnConfigProcesHanding"])
                    this.listColumnConfigProcesHanding.push(SqlConfigDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDataAndColumnConfig_ProcesHanding {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataAndColumnConfig_ProcesHanding();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listDocumentHanding && this.listDocumentHanding.constructor === Array) {
            data["listDocumentHanding"] = [];
            for (let item of this.listDocumentHanding)
                data["listDocumentHanding"].push(item.toJSON());
        }
        if (this.listColumnConfigProcesHanding && this.listColumnConfigProcesHanding.constructor === Array) {
            data["listColumnConfigProcesHanding"] = [];
            for (let item of this.listColumnConfigProcesHanding)
                data["listColumnConfigProcesHanding"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetDataAndColumnConfig_ProcesHanding {
        const json = this.toJSON();
        let result = new GetDataAndColumnConfig_ProcesHanding();
        result.init(json);
        return result;
    }
}

export interface IGetDataAndColumnConfig_ProcesHanding {
    listDocumentHanding: ListDocumentHanding[] | undefined;
    listColumnConfigProcesHanding: SqlConfigDetailDto[] | undefined;
}

export class DocumentStatusDto implements IDocumentStatusDto {
    key: string | undefined;
    value: string | undefined;
    id: number;

    constructor(data?: IDocumentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DocumentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["id"] = this.id;
        return data; 
    }

    clone(): DocumentStatusDto {
        const json = this.toJSON();
        let result = new DocumentStatusDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentStatusDto {
    key: string | undefined;
    value: string | undefined;
    id: number;
}

export class GetDocumentStatusForViewDto implements IGetDocumentStatusForViewDto {
    documentStatus: DocumentStatusDto;

    constructor(data?: IGetDocumentStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documentStatus = new DocumentStatusDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.documentStatus = data["documentStatus"] ? DocumentStatusDto.fromJS(data["documentStatus"]) : new DocumentStatusDto();
        }
    }

    static fromJS(data: any): GetDocumentStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentStatus"] = this.documentStatus ? this.documentStatus.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDocumentStatusForViewDto {
        const json = this.toJSON();
        let result = new GetDocumentStatusForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentStatusForViewDto {
    documentStatus: DocumentStatusDto;
}

export class PagedResultDtoOfGetDocumentStatusForViewDto implements IPagedResultDtoOfGetDocumentStatusForViewDto {
    totalCount: number;
    items: GetDocumentStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDocumentStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetDocumentStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDocumentStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDocumentStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetDocumentStatusForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetDocumentStatusForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetDocumentStatusForViewDto {
    totalCount: number;
    items: GetDocumentStatusForViewDto[] | undefined;
}

export class CreateOrEditDocumentStatusDto implements ICreateOrEditDocumentStatusDto {
    key: string | undefined;
    value: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditDocumentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDocumentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDocumentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDocumentStatusDto {
        const json = this.toJSON();
        let result = new CreateOrEditDocumentStatusDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDocumentStatusDto {
    key: string | undefined;
    value: string | undefined;
    id: number | undefined;
}

export class GetDocumentStatusForEditOutput implements IGetDocumentStatusForEditOutput {
    documentStatus: CreateOrEditDocumentStatusDto;

    constructor(data?: IGetDocumentStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documentStatus = new CreateOrEditDocumentStatusDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.documentStatus = data["documentStatus"] ? CreateOrEditDocumentStatusDto.fromJS(data["documentStatus"]) : new CreateOrEditDocumentStatusDto();
        }
    }

    static fromJS(data: any): GetDocumentStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentStatus"] = this.documentStatus ? this.documentStatus.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDocumentStatusForEditOutput {
        const json = this.toJSON();
        let result = new GetDocumentStatusForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentStatusForEditOutput {
    documentStatus: CreateOrEditDocumentStatusDto;
}

export class DocumentTypeDto implements IDocumentTypeDto {
    typeName: string | undefined;
    signal: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IDocumentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeName = data["typeName"];
            this.signal = data["signal"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DocumentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["signal"] = this.signal;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): DocumentTypeDto {
        const json = this.toJSON();
        let result = new DocumentTypeDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentTypeDto {
    typeName: string | undefined;
    signal: string | undefined;
    isActive: boolean;
    id: number;
}

export class GetDocumentTypeForViewDto implements IGetDocumentTypeForViewDto {
    documentType: DocumentTypeDto;

    constructor(data?: IGetDocumentTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documentType = new DocumentTypeDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.documentType = data["documentType"] ? DocumentTypeDto.fromJS(data["documentType"]) : new DocumentTypeDto();
        }
    }

    static fromJS(data: any): GetDocumentTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDocumentTypeForViewDto {
        const json = this.toJSON();
        let result = new GetDocumentTypeForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentTypeForViewDto {
    documentType: DocumentTypeDto;
}

export class PagedResultDtoOfGetDocumentTypeForViewDto implements IPagedResultDtoOfGetDocumentTypeForViewDto {
    totalCount: number;
    items: GetDocumentTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDocumentTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetDocumentTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDocumentTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDocumentTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetDocumentTypeForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetDocumentTypeForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetDocumentTypeForViewDto {
    totalCount: number;
    items: GetDocumentTypeForViewDto[] | undefined;
}

export class CreateOrEditDocumentTypeDto implements ICreateOrEditDocumentTypeDto {
    typeName: string | undefined;
    signal: string | undefined;
    order: number;
    isActive: boolean;
    id: number | undefined;

    constructor(data?: ICreateOrEditDocumentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeName = data["typeName"];
            this.signal = data["signal"];
            this.order = data["order"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDocumentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDocumentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["signal"] = this.signal;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDocumentTypeDto {
        const json = this.toJSON();
        let result = new CreateOrEditDocumentTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDocumentTypeDto {
    typeName: string | undefined;
    signal: string | undefined;
    order: number;
    isActive: boolean;
    id: number | undefined;
}

export class GetDocumentTypeForEditOutput implements IGetDocumentTypeForEditOutput {
    documentType: CreateOrEditDocumentTypeDto;

    constructor(data?: IGetDocumentTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documentType = new CreateOrEditDocumentTypeDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.documentType = data["documentType"] ? CreateOrEditDocumentTypeDto.fromJS(data["documentType"]) : new CreateOrEditDocumentTypeDto();
        }
    }

    static fromJS(data: any): GetDocumentTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDocumentTypeForEditOutput {
        const json = this.toJSON();
        let result = new GetDocumentTypeForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentTypeForEditOutput {
    documentType: CreateOrEditDocumentTypeDto;
}

export class DynamicActionDto implements IDynamicActionDto {
    labelId: number;
    roleId: number;
    tenantId: number | undefined;
    hasSave: boolean;
    hasReturn: boolean;
    hasTransfer: string | undefined;
    hasSaveAndTransfer: boolean;
    hasFinish: boolean;
    position: number;
    isBack: boolean;
    hasAssignWork: string | undefined;
    description: string | undefined;
    order: number;
    hasDelete: boolean;
    hasCreate: boolean;
    hasReport: boolean;
    hasSaveAndCreate: boolean;
    cellTemplate: string | undefined;
    id: number;

    constructor(data?: IDynamicActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.labelId = data["labelId"];
            this.roleId = data["roleId"];
            this.tenantId = data["tenantId"];
            this.hasSave = data["hasSave"];
            this.hasReturn = data["hasReturn"];
            this.hasTransfer = data["hasTransfer"];
            this.hasSaveAndTransfer = data["hasSaveAndTransfer"];
            this.hasFinish = data["hasFinish"];
            this.position = data["position"];
            this.isBack = data["isBack"];
            this.hasAssignWork = data["hasAssignWork"];
            this.description = data["description"];
            this.order = data["order"];
            this.hasDelete = data["hasDelete"];
            this.hasCreate = data["hasCreate"];
            this.hasReport = data["hasReport"];
            this.hasSaveAndCreate = data["hasSaveAndCreate"];
            this.cellTemplate = data["cellTemplate"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DynamicActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["labelId"] = this.labelId;
        data["roleId"] = this.roleId;
        data["tenantId"] = this.tenantId;
        data["hasSave"] = this.hasSave;
        data["hasReturn"] = this.hasReturn;
        data["hasTransfer"] = this.hasTransfer;
        data["hasSaveAndTransfer"] = this.hasSaveAndTransfer;
        data["hasFinish"] = this.hasFinish;
        data["position"] = this.position;
        data["isBack"] = this.isBack;
        data["hasAssignWork"] = this.hasAssignWork;
        data["description"] = this.description;
        data["order"] = this.order;
        data["hasDelete"] = this.hasDelete;
        data["hasCreate"] = this.hasCreate;
        data["hasReport"] = this.hasReport;
        data["hasSaveAndCreate"] = this.hasSaveAndCreate;
        data["cellTemplate"] = this.cellTemplate;
        data["id"] = this.id;
        return data; 
    }

    clone(): DynamicActionDto {
        const json = this.toJSON();
        let result = new DynamicActionDto();
        result.init(json);
        return result;
    }
}

export interface IDynamicActionDto {
    labelId: number;
    roleId: number;
    tenantId: number | undefined;
    hasSave: boolean;
    hasReturn: boolean;
    hasTransfer: string | undefined;
    hasSaveAndTransfer: boolean;
    hasFinish: boolean;
    position: number;
    isBack: boolean;
    hasAssignWork: string | undefined;
    description: string | undefined;
    order: number;
    hasDelete: boolean;
    hasCreate: boolean;
    hasReport: boolean;
    hasSaveAndCreate: boolean;
    cellTemplate: string | undefined;
    id: number;
}

export class GetDynamicActionForViewDto implements IGetDynamicActionForViewDto {
    dynamicAction: DynamicActionDto;

    constructor(data?: IGetDynamicActionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dynamicAction = new DynamicActionDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dynamicAction = data["dynamicAction"] ? DynamicActionDto.fromJS(data["dynamicAction"]) : new DynamicActionDto();
        }
    }

    static fromJS(data: any): GetDynamicActionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDynamicActionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicAction"] = this.dynamicAction ? this.dynamicAction.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDynamicActionForViewDto {
        const json = this.toJSON();
        let result = new GetDynamicActionForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetDynamicActionForViewDto {
    dynamicAction: DynamicActionDto;
}

export class CreateOrEditDynamicActionDto implements ICreateOrEditDynamicActionDto {
    labelId: number;
    tenantId: number | undefined;
    roleId: number;
    hasSave: boolean;
    hasReturn: boolean;
    hasTransfer: string | undefined;
    hasSaveAndTransfer: boolean;
    hasFinish: boolean;
    position: number;
    isBack: boolean;
    hasAssignWork: string | undefined;
    description: string | undefined;
    order: number;
    hasDelete: boolean;
    hasCreate: boolean;
    hasReport: boolean;
    hasSaveAndCreate: boolean;
    cellTemplate: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditDynamicActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.labelId = data["labelId"];
            this.tenantId = data["tenantId"];
            this.roleId = data["roleId"];
            this.hasSave = data["hasSave"];
            this.hasReturn = data["hasReturn"];
            this.hasTransfer = data["hasTransfer"];
            this.hasSaveAndTransfer = data["hasSaveAndTransfer"];
            this.hasFinish = data["hasFinish"];
            this.position = data["position"];
            this.isBack = data["isBack"];
            this.hasAssignWork = data["hasAssignWork"];
            this.description = data["description"];
            this.order = data["order"];
            this.hasDelete = data["hasDelete"];
            this.hasCreate = data["hasCreate"];
            this.hasReport = data["hasReport"];
            this.hasSaveAndCreate = data["hasSaveAndCreate"];
            this.cellTemplate = data["cellTemplate"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDynamicActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDynamicActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["labelId"] = this.labelId;
        data["tenantId"] = this.tenantId;
        data["roleId"] = this.roleId;
        data["hasSave"] = this.hasSave;
        data["hasReturn"] = this.hasReturn;
        data["hasTransfer"] = this.hasTransfer;
        data["hasSaveAndTransfer"] = this.hasSaveAndTransfer;
        data["hasFinish"] = this.hasFinish;
        data["position"] = this.position;
        data["isBack"] = this.isBack;
        data["hasAssignWork"] = this.hasAssignWork;
        data["description"] = this.description;
        data["order"] = this.order;
        data["hasDelete"] = this.hasDelete;
        data["hasCreate"] = this.hasCreate;
        data["hasReport"] = this.hasReport;
        data["hasSaveAndCreate"] = this.hasSaveAndCreate;
        data["cellTemplate"] = this.cellTemplate;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDynamicActionDto {
        const json = this.toJSON();
        let result = new CreateOrEditDynamicActionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDynamicActionDto {
    labelId: number;
    tenantId: number | undefined;
    roleId: number;
    hasSave: boolean;
    hasReturn: boolean;
    hasTransfer: string | undefined;
    hasSaveAndTransfer: boolean;
    hasFinish: boolean;
    position: number;
    isBack: boolean;
    hasAssignWork: string | undefined;
    description: string | undefined;
    order: number;
    hasDelete: boolean;
    hasCreate: boolean;
    hasReport: boolean;
    hasSaveAndCreate: boolean;
    cellTemplate: string | undefined;
    id: number | undefined;
}

export class GetDynamicActionForEditOutput implements IGetDynamicActionForEditOutput {
    dynamicAction: CreateOrEditDynamicActionDto;

    constructor(data?: IGetDynamicActionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dynamicAction = new CreateOrEditDynamicActionDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dynamicAction = data["dynamicAction"] ? CreateOrEditDynamicActionDto.fromJS(data["dynamicAction"]) : new CreateOrEditDynamicActionDto();
        }
    }

    static fromJS(data: any): GetDynamicActionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDynamicActionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicAction"] = this.dynamicAction ? this.dynamicAction.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDynamicActionForEditOutput {
        const json = this.toJSON();
        let result = new GetDynamicActionForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDynamicActionForEditOutput {
    dynamicAction: CreateOrEditDynamicActionDto;
}

export class DynamicDatasourceDto implements IDynamicDatasourceDto {
    type: number;
    objectId: number | undefined;
    dynamicFieldId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IDynamicDatasourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.objectId = data["objectId"];
            this.dynamicFieldId = data["dynamicFieldId"];
            this.order = data["order"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DynamicDatasourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicDatasourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["objectId"] = this.objectId;
        data["dynamicFieldId"] = this.dynamicFieldId;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): DynamicDatasourceDto {
        const json = this.toJSON();
        let result = new DynamicDatasourceDto();
        result.init(json);
        return result;
    }
}

export interface IDynamicDatasourceDto {
    type: number;
    objectId: number | undefined;
    dynamicFieldId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number;
}

export class GetDynamicDatasourceForViewDto implements IGetDynamicDatasourceForViewDto {
    dynamicDatasource: DynamicDatasourceDto;

    constructor(data?: IGetDynamicDatasourceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dynamicDatasource = new DynamicDatasourceDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dynamicDatasource = data["dynamicDatasource"] ? DynamicDatasourceDto.fromJS(data["dynamicDatasource"]) : new DynamicDatasourceDto();
        }
    }

    static fromJS(data: any): GetDynamicDatasourceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDynamicDatasourceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicDatasource"] = this.dynamicDatasource ? this.dynamicDatasource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDynamicDatasourceForViewDto {
        const json = this.toJSON();
        let result = new GetDynamicDatasourceForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetDynamicDatasourceForViewDto {
    dynamicDatasource: DynamicDatasourceDto;
}

export class PagedResultDtoOfGetDynamicDatasourceForViewDto implements IPagedResultDtoOfGetDynamicDatasourceForViewDto {
    totalCount: number;
    items: GetDynamicDatasourceForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDynamicDatasourceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetDynamicDatasourceForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDynamicDatasourceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDynamicDatasourceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetDynamicDatasourceForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetDynamicDatasourceForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetDynamicDatasourceForViewDto {
    totalCount: number;
    items: GetDynamicDatasourceForViewDto[] | undefined;
}

export class CreateOrEditDynamicDatasourceDto implements ICreateOrEditDynamicDatasourceDto {
    type: number;
    objectId: number | undefined;
    dynamicFieldId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number | undefined;

    constructor(data?: ICreateOrEditDynamicDatasourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.objectId = data["objectId"];
            this.dynamicFieldId = data["dynamicFieldId"];
            this.order = data["order"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDynamicDatasourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDynamicDatasourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["objectId"] = this.objectId;
        data["dynamicFieldId"] = this.dynamicFieldId;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDynamicDatasourceDto {
        const json = this.toJSON();
        let result = new CreateOrEditDynamicDatasourceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDynamicDatasourceDto {
    type: number;
    objectId: number | undefined;
    dynamicFieldId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number | undefined;
}

export class GetDynamicDatasourceForEditOutput implements IGetDynamicDatasourceForEditOutput {
    dynamicDatasource: CreateOrEditDynamicDatasourceDto;

    constructor(data?: IGetDynamicDatasourceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dynamicDatasource = new CreateOrEditDynamicDatasourceDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dynamicDatasource = data["dynamicDatasource"] ? CreateOrEditDynamicDatasourceDto.fromJS(data["dynamicDatasource"]) : new CreateOrEditDynamicDatasourceDto();
        }
    }

    static fromJS(data: any): GetDynamicDatasourceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDynamicDatasourceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicDatasource"] = this.dynamicDatasource ? this.dynamicDatasource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDynamicDatasourceForEditOutput {
        const json = this.toJSON();
        let result = new GetDynamicDatasourceForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDynamicDatasourceForEditOutput {
    dynamicDatasource: CreateOrEditDynamicDatasourceDto;
}

export class DynamicFieldDto implements IDynamicFieldDto {
    tenantId: number | undefined;
    moduleId: number;
    tableName: string | undefined;
    name: string | undefined;
    typeField: number;
    width: number | undefined;
    nameDescription: string | undefined;
    departmentId: number | undefined;
    isActive: boolean;
    order: number | undefined;
    widthDescription: number | undefined;
    classAttach: string | undefined;
    id: number;

    constructor(data?: IDynamicFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.moduleId = data["moduleId"];
            this.tableName = data["tableName"];
            this.name = data["name"];
            this.typeField = data["typeField"];
            this.width = data["width"];
            this.nameDescription = data["nameDescription"];
            this.departmentId = data["departmentId"];
            this.isActive = data["isActive"];
            this.order = data["order"];
            this.widthDescription = data["widthDescription"];
            this.classAttach = data["classAttach"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DynamicFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["moduleId"] = this.moduleId;
        data["tableName"] = this.tableName;
        data["name"] = this.name;
        data["typeField"] = this.typeField;
        data["width"] = this.width;
        data["nameDescription"] = this.nameDescription;
        data["departmentId"] = this.departmentId;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        data["widthDescription"] = this.widthDescription;
        data["classAttach"] = this.classAttach;
        data["id"] = this.id;
        return data; 
    }

    clone(): DynamicFieldDto {
        const json = this.toJSON();
        let result = new DynamicFieldDto();
        result.init(json);
        return result;
    }
}

export interface IDynamicFieldDto {
    tenantId: number | undefined;
    moduleId: number;
    tableName: string | undefined;
    name: string | undefined;
    typeField: number;
    width: number | undefined;
    nameDescription: string | undefined;
    departmentId: number | undefined;
    isActive: boolean;
    order: number | undefined;
    widthDescription: number | undefined;
    classAttach: string | undefined;
    id: number;
}

export class DynamicFieldListDto implements IDynamicFieldListDto {
    nameDescription: string | undefined;
    name: string | undefined;
    typeField: number;
    classAttach: string | undefined;
    width: number;
    widthDescription: number;
    tenantID: number;
    moduleID: number;
    value: string | undefined;
    order: number;
    valueId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDynamicFieldListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nameDescription = data["nameDescription"];
            this.name = data["name"];
            this.typeField = data["typeField"];
            this.classAttach = data["classAttach"];
            this.width = data["width"];
            this.widthDescription = data["widthDescription"];
            this.tenantID = data["tenantID"];
            this.moduleID = data["moduleID"];
            this.value = data["value"];
            this.order = data["order"];
            this.valueId = data["valueId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DynamicFieldListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicFieldListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameDescription"] = this.nameDescription;
        data["name"] = this.name;
        data["typeField"] = this.typeField;
        data["classAttach"] = this.classAttach;
        data["width"] = this.width;
        data["widthDescription"] = this.widthDescription;
        data["tenantID"] = this.tenantID;
        data["moduleID"] = this.moduleID;
        data["value"] = this.value;
        data["order"] = this.order;
        data["valueId"] = this.valueId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DynamicFieldListDto {
        const json = this.toJSON();
        let result = new DynamicFieldListDto();
        result.init(json);
        return result;
    }
}

export interface IDynamicFieldListDto {
    nameDescription: string | undefined;
    name: string | undefined;
    typeField: number;
    classAttach: string | undefined;
    width: number;
    widthDescription: number;
    tenantID: number;
    moduleID: number;
    value: string | undefined;
    order: number;
    valueId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class GetDataSourceDynamicDto implements IGetDataSourceDynamicDto {
    key: string | undefined;
    value: string | undefined;

    constructor(data?: IGetDataSourceDynamicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): GetDataSourceDynamicDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataSourceDynamicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): GetDataSourceDynamicDto {
        const json = this.toJSON();
        let result = new GetDataSourceDynamicDto();
        result.init(json);
        return result;
    }
}

export interface IGetDataSourceDynamicDto {
    key: string | undefined;
    value: string | undefined;
}

export class CreateOrEditDynamicFieldDto implements ICreateOrEditDynamicFieldDto {
    moduleId: number;
    tableName: string | undefined;
    name: string | undefined;
    typeField: number;
    width: number | undefined;
    nameDescription: string | undefined;
    departmentId: number | undefined;
    isActive: boolean;
    order: number | undefined;
    widthDescription: number | undefined;
    classAttach: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditDynamicFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.moduleId = data["moduleId"];
            this.tableName = data["tableName"];
            this.name = data["name"];
            this.typeField = data["typeField"];
            this.width = data["width"];
            this.nameDescription = data["nameDescription"];
            this.departmentId = data["departmentId"];
            this.isActive = data["isActive"];
            this.order = data["order"];
            this.widthDescription = data["widthDescription"];
            this.classAttach = data["classAttach"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDynamicFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDynamicFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleId"] = this.moduleId;
        data["tableName"] = this.tableName;
        data["name"] = this.name;
        data["typeField"] = this.typeField;
        data["width"] = this.width;
        data["nameDescription"] = this.nameDescription;
        data["departmentId"] = this.departmentId;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        data["widthDescription"] = this.widthDescription;
        data["classAttach"] = this.classAttach;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDynamicFieldDto {
        const json = this.toJSON();
        let result = new CreateOrEditDynamicFieldDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDynamicFieldDto {
    moduleId: number;
    tableName: string | undefined;
    name: string | undefined;
    typeField: number;
    width: number | undefined;
    nameDescription: string | undefined;
    departmentId: number | undefined;
    isActive: boolean;
    order: number | undefined;
    widthDescription: number | undefined;
    classAttach: string | undefined;
    id: number | undefined;
}

export class DynamicValueDto implements IDynamicValueDto {
    objectId: number | undefined;
    key: string | undefined;
    dynamicFieldId: number | undefined;
    isActive: boolean;
    order: number | undefined;
    value: string | undefined;
    id: number;

    constructor(data?: IDynamicValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.objectId = data["objectId"];
            this.key = data["key"];
            this.dynamicFieldId = data["dynamicFieldId"];
            this.isActive = data["isActive"];
            this.order = data["order"];
            this.value = data["value"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DynamicValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectId"] = this.objectId;
        data["key"] = this.key;
        data["dynamicFieldId"] = this.dynamicFieldId;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        data["value"] = this.value;
        data["id"] = this.id;
        return data; 
    }

    clone(): DynamicValueDto {
        const json = this.toJSON();
        let result = new DynamicValueDto();
        result.init(json);
        return result;
    }
}

export interface IDynamicValueDto {
    objectId: number | undefined;
    key: string | undefined;
    dynamicFieldId: number | undefined;
    isActive: boolean;
    order: number | undefined;
    value: string | undefined;
    id: number;
}

export class GetDynamicFieldForViewDto implements IGetDynamicFieldForViewDto {
    dynamicField: DynamicFieldDto;

    constructor(data?: IGetDynamicFieldForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dynamicField = new DynamicFieldDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dynamicField = data["dynamicField"] ? DynamicFieldDto.fromJS(data["dynamicField"]) : new DynamicFieldDto();
        }
    }

    static fromJS(data: any): GetDynamicFieldForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDynamicFieldForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicField"] = this.dynamicField ? this.dynamicField.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDynamicFieldForViewDto {
        const json = this.toJSON();
        let result = new GetDynamicFieldForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetDynamicFieldForViewDto {
    dynamicField: DynamicFieldDto;
}

export class PagedResultDtoOfGetDynamicFieldForViewDto implements IPagedResultDtoOfGetDynamicFieldForViewDto {
    totalCount: number;
    items: GetDynamicFieldForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDynamicFieldForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetDynamicFieldForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDynamicFieldForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDynamicFieldForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetDynamicFieldForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetDynamicFieldForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetDynamicFieldForViewDto {
    totalCount: number;
    items: GetDynamicFieldForViewDto[] | undefined;
}

export class GetDynamicFieldForEditOutput implements IGetDynamicFieldForEditOutput {
    dynamicField: CreateOrEditDynamicFieldDto;

    constructor(data?: IGetDynamicFieldForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dynamicField = new CreateOrEditDynamicFieldDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dynamicField = data["dynamicField"] ? CreateOrEditDynamicFieldDto.fromJS(data["dynamicField"]) : new CreateOrEditDynamicFieldDto();
        }
    }

    static fromJS(data: any): GetDynamicFieldForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDynamicFieldForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicField"] = this.dynamicField ? this.dynamicField.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDynamicFieldForEditOutput {
        const json = this.toJSON();
        let result = new GetDynamicFieldForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDynamicFieldForEditOutput {
    dynamicField: CreateOrEditDynamicFieldDto;
}

export class GetDynamicValueForViewDto implements IGetDynamicValueForViewDto {
    dynamicValue: DynamicValueDto;

    constructor(data?: IGetDynamicValueForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dynamicValue = new DynamicValueDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dynamicValue = data["dynamicValue"] ? DynamicValueDto.fromJS(data["dynamicValue"]) : new DynamicValueDto();
        }
    }

    static fromJS(data: any): GetDynamicValueForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDynamicValueForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicValue"] = this.dynamicValue ? this.dynamicValue.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDynamicValueForViewDto {
        const json = this.toJSON();
        let result = new GetDynamicValueForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetDynamicValueForViewDto {
    dynamicValue: DynamicValueDto;
}

export class PagedResultDtoOfGetDynamicValueForViewDto implements IPagedResultDtoOfGetDynamicValueForViewDto {
    totalCount: number;
    items: GetDynamicValueForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDynamicValueForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetDynamicValueForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDynamicValueForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDynamicValueForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetDynamicValueForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetDynamicValueForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetDynamicValueForViewDto {
    totalCount: number;
    items: GetDynamicValueForViewDto[] | undefined;
}

export class CreateOrEditDynamicValueDto implements ICreateOrEditDynamicValueDto {
    objectId: number | undefined;
    key: string | undefined;
    dynamicFieldId: number | undefined;
    isActive: boolean;
    order: number | undefined;
    value: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditDynamicValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.objectId = data["objectId"];
            this.key = data["key"];
            this.dynamicFieldId = data["dynamicFieldId"];
            this.isActive = data["isActive"];
            this.order = data["order"];
            this.value = data["value"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDynamicValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDynamicValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectId"] = this.objectId;
        data["key"] = this.key;
        data["dynamicFieldId"] = this.dynamicFieldId;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        data["value"] = this.value;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditDynamicValueDto {
        const json = this.toJSON();
        let result = new CreateOrEditDynamicValueDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditDynamicValueDto {
    objectId: number | undefined;
    key: string | undefined;
    dynamicFieldId: number | undefined;
    isActive: boolean;
    order: number | undefined;
    value: string | undefined;
    id: number | undefined;
}

export class GetDynamicValueForEditOutput implements IGetDynamicValueForEditOutput {
    dynamicValue: CreateOrEditDynamicValueDto;

    constructor(data?: IGetDynamicValueForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dynamicValue = new CreateOrEditDynamicValueDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dynamicValue = data["dynamicValue"] ? CreateOrEditDynamicValueDto.fromJS(data["dynamicValue"]) : new CreateOrEditDynamicValueDto();
        }
    }

    static fromJS(data: any): GetDynamicValueForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDynamicValueForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicValue"] = this.dynamicValue ? this.dynamicValue.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDynamicValueForEditOutput {
        const json = this.toJSON();
        let result = new GetDynamicValueForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDynamicValueForEditOutput {
    dynamicValue: CreateOrEditDynamicValueDto;
}

export class EditionListDto implements IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.dailyPrice = data["dailyPrice"];
            this.weeklyPrice = data["weeklyPrice"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.trialDayCount = data["trialDayCount"];
            this.expiringEditionDisplayName = data["expiringEditionDisplayName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditionListDto {
        const json = this.toJSON();
        let result = new EditionListDto();
        result.init(json);
        return result;
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfEditionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfEditionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id: number | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }

    clone(): EditionEditDto {
        const json = this.toJSON();
        let result = new EditionEditDto();
        result.init(json);
        return result;
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
}

export class IValueValidator implements IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : Anonymous; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key] ? Anonymous.fromJS(data["attributes"][key]) : new Anonymous();
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }

    clone(): IValueValidator {
        const json = this.toJSON();
        let result = new IValueValidator();
        result.init(json);
        return result;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : Anonymous; } | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }

    clone(): LocalizableComboboxItemDto {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LocalizableComboboxItemSourceDto {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemSourceDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : Anonymous2; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.validator = new IValueValidator();
            this.itemSource = new LocalizableComboboxItemSourceDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key] ? Anonymous2.fromJS(data["attributes"][key]) : new Anonymous2();
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : new IValueValidator();
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : new LocalizableComboboxItemSourceDto();
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FeatureInputTypeDto {
        const json = this.toJSON();
        let result = new FeatureInputTypeDto();
        result.init(json);
        return result;
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : Anonymous2; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.inputType = new FeatureInputTypeDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : new FeatureInputTypeDto();
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FlatFeatureDto {
        const json = this.toJSON();
        let result = new FlatFeatureDto();
        result.init(json);
        return result;
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetEditionEditOutput {
        const json = this.toJSON();
        let result = new GetEditionEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionCreateDto implements IEditionCreateDto {
    id: number | undefined;
    displayName: string | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.dailyPrice = data["dailyPrice"];
            this.weeklyPrice = data["weeklyPrice"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }

    clone(): EditionCreateDto {
        const json = this.toJSON();
        let result = new EditionCreateDto();
        result.init(json);
        return result;
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[] | undefined;

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionCreateDto.fromJS(data["edition"]) : new EditionCreateDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateEditionDto {
        const json = this.toJSON();
        let result = new CreateEditionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[] | undefined;
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateEditionDto {
        const json = this.toJSON();
        let result = new UpdateEditionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number;
    targetEditionId: number;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceEditionId = data["sourceEditionId"];
            this.targetEditionId = data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data; 
    }

    clone(): MoveTenantsToAnotherEditionDto {
        const json = this.toJSON();
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(json);
        return result;
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number;
    targetEditionId: number;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): CreateFriendshipRequestInput {
        const json = this.toJSON();
        let result = new CreateFriendshipRequestInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName: string | undefined;
    userName: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): CreateFriendshipRequestByUserNameInput {
        const json = this.toJSON();
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string | undefined;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId: number;
    tenantId: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): BlockUserInput {
        const json = this.toJSON();
        let result = new BlockUserInput();
        result.init(json);
        return result;
    }
}

export interface IBlockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId: number;
    tenantId: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): UnblockUserInput {
        const json = this.toJSON();
        let result = new UnblockUserInput();
        result.init(json);
        return result;
    }
}

export interface IUnblockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): AcceptFriendshipRequestInput {
        const json = this.toJSON();
        let result = new AcceptFriendshipRequestInput();
        result.init(json);
        return result;
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class HardDatasourceDto implements IHardDatasourceDto {
    key: string | undefined;
    value: string | undefined;
    dynamicDatasourceId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IHardDatasourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
            this.dynamicDatasourceId = data["dynamicDatasourceId"];
            this.order = data["order"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HardDatasourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new HardDatasourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["dynamicDatasourceId"] = this.dynamicDatasourceId;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): HardDatasourceDto {
        const json = this.toJSON();
        let result = new HardDatasourceDto();
        result.init(json);
        return result;
    }
}

export interface IHardDatasourceDto {
    key: string | undefined;
    value: string | undefined;
    dynamicDatasourceId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number;
}

export class GetHardDatasourceForViewDto implements IGetHardDatasourceForViewDto {
    hardDatasource: HardDatasourceDto;

    constructor(data?: IGetHardDatasourceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hardDatasource = new HardDatasourceDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.hardDatasource = data["hardDatasource"] ? HardDatasourceDto.fromJS(data["hardDatasource"]) : new HardDatasourceDto();
        }
    }

    static fromJS(data: any): GetHardDatasourceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetHardDatasourceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hardDatasource"] = this.hardDatasource ? this.hardDatasource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetHardDatasourceForViewDto {
        const json = this.toJSON();
        let result = new GetHardDatasourceForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetHardDatasourceForViewDto {
    hardDatasource: HardDatasourceDto;
}

export class PagedResultDtoOfGetHardDatasourceForViewDto implements IPagedResultDtoOfGetHardDatasourceForViewDto {
    totalCount: number;
    items: GetHardDatasourceForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetHardDatasourceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetHardDatasourceForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetHardDatasourceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetHardDatasourceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetHardDatasourceForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetHardDatasourceForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetHardDatasourceForViewDto {
    totalCount: number;
    items: GetHardDatasourceForViewDto[] | undefined;
}

export class CreateOrEditHardDatasourceDto implements ICreateOrEditHardDatasourceDto {
    key: string | undefined;
    value: string | undefined;
    dynamicDatasourceId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number | undefined;

    constructor(data?: ICreateOrEditHardDatasourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
            this.dynamicDatasourceId = data["dynamicDatasourceId"];
            this.order = data["order"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditHardDatasourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditHardDatasourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["dynamicDatasourceId"] = this.dynamicDatasourceId;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditHardDatasourceDto {
        const json = this.toJSON();
        let result = new CreateOrEditHardDatasourceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditHardDatasourceDto {
    key: string | undefined;
    value: string | undefined;
    dynamicDatasourceId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number | undefined;
}

export class GetHardDatasourceForEditOutput implements IGetHardDatasourceForEditOutput {
    hardDatasource: CreateOrEditHardDatasourceDto;

    constructor(data?: IGetHardDatasourceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hardDatasource = new CreateOrEditHardDatasourceDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.hardDatasource = data["hardDatasource"] ? CreateOrEditHardDatasourceDto.fromJS(data["hardDatasource"]) : new CreateOrEditHardDatasourceDto();
        }
    }

    static fromJS(data: any): GetHardDatasourceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetHardDatasourceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hardDatasource"] = this.hardDatasource ? this.hardDatasource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetHardDatasourceForEditOutput {
        const json = this.toJSON();
        let result = new GetHardDatasourceForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetHardDatasourceForEditOutput {
    hardDatasource: CreateOrEditHardDatasourceDto;
}

export class GetDataAndColumnConfig_HistoryUploads implements IGetDataAndColumnConfig_HistoryUploads {
    listHistoryUploads: ListHistoryUploads[] | undefined;
    listColumnConfigHistoryUploads: SqlConfigDetailDto[] | undefined;

    constructor(data?: IGetDataAndColumnConfig_HistoryUploads) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["listHistoryUploads"] && data["listHistoryUploads"].constructor === Array) {
                this.listHistoryUploads = [];
                for (let item of data["listHistoryUploads"])
                    this.listHistoryUploads.push(ListHistoryUploads.fromJS(item));
            }
            if (data["listColumnConfigHistoryUploads"] && data["listColumnConfigHistoryUploads"].constructor === Array) {
                this.listColumnConfigHistoryUploads = [];
                for (let item of data["listColumnConfigHistoryUploads"])
                    this.listColumnConfigHistoryUploads.push(SqlConfigDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDataAndColumnConfig_HistoryUploads {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataAndColumnConfig_HistoryUploads();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listHistoryUploads && this.listHistoryUploads.constructor === Array) {
            data["listHistoryUploads"] = [];
            for (let item of this.listHistoryUploads)
                data["listHistoryUploads"].push(item.toJSON());
        }
        if (this.listColumnConfigHistoryUploads && this.listColumnConfigHistoryUploads.constructor === Array) {
            data["listColumnConfigHistoryUploads"] = [];
            for (let item of this.listColumnConfigHistoryUploads)
                data["listColumnConfigHistoryUploads"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetDataAndColumnConfig_HistoryUploads {
        const json = this.toJSON();
        let result = new GetDataAndColumnConfig_HistoryUploads();
        result.init(json);
        return result;
    }
}

export interface IGetDataAndColumnConfig_HistoryUploads {
    listHistoryUploads: ListHistoryUploads[] | undefined;
    listColumnConfigHistoryUploads: SqlConfigDetailDto[] | undefined;
}

export class HistoryUploadDto implements IHistoryUploadDto {
    file: string | undefined;
    version: number;
    documentID: number;
    id: number;

    constructor(data?: IHistoryUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.file = data["file"];
            this.version = data["version"];
            this.documentID = data["documentID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HistoryUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        data["version"] = this.version;
        data["documentID"] = this.documentID;
        data["id"] = this.id;
        return data; 
    }

    clone(): HistoryUploadDto {
        const json = this.toJSON();
        let result = new HistoryUploadDto();
        result.init(json);
        return result;
    }
}

export interface IHistoryUploadDto {
    file: string | undefined;
    version: number;
    documentID: number;
    id: number;
}

export class GetHistoryUploadForViewDto implements IGetHistoryUploadForViewDto {
    historyUpload: HistoryUploadDto;

    constructor(data?: IGetHistoryUploadForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.historyUpload = new HistoryUploadDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.historyUpload = data["historyUpload"] ? HistoryUploadDto.fromJS(data["historyUpload"]) : new HistoryUploadDto();
        }
    }

    static fromJS(data: any): GetHistoryUploadForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetHistoryUploadForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["historyUpload"] = this.historyUpload ? this.historyUpload.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetHistoryUploadForViewDto {
        const json = this.toJSON();
        let result = new GetHistoryUploadForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetHistoryUploadForViewDto {
    historyUpload: HistoryUploadDto;
}

export class PagedResultDtoOfGetHistoryUploadForViewDto implements IPagedResultDtoOfGetHistoryUploadForViewDto {
    totalCount: number;
    items: GetHistoryUploadForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetHistoryUploadForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetHistoryUploadForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetHistoryUploadForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetHistoryUploadForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetHistoryUploadForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetHistoryUploadForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetHistoryUploadForViewDto {
    totalCount: number;
    items: GetHistoryUploadForViewDto[] | undefined;
}

export class CreateOrEditHistoryUploadDto implements ICreateOrEditHistoryUploadDto {
    file: string | undefined;
    version: number;
    documentID: number;
    id: number | undefined;

    constructor(data?: ICreateOrEditHistoryUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.file = data["file"];
            this.version = data["version"];
            this.documentID = data["documentID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditHistoryUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditHistoryUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        data["version"] = this.version;
        data["documentID"] = this.documentID;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditHistoryUploadDto {
        const json = this.toJSON();
        let result = new CreateOrEditHistoryUploadDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditHistoryUploadDto {
    file: string | undefined;
    version: number;
    documentID: number;
    id: number | undefined;
}

export class GetHistoryUploadForEditOutput implements IGetHistoryUploadForEditOutput {
    historyUpload: CreateOrEditHistoryUploadDto;

    constructor(data?: IGetHistoryUploadForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.historyUpload = new CreateOrEditHistoryUploadDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.historyUpload = data["historyUpload"] ? CreateOrEditHistoryUploadDto.fromJS(data["historyUpload"]) : new CreateOrEditHistoryUploadDto();
        }
    }

    static fromJS(data: any): GetHistoryUploadForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetHistoryUploadForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["historyUpload"] = this.historyUpload ? this.historyUpload.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetHistoryUploadForEditOutput {
        const json = this.toJSON();
        let result = new GetHistoryUploadForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetHistoryUploadForEditOutput {
    historyUpload: CreateOrEditHistoryUploadDto;
}

export class HopDongDto implements IHopDongDto {
    nhanVienId: string | undefined;
    hoTenNhanVien: string | undefined;
    viTriCongViecCode: string | undefined;
    soHopDong: string | undefined;
    ngayKy: moment.Moment | undefined;
    donViCongTacID: number | undefined;
    tenHopDong: string | undefined;
    loaiHopDongCode: string | undefined;
    hinhThucLamViecCode: string | undefined;
    ngayCoHieuLuc: moment.Moment | undefined;
    ngayHetHan: moment.Moment | undefined;
    luongCoBan: string | undefined;
    luongDongBaoHiem: string | undefined;
    tyLeHuongLuong: number | undefined;
    nguoiDaiDienCongTy: string | undefined;
    chucDanh: string | undefined;
    trichYeu: string | undefined;
    tepDinhKem: string | undefined;
    ghiChu: string | undefined;
    recorD_STATUS: string | undefined;
    markeR_ID: number | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: number | undefined;
    approvE_DT: moment.Moment | undefined;
    thoiHanHopDong: string | undefined;
    donViCongTac: string | undefined;
    linkTemplate: string | undefined;
    loaiHopDongID: number | undefined;
    tenCTY: string | undefined;
    id: number;

    constructor(data?: IHopDongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nhanVienId = data["nhanVienId"];
            this.hoTenNhanVien = data["hoTenNhanVien"];
            this.viTriCongViecCode = data["viTriCongViecCode"];
            this.soHopDong = data["soHopDong"];
            this.ngayKy = data["ngayKy"] ? moment(data["ngayKy"].toString()) : <any>undefined;
            this.donViCongTacID = data["donViCongTacID"];
            this.tenHopDong = data["tenHopDong"];
            this.loaiHopDongCode = data["loaiHopDongCode"];
            this.hinhThucLamViecCode = data["hinhThucLamViecCode"];
            this.ngayCoHieuLuc = data["ngayCoHieuLuc"] ? moment(data["ngayCoHieuLuc"].toString()) : <any>undefined;
            this.ngayHetHan = data["ngayHetHan"] ? moment(data["ngayHetHan"].toString()) : <any>undefined;
            this.luongCoBan = data["luongCoBan"];
            this.luongDongBaoHiem = data["luongDongBaoHiem"];
            this.tyLeHuongLuong = data["tyLeHuongLuong"];
            this.nguoiDaiDienCongTy = data["nguoiDaiDienCongTy"];
            this.chucDanh = data["chucDanh"];
            this.trichYeu = data["trichYeu"];
            this.tepDinhKem = data["tepDinhKem"];
            this.ghiChu = data["ghiChu"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.markeR_ID = data["markeR_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.thoiHanHopDong = data["thoiHanHopDong"];
            this.donViCongTac = data["donViCongTac"];
            this.linkTemplate = data["linkTemplate"];
            this.loaiHopDongID = data["loaiHopDongID"];
            this.tenCTY = data["tenCTY"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HopDongDto {
        data = typeof data === 'object' ? data : {};
        let result = new HopDongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhanVienId"] = this.nhanVienId;
        data["hoTenNhanVien"] = this.hoTenNhanVien;
        data["viTriCongViecCode"] = this.viTriCongViecCode;
        data["soHopDong"] = this.soHopDong;
        data["ngayKy"] = this.ngayKy ? this.ngayKy.toISOString() : <any>undefined;
        data["donViCongTacID"] = this.donViCongTacID;
        data["tenHopDong"] = this.tenHopDong;
        data["loaiHopDongCode"] = this.loaiHopDongCode;
        data["hinhThucLamViecCode"] = this.hinhThucLamViecCode;
        data["ngayCoHieuLuc"] = this.ngayCoHieuLuc ? this.ngayCoHieuLuc.toISOString() : <any>undefined;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        data["luongCoBan"] = this.luongCoBan;
        data["luongDongBaoHiem"] = this.luongDongBaoHiem;
        data["tyLeHuongLuong"] = this.tyLeHuongLuong;
        data["nguoiDaiDienCongTy"] = this.nguoiDaiDienCongTy;
        data["chucDanh"] = this.chucDanh;
        data["trichYeu"] = this.trichYeu;
        data["tepDinhKem"] = this.tepDinhKem;
        data["ghiChu"] = this.ghiChu;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["markeR_ID"] = this.markeR_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["thoiHanHopDong"] = this.thoiHanHopDong;
        data["donViCongTac"] = this.donViCongTac;
        data["linkTemplate"] = this.linkTemplate;
        data["loaiHopDongID"] = this.loaiHopDongID;
        data["tenCTY"] = this.tenCTY;
        data["id"] = this.id;
        return data; 
    }

    clone(): HopDongDto {
        const json = this.toJSON();
        let result = new HopDongDto();
        result.init(json);
        return result;
    }
}

export interface IHopDongDto {
    nhanVienId: string | undefined;
    hoTenNhanVien: string | undefined;
    viTriCongViecCode: string | undefined;
    soHopDong: string | undefined;
    ngayKy: moment.Moment | undefined;
    donViCongTacID: number | undefined;
    tenHopDong: string | undefined;
    loaiHopDongCode: string | undefined;
    hinhThucLamViecCode: string | undefined;
    ngayCoHieuLuc: moment.Moment | undefined;
    ngayHetHan: moment.Moment | undefined;
    luongCoBan: string | undefined;
    luongDongBaoHiem: string | undefined;
    tyLeHuongLuong: number | undefined;
    nguoiDaiDienCongTy: string | undefined;
    chucDanh: string | undefined;
    trichYeu: string | undefined;
    tepDinhKem: string | undefined;
    ghiChu: string | undefined;
    recorD_STATUS: string | undefined;
    markeR_ID: number | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: number | undefined;
    approvE_DT: moment.Moment | undefined;
    thoiHanHopDong: string | undefined;
    donViCongTac: string | undefined;
    linkTemplate: string | undefined;
    loaiHopDongID: number | undefined;
    tenCTY: string | undefined;
    id: number;
}

export class GetHopDongForViewDto implements IGetHopDongForViewDto {
    hopDong: HopDongDto;
    thoiHanhopDongTaoValue: string | undefined;
    donViCongTacValue: string | undefined;
    loaiHopDongValue: string | undefined;
    viTriCongViecValue: string | undefined;
    hinhThucLamViecValue: string | undefined;

    constructor(data?: IGetHopDongForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hopDong = new HopDongDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.hopDong = data["hopDong"] ? HopDongDto.fromJS(data["hopDong"]) : new HopDongDto();
            this.thoiHanhopDongTaoValue = data["thoiHanhopDongTaoValue"];
            this.donViCongTacValue = data["donViCongTacValue"];
            this.loaiHopDongValue = data["loaiHopDongValue"];
            this.viTriCongViecValue = data["viTriCongViecValue"];
            this.hinhThucLamViecValue = data["hinhThucLamViecValue"];
        }
    }

    static fromJS(data: any): GetHopDongForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetHopDongForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hopDong"] = this.hopDong ? this.hopDong.toJSON() : <any>undefined;
        data["thoiHanhopDongTaoValue"] = this.thoiHanhopDongTaoValue;
        data["donViCongTacValue"] = this.donViCongTacValue;
        data["loaiHopDongValue"] = this.loaiHopDongValue;
        data["viTriCongViecValue"] = this.viTriCongViecValue;
        data["hinhThucLamViecValue"] = this.hinhThucLamViecValue;
        return data; 
    }

    clone(): GetHopDongForViewDto {
        const json = this.toJSON();
        let result = new GetHopDongForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetHopDongForViewDto {
    hopDong: HopDongDto;
    thoiHanhopDongTaoValue: string | undefined;
    donViCongTacValue: string | undefined;
    loaiHopDongValue: string | undefined;
    viTriCongViecValue: string | undefined;
    hinhThucLamViecValue: string | undefined;
}

export class PagedResultDtoOfGetHopDongForViewDto implements IPagedResultDtoOfGetHopDongForViewDto {
    totalCount: number;
    items: GetHopDongForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetHopDongForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetHopDongForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetHopDongForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetHopDongForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetHopDongForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetHopDongForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetHopDongForViewDto {
    totalCount: number;
    items: GetHopDongForViewDto[] | undefined;
}

export class CreateOrEditHopDongDto implements ICreateOrEditHopDongDto {
    nhanVienId: string | undefined;
    hoTenNhanVien: string | undefined;
    viTriCongViecCode: string | undefined;
    soHopDong: string | undefined;
    ngayKy: moment.Moment;
    donViCongTacID: number | undefined;
    tenHopDong: string | undefined;
    loaiHopDongCode: string | undefined;
    hinhThucLamViecCode: string | undefined;
    ngayCoHieuLuc: moment.Moment;
    ngayHetHan: moment.Moment;
    luongCoBan: number | undefined;
    luongDongBaoHiem: number | undefined;
    tyLeHuongLuong: number | undefined;
    nguoiDaiDienCongTy: string | undefined;
    chucDanh: string | undefined;
    trichYeu: string | undefined;
    tepDinhKem: string | undefined;
    ghiChu: string | undefined;
    recorD_STATUS: string | undefined;
    markeR_ID: number | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: number | undefined;
    approvE_DT: moment.Moment;
    thoiHanHopDong: string | undefined;
    donViCongTac: string | undefined;
    linkTemplate: string | undefined;
    loaiHopDongID: number | undefined;
    tenCTY: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditHopDongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nhanVienId = data["nhanVienId"];
            this.hoTenNhanVien = data["hoTenNhanVien"];
            this.viTriCongViecCode = data["viTriCongViecCode"];
            this.soHopDong = data["soHopDong"];
            this.ngayKy = data["ngayKy"] ? moment(data["ngayKy"].toString()) : <any>undefined;
            this.donViCongTacID = data["donViCongTacID"];
            this.tenHopDong = data["tenHopDong"];
            this.loaiHopDongCode = data["loaiHopDongCode"];
            this.hinhThucLamViecCode = data["hinhThucLamViecCode"];
            this.ngayCoHieuLuc = data["ngayCoHieuLuc"] ? moment(data["ngayCoHieuLuc"].toString()) : <any>undefined;
            this.ngayHetHan = data["ngayHetHan"] ? moment(data["ngayHetHan"].toString()) : <any>undefined;
            this.luongCoBan = data["luongCoBan"];
            this.luongDongBaoHiem = data["luongDongBaoHiem"];
            this.tyLeHuongLuong = data["tyLeHuongLuong"];
            this.nguoiDaiDienCongTy = data["nguoiDaiDienCongTy"];
            this.chucDanh = data["chucDanh"];
            this.trichYeu = data["trichYeu"];
            this.tepDinhKem = data["tepDinhKem"];
            this.ghiChu = data["ghiChu"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.markeR_ID = data["markeR_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.thoiHanHopDong = data["thoiHanHopDong"];
            this.donViCongTac = data["donViCongTac"];
            this.linkTemplate = data["linkTemplate"];
            this.loaiHopDongID = data["loaiHopDongID"];
            this.tenCTY = data["tenCTY"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditHopDongDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditHopDongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhanVienId"] = this.nhanVienId;
        data["hoTenNhanVien"] = this.hoTenNhanVien;
        data["viTriCongViecCode"] = this.viTriCongViecCode;
        data["soHopDong"] = this.soHopDong;
        data["ngayKy"] = this.ngayKy ? this.ngayKy.toISOString() : <any>undefined;
        data["donViCongTacID"] = this.donViCongTacID;
        data["tenHopDong"] = this.tenHopDong;
        data["loaiHopDongCode"] = this.loaiHopDongCode;
        data["hinhThucLamViecCode"] = this.hinhThucLamViecCode;
        data["ngayCoHieuLuc"] = this.ngayCoHieuLuc ? this.ngayCoHieuLuc.toISOString() : <any>undefined;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        data["luongCoBan"] = this.luongCoBan;
        data["luongDongBaoHiem"] = this.luongDongBaoHiem;
        data["tyLeHuongLuong"] = this.tyLeHuongLuong;
        data["nguoiDaiDienCongTy"] = this.nguoiDaiDienCongTy;
        data["chucDanh"] = this.chucDanh;
        data["trichYeu"] = this.trichYeu;
        data["tepDinhKem"] = this.tepDinhKem;
        data["ghiChu"] = this.ghiChu;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["markeR_ID"] = this.markeR_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["thoiHanHopDong"] = this.thoiHanHopDong;
        data["donViCongTac"] = this.donViCongTac;
        data["linkTemplate"] = this.linkTemplate;
        data["loaiHopDongID"] = this.loaiHopDongID;
        data["tenCTY"] = this.tenCTY;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditHopDongDto {
        const json = this.toJSON();
        let result = new CreateOrEditHopDongDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditHopDongDto {
    nhanVienId: string | undefined;
    hoTenNhanVien: string | undefined;
    viTriCongViecCode: string | undefined;
    soHopDong: string | undefined;
    ngayKy: moment.Moment;
    donViCongTacID: number | undefined;
    tenHopDong: string | undefined;
    loaiHopDongCode: string | undefined;
    hinhThucLamViecCode: string | undefined;
    ngayCoHieuLuc: moment.Moment;
    ngayHetHan: moment.Moment;
    luongCoBan: number | undefined;
    luongDongBaoHiem: number | undefined;
    tyLeHuongLuong: number | undefined;
    nguoiDaiDienCongTy: string | undefined;
    chucDanh: string | undefined;
    trichYeu: string | undefined;
    tepDinhKem: string | undefined;
    ghiChu: string | undefined;
    recorD_STATUS: string | undefined;
    markeR_ID: number | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: number | undefined;
    approvE_DT: moment.Moment;
    thoiHanHopDong: string | undefined;
    donViCongTac: string | undefined;
    linkTemplate: string | undefined;
    loaiHopDongID: number | undefined;
    tenCTY: string | undefined;
    id: number | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfOrganizationUnitDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class NoiDaoTaoDto implements INoiDaoTaoDto {
    tenNoiDaoTao: string | undefined;
    maNoiDaoTao: string | undefined;
    diaChi: string | undefined;
    khuVuc: string | undefined;
    id: number;

    constructor(data?: INoiDaoTaoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenNoiDaoTao = data["tenNoiDaoTao"];
            this.maNoiDaoTao = data["maNoiDaoTao"];
            this.diaChi = data["diaChi"];
            this.khuVuc = data["khuVuc"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): NoiDaoTaoDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoiDaoTaoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenNoiDaoTao"] = this.tenNoiDaoTao;
        data["maNoiDaoTao"] = this.maNoiDaoTao;
        data["diaChi"] = this.diaChi;
        data["khuVuc"] = this.khuVuc;
        data["id"] = this.id;
        return data; 
    }

    clone(): NoiDaoTaoDto {
        const json = this.toJSON();
        let result = new NoiDaoTaoDto();
        result.init(json);
        return result;
    }
}

export interface INoiDaoTaoDto {
    tenNoiDaoTao: string | undefined;
    maNoiDaoTao: string | undefined;
    diaChi: string | undefined;
    khuVuc: string | undefined;
    id: number;
}

export class TinhThanhDto implements ITinhThanhDto {
    tenTinhThanh: string | undefined;
    maTinhThanh: string | undefined;
    id: number;

    constructor(data?: ITinhThanhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenTinhThanh = data["tenTinhThanh"];
            this.maTinhThanh = data["maTinhThanh"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TinhThanhDto {
        data = typeof data === 'object' ? data : {};
        let result = new TinhThanhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenTinhThanh"] = this.tenTinhThanh;
        data["maTinhThanh"] = this.maTinhThanh;
        data["id"] = this.id;
        return data; 
    }

    clone(): TinhThanhDto {
        const json = this.toJSON();
        let result = new TinhThanhDto();
        result.init(json);
        return result;
    }
}

export interface ITinhThanhDto {
    tenTinhThanh: string | undefined;
    maTinhThanh: string | undefined;
    id: number;
}

export class TemplateDto implements ITemplateDto {
    maTemplate: string | undefined;
    tenTemplate: string | undefined;
    linkTemplate: string | undefined;
    ghiChu: string | undefined;
    noiDung: string | undefined;
    id: number;

    constructor(data?: ITemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maTemplate = data["maTemplate"];
            this.tenTemplate = data["tenTemplate"];
            this.linkTemplate = data["linkTemplate"];
            this.ghiChu = data["ghiChu"];
            this.noiDung = data["noiDung"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maTemplate"] = this.maTemplate;
        data["tenTemplate"] = this.tenTemplate;
        data["linkTemplate"] = this.linkTemplate;
        data["ghiChu"] = this.ghiChu;
        data["noiDung"] = this.noiDung;
        data["id"] = this.id;
        return data; 
    }

    clone(): TemplateDto {
        const json = this.toJSON();
        let result = new TemplateDto();
        result.init(json);
        return result;
    }
}

export interface ITemplateDto {
    maTemplate: string | undefined;
    tenTemplate: string | undefined;
    linkTemplate: string | undefined;
    ghiChu: string | undefined;
    noiDung: string | undefined;
    id: number;
}

export class LichSuLamViecDto implements ILichSuLamViecDto {
    ungVienId: number | undefined;
    phieuNghiPhepID: number | undefined;
    noiDung: string | undefined;
    chuDe: string | undefined;
    tepDinhKem: string | undefined;
    fullName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ILichSuLamViecDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ungVienId = data["ungVienId"];
            this.phieuNghiPhepID = data["phieuNghiPhepID"];
            this.noiDung = data["noiDung"];
            this.chuDe = data["chuDe"];
            this.tepDinhKem = data["tepDinhKem"];
            this.fullName = data["fullName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LichSuLamViecDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichSuLamViecDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ungVienId"] = this.ungVienId;
        data["phieuNghiPhepID"] = this.phieuNghiPhepID;
        data["noiDung"] = this.noiDung;
        data["chuDe"] = this.chuDe;
        data["tepDinhKem"] = this.tepDinhKem;
        data["fullName"] = this.fullName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LichSuLamViecDto {
        const json = this.toJSON();
        let result = new LichSuLamViecDto();
        result.init(json);
        return result;
    }
}

export interface ILichSuLamViecDto {
    ungVienId: number | undefined;
    phieuNghiPhepID: number | undefined;
    noiDung: string | undefined;
    chuDe: string | undefined;
    tepDinhKem: string | undefined;
    fullName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class LichSuUploadDto implements ILichSuUploadDto {
    tenFile: string | undefined;
    dungLuong: string | undefined;
    tieuDe: string | undefined;
    type: string | undefined;
    typeID: string | undefined;
    id: number;

    constructor(data?: ILichSuUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenFile = data["tenFile"];
            this.dungLuong = data["dungLuong"];
            this.tieuDe = data["tieuDe"];
            this.type = data["type"];
            this.typeID = data["typeID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LichSuUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichSuUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenFile"] = this.tenFile;
        data["dungLuong"] = this.dungLuong;
        data["tieuDe"] = this.tieuDe;
        data["type"] = this.type;
        data["typeID"] = this.typeID;
        data["id"] = this.id;
        return data; 
    }

    clone(): LichSuUploadDto {
        const json = this.toJSON();
        let result = new LichSuUploadDto();
        result.init(json);
        return result;
    }
}

export interface ILichSuUploadDto {
    tenFile: string | undefined;
    dungLuong: string | undefined;
    tieuDe: string | undefined;
    type: string | undefined;
    typeID: string | undefined;
    id: number;
}

export class GetHopDongForEditOutput implements IGetHopDongForEditOutput {
    hopDong: CreateOrEditHopDongDto;
    organizationUnitList: ListResultDtoOfOrganizationUnitDto;
    noiDaoTaoList: NoiDaoTaoDto[] | undefined;
    tinhThanhList: TinhThanhDto[] | undefined;
    templateList: TemplateDto[] | undefined;
    congViecList: OrganizationUnitDto[] | undefined;
    lichSuLamViecList: LichSuLamViecDto[] | undefined;
    lichSuUploadList: LichSuUploadDto[] | undefined;
    configEmail: GetConfigEmailForViewDto;
    viTriCongViec: TruongGiaoDichDto[] | undefined;
    tienDoTuyenDung: TruongGiaoDichDto[] | undefined;
    trangThai: TruongGiaoDichDto[] | undefined;
    kenhTuyenDung: TruongGiaoDichDto[] | undefined;
    congty: TruongGiaoDichDto[] | undefined;
    gioiTinh: TruongGiaoDichDto[] | undefined;
    tinhTrangHonNhan: TruongGiaoDichDto[] | undefined;
    trinhDoDaoTao: TruongGiaoDichDto[] | undefined;
    xepLoaiHocLuc: TruongGiaoDichDto[] | undefined;
    hinhThucLamViec: TruongGiaoDichDto[] | undefined;
    thoiHanHopDong: TruongGiaoDichDto[] | undefined;
    defaultCbbOption: TruongGiaoDichDto[] | undefined;

    constructor(data?: IGetHopDongForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hopDong = new CreateOrEditHopDongDto();
            this.organizationUnitList = new ListResultDtoOfOrganizationUnitDto();
            this.configEmail = new GetConfigEmailForViewDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.hopDong = data["hopDong"] ? CreateOrEditHopDongDto.fromJS(data["hopDong"]) : new CreateOrEditHopDongDto();
            this.organizationUnitList = data["organizationUnitList"] ? ListResultDtoOfOrganizationUnitDto.fromJS(data["organizationUnitList"]) : new ListResultDtoOfOrganizationUnitDto();
            if (data["noiDaoTaoList"] && data["noiDaoTaoList"].constructor === Array) {
                this.noiDaoTaoList = [];
                for (let item of data["noiDaoTaoList"])
                    this.noiDaoTaoList.push(NoiDaoTaoDto.fromJS(item));
            }
            if (data["tinhThanhList"] && data["tinhThanhList"].constructor === Array) {
                this.tinhThanhList = [];
                for (let item of data["tinhThanhList"])
                    this.tinhThanhList.push(TinhThanhDto.fromJS(item));
            }
            if (data["templateList"] && data["templateList"].constructor === Array) {
                this.templateList = [];
                for (let item of data["templateList"])
                    this.templateList.push(TemplateDto.fromJS(item));
            }
            if (data["congViecList"] && data["congViecList"].constructor === Array) {
                this.congViecList = [];
                for (let item of data["congViecList"])
                    this.congViecList.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["lichSuLamViecList"] && data["lichSuLamViecList"].constructor === Array) {
                this.lichSuLamViecList = [];
                for (let item of data["lichSuLamViecList"])
                    this.lichSuLamViecList.push(LichSuLamViecDto.fromJS(item));
            }
            if (data["lichSuUploadList"] && data["lichSuUploadList"].constructor === Array) {
                this.lichSuUploadList = [];
                for (let item of data["lichSuUploadList"])
                    this.lichSuUploadList.push(LichSuUploadDto.fromJS(item));
            }
            this.configEmail = data["configEmail"] ? GetConfigEmailForViewDto.fromJS(data["configEmail"]) : new GetConfigEmailForViewDto();
            if (data["viTriCongViec"] && data["viTriCongViec"].constructor === Array) {
                this.viTriCongViec = [];
                for (let item of data["viTriCongViec"])
                    this.viTriCongViec.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["tienDoTuyenDung"] && data["tienDoTuyenDung"].constructor === Array) {
                this.tienDoTuyenDung = [];
                for (let item of data["tienDoTuyenDung"])
                    this.tienDoTuyenDung.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["trangThai"] && data["trangThai"].constructor === Array) {
                this.trangThai = [];
                for (let item of data["trangThai"])
                    this.trangThai.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["kenhTuyenDung"] && data["kenhTuyenDung"].constructor === Array) {
                this.kenhTuyenDung = [];
                for (let item of data["kenhTuyenDung"])
                    this.kenhTuyenDung.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["congty"] && data["congty"].constructor === Array) {
                this.congty = [];
                for (let item of data["congty"])
                    this.congty.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["gioiTinh"] && data["gioiTinh"].constructor === Array) {
                this.gioiTinh = [];
                for (let item of data["gioiTinh"])
                    this.gioiTinh.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["tinhTrangHonNhan"] && data["tinhTrangHonNhan"].constructor === Array) {
                this.tinhTrangHonNhan = [];
                for (let item of data["tinhTrangHonNhan"])
                    this.tinhTrangHonNhan.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["trinhDoDaoTao"] && data["trinhDoDaoTao"].constructor === Array) {
                this.trinhDoDaoTao = [];
                for (let item of data["trinhDoDaoTao"])
                    this.trinhDoDaoTao.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["xepLoaiHocLuc"] && data["xepLoaiHocLuc"].constructor === Array) {
                this.xepLoaiHocLuc = [];
                for (let item of data["xepLoaiHocLuc"])
                    this.xepLoaiHocLuc.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["hinhThucLamViec"] && data["hinhThucLamViec"].constructor === Array) {
                this.hinhThucLamViec = [];
                for (let item of data["hinhThucLamViec"])
                    this.hinhThucLamViec.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["thoiHanHopDong"] && data["thoiHanHopDong"].constructor === Array) {
                this.thoiHanHopDong = [];
                for (let item of data["thoiHanHopDong"])
                    this.thoiHanHopDong.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["defaultCbbOption"] && data["defaultCbbOption"].constructor === Array) {
                this.defaultCbbOption = [];
                for (let item of data["defaultCbbOption"])
                    this.defaultCbbOption.push(TruongGiaoDichDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetHopDongForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetHopDongForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hopDong"] = this.hopDong ? this.hopDong.toJSON() : <any>undefined;
        data["organizationUnitList"] = this.organizationUnitList ? this.organizationUnitList.toJSON() : <any>undefined;
        if (this.noiDaoTaoList && this.noiDaoTaoList.constructor === Array) {
            data["noiDaoTaoList"] = [];
            for (let item of this.noiDaoTaoList)
                data["noiDaoTaoList"].push(item.toJSON());
        }
        if (this.tinhThanhList && this.tinhThanhList.constructor === Array) {
            data["tinhThanhList"] = [];
            for (let item of this.tinhThanhList)
                data["tinhThanhList"].push(item.toJSON());
        }
        if (this.templateList && this.templateList.constructor === Array) {
            data["templateList"] = [];
            for (let item of this.templateList)
                data["templateList"].push(item.toJSON());
        }
        if (this.congViecList && this.congViecList.constructor === Array) {
            data["congViecList"] = [];
            for (let item of this.congViecList)
                data["congViecList"].push(item.toJSON());
        }
        if (this.lichSuLamViecList && this.lichSuLamViecList.constructor === Array) {
            data["lichSuLamViecList"] = [];
            for (let item of this.lichSuLamViecList)
                data["lichSuLamViecList"].push(item.toJSON());
        }
        if (this.lichSuUploadList && this.lichSuUploadList.constructor === Array) {
            data["lichSuUploadList"] = [];
            for (let item of this.lichSuUploadList)
                data["lichSuUploadList"].push(item.toJSON());
        }
        data["configEmail"] = this.configEmail ? this.configEmail.toJSON() : <any>undefined;
        if (this.viTriCongViec && this.viTriCongViec.constructor === Array) {
            data["viTriCongViec"] = [];
            for (let item of this.viTriCongViec)
                data["viTriCongViec"].push(item.toJSON());
        }
        if (this.tienDoTuyenDung && this.tienDoTuyenDung.constructor === Array) {
            data["tienDoTuyenDung"] = [];
            for (let item of this.tienDoTuyenDung)
                data["tienDoTuyenDung"].push(item.toJSON());
        }
        if (this.trangThai && this.trangThai.constructor === Array) {
            data["trangThai"] = [];
            for (let item of this.trangThai)
                data["trangThai"].push(item.toJSON());
        }
        if (this.kenhTuyenDung && this.kenhTuyenDung.constructor === Array) {
            data["kenhTuyenDung"] = [];
            for (let item of this.kenhTuyenDung)
                data["kenhTuyenDung"].push(item.toJSON());
        }
        if (this.congty && this.congty.constructor === Array) {
            data["congty"] = [];
            for (let item of this.congty)
                data["congty"].push(item.toJSON());
        }
        if (this.gioiTinh && this.gioiTinh.constructor === Array) {
            data["gioiTinh"] = [];
            for (let item of this.gioiTinh)
                data["gioiTinh"].push(item.toJSON());
        }
        if (this.tinhTrangHonNhan && this.tinhTrangHonNhan.constructor === Array) {
            data["tinhTrangHonNhan"] = [];
            for (let item of this.tinhTrangHonNhan)
                data["tinhTrangHonNhan"].push(item.toJSON());
        }
        if (this.trinhDoDaoTao && this.trinhDoDaoTao.constructor === Array) {
            data["trinhDoDaoTao"] = [];
            for (let item of this.trinhDoDaoTao)
                data["trinhDoDaoTao"].push(item.toJSON());
        }
        if (this.xepLoaiHocLuc && this.xepLoaiHocLuc.constructor === Array) {
            data["xepLoaiHocLuc"] = [];
            for (let item of this.xepLoaiHocLuc)
                data["xepLoaiHocLuc"].push(item.toJSON());
        }
        if (this.hinhThucLamViec && this.hinhThucLamViec.constructor === Array) {
            data["hinhThucLamViec"] = [];
            for (let item of this.hinhThucLamViec)
                data["hinhThucLamViec"].push(item.toJSON());
        }
        if (this.thoiHanHopDong && this.thoiHanHopDong.constructor === Array) {
            data["thoiHanHopDong"] = [];
            for (let item of this.thoiHanHopDong)
                data["thoiHanHopDong"].push(item.toJSON());
        }
        if (this.defaultCbbOption && this.defaultCbbOption.constructor === Array) {
            data["defaultCbbOption"] = [];
            for (let item of this.defaultCbbOption)
                data["defaultCbbOption"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetHopDongForEditOutput {
        const json = this.toJSON();
        let result = new GetHopDongForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetHopDongForEditOutput {
    hopDong: CreateOrEditHopDongDto;
    organizationUnitList: ListResultDtoOfOrganizationUnitDto;
    noiDaoTaoList: NoiDaoTaoDto[] | undefined;
    tinhThanhList: TinhThanhDto[] | undefined;
    templateList: TemplateDto[] | undefined;
    congViecList: OrganizationUnitDto[] | undefined;
    lichSuLamViecList: LichSuLamViecDto[] | undefined;
    lichSuUploadList: LichSuUploadDto[] | undefined;
    configEmail: GetConfigEmailForViewDto;
    viTriCongViec: TruongGiaoDichDto[] | undefined;
    tienDoTuyenDung: TruongGiaoDichDto[] | undefined;
    trangThai: TruongGiaoDichDto[] | undefined;
    kenhTuyenDung: TruongGiaoDichDto[] | undefined;
    congty: TruongGiaoDichDto[] | undefined;
    gioiTinh: TruongGiaoDichDto[] | undefined;
    tinhTrangHonNhan: TruongGiaoDichDto[] | undefined;
    trinhDoDaoTao: TruongGiaoDichDto[] | undefined;
    xepLoaiHocLuc: TruongGiaoDichDto[] | undefined;
    hinhThucLamViec: TruongGiaoDichDto[] | undefined;
    thoiHanHopDong: TruongGiaoDichDto[] | undefined;
    defaultCbbOption: TruongGiaoDichDto[] | undefined;
}

export class LichSuUploadNewDto implements ILichSuUploadNewDto {
    tenFile: string | undefined;
    dungLuong: string | undefined;
    tieuDe: string | undefined;
    id: number;

    constructor(data?: ILichSuUploadNewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenFile = data["tenFile"];
            this.dungLuong = data["dungLuong"];
            this.tieuDe = data["tieuDe"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LichSuUploadNewDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichSuUploadNewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenFile"] = this.tenFile;
        data["dungLuong"] = this.dungLuong;
        data["tieuDe"] = this.tieuDe;
        data["id"] = this.id;
        return data; 
    }

    clone(): LichSuUploadNewDto {
        const json = this.toJSON();
        let result = new LichSuUploadNewDto();
        result.init(json);
        return result;
    }
}

export interface ILichSuUploadNewDto {
    tenFile: string | undefined;
    dungLuong: string | undefined;
    tieuDe: string | undefined;
    id: number;
}

export class CreateOrEditHopDongInput implements ICreateOrEditHopDongInput {
    hopDong: CreateOrEditHopDongDto;
    lichSuUpLoad: LichSuUploadNewDto[] | undefined;

    constructor(data?: ICreateOrEditHopDongInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hopDong = new CreateOrEditHopDongDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.hopDong = data["hopDong"] ? CreateOrEditHopDongDto.fromJS(data["hopDong"]) : new CreateOrEditHopDongDto();
            if (data["lichSuUpLoad"] && data["lichSuUpLoad"].constructor === Array) {
                this.lichSuUpLoad = [];
                for (let item of data["lichSuUpLoad"])
                    this.lichSuUpLoad.push(LichSuUploadNewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrEditHopDongInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditHopDongInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hopDong"] = this.hopDong ? this.hopDong.toJSON() : <any>undefined;
        if (this.lichSuUpLoad && this.lichSuUpLoad.constructor === Array) {
            data["lichSuUpLoad"] = [];
            for (let item of this.lichSuUpLoad)
                data["lichSuUpLoad"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateOrEditHopDongInput {
        const json = this.toJSON();
        let result = new CreateOrEditHopDongInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditHopDongInput {
    hopDong: CreateOrEditHopDongDto;
    lichSuUpLoad: LichSuUploadNewDto[] | undefined;
}

export class HoSoDto implements IHoSoDto {
    maHoSo: string | undefined;
    tenCty: string | undefined;
    sdt: string | undefined;
    hopDongHienTai: string | undefined;
    soHD: string | undefined;
    donViCongTacName: string | undefined;
    choNgoi: string | undefined;
    noiDaoTaoID: number | undefined;
    loaiHopDongID: number | undefined;
    maSoNoiKCB: string | undefined;
    noiDangKyKCBID: number | undefined;
    ngayHetHanBHYT: moment.Moment | undefined;
    soTheBHYT: string | undefined;
    maTinhCap: string | undefined;
    maSoBHXH: string | undefined;
    soSoBHXH: string | undefined;
    tyLeDongBH: number;
    ngayThamGiaBH: moment.Moment | undefined;
    thamGiaCongDoan: boolean;
    nganHangCode: string | undefined;
    tkNganHang: string | undefined;
    donViSoCongChuanCode: string | undefined;
    soCongChuan: string | undefined;
    luongDongBH: string | undefined;
    luongCoBan: string | undefined;
    bacLuongCode: string | undefined;
    soNgayPhep: number;
    ngayChinhThuc: moment.Moment | undefined;
    ngayThuViec: moment.Moment | undefined;
    ngayTapSu: moment.Moment | undefined;
    soSoQLLaoDong: string | undefined;
    diaDiemLamViecCode: string | undefined;
    quanLyGianTiep: string | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiLamViecCode: string | undefined;
    bac: string | undefined;
    cap: string | undefined;
    chucDanh: string | undefined;
    maChamCong: string | undefined;
    diaChiLHKC: string | undefined;
    emailLHKC: string | undefined;
    dtDiDongLHKC: string | undefined;
    dtNhaRiengLHKC: string | undefined;
    quanHeLHKC: string | undefined;
    hoVaTenLHKC: string | undefined;
    diaChiHN: string | undefined;
    tinhThanhIDHN: number | undefined;
    quocGiaHN: string | undefined;
    laChuHo: boolean;
    maSoHoGiaDinh: string | undefined;
    soSoHoKhau: string | undefined;
    diaChiHKTT: string | undefined;
    tinhThanhIDHKTT: number | undefined;
    tinhThanhID: number | undefined;
    quocGiaHKTT: string | undefined;
    facebook: string | undefined;
    skype: string | undefined;
    noiSinh: string | undefined;
    nguyenQuan: string | undefined;
    emailKhac: string | undefined;
    emailCoQuan: string | undefined;
    emailCaNhan: string | undefined;
    dtKhac: string | undefined;
    dtNhaRieng: string | undefined;
    dtCoQuan: string | undefined;
    dtDiDong: string | undefined;
    tepDinhKem: string | undefined;
    tinhTrangHonNhanCode: string | undefined;
    xepLoaiCode: string | undefined;
    namTotNghiep: number;
    chuyenNganh: string | undefined;
    khoa: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    trinhDoVanHoa: string | undefined;
    ngayHetHan: moment.Moment | undefined;
    noiCap: string | undefined;
    ngayCap: moment.Moment | undefined;
    soCMND: string | undefined;
    quocTich: string | undefined;
    tonGiao: string | undefined;
    danToc: string | undefined;
    viTriCongViecCode: string | undefined;
    donViCongTacID: number | undefined;
    mstCaNhan: string | undefined;
    ngaySinh: moment.Moment | undefined;
    gioiTinhCode: string | undefined;
    anhDaiDien: string | undefined;
    hoVaTen: string | undefined;
    maNhanVien: string | undefined;
    chiNhanh: string | undefined;
    dvt: string | undefined;
    ngayKyHDKTH: moment.Moment | undefined;
    ngayKyHD36TH: moment.Moment | undefined;
    ngayKyHD12TH: moment.Moment | undefined;
    ngayKyHDTV: moment.Moment | undefined;
    ngayKYHDCTV: moment.Moment | undefined;
    ngayKyHDKV: moment.Moment | undefined;
    ngayKYHDTT: moment.Moment | undefined;
    ngayKyHD: moment.Moment | undefined;
    nguoiNhapCV: string | undefined;
    id: number;

    constructor(data?: IHoSoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maHoSo = data["maHoSo"];
            this.tenCty = data["tenCty"];
            this.sdt = data["sdt"];
            this.hopDongHienTai = data["hopDongHienTai"];
            this.soHD = data["soHD"];
            this.donViCongTacName = data["donViCongTacName"];
            this.choNgoi = data["choNgoi"];
            this.noiDaoTaoID = data["noiDaoTaoID"];
            this.loaiHopDongID = data["loaiHopDongID"];
            this.maSoNoiKCB = data["maSoNoiKCB"];
            this.noiDangKyKCBID = data["noiDangKyKCBID"];
            this.ngayHetHanBHYT = data["ngayHetHanBHYT"] ? moment(data["ngayHetHanBHYT"].toString()) : <any>undefined;
            this.soTheBHYT = data["soTheBHYT"];
            this.maTinhCap = data["maTinhCap"];
            this.maSoBHXH = data["maSoBHXH"];
            this.soSoBHXH = data["soSoBHXH"];
            this.tyLeDongBH = data["tyLeDongBH"];
            this.ngayThamGiaBH = data["ngayThamGiaBH"] ? moment(data["ngayThamGiaBH"].toString()) : <any>undefined;
            this.thamGiaCongDoan = data["thamGiaCongDoan"];
            this.nganHangCode = data["nganHangCode"];
            this.tkNganHang = data["tkNganHang"];
            this.donViSoCongChuanCode = data["donViSoCongChuanCode"];
            this.soCongChuan = data["soCongChuan"];
            this.luongDongBH = data["luongDongBH"];
            this.luongCoBan = data["luongCoBan"];
            this.bacLuongCode = data["bacLuongCode"];
            this.soNgayPhep = data["soNgayPhep"];
            this.ngayChinhThuc = data["ngayChinhThuc"] ? moment(data["ngayChinhThuc"].toString()) : <any>undefined;
            this.ngayThuViec = data["ngayThuViec"] ? moment(data["ngayThuViec"].toString()) : <any>undefined;
            this.ngayTapSu = data["ngayTapSu"] ? moment(data["ngayTapSu"].toString()) : <any>undefined;
            this.soSoQLLaoDong = data["soSoQLLaoDong"];
            this.diaDiemLamViecCode = data["diaDiemLamViecCode"];
            this.quanLyGianTiep = data["quanLyGianTiep"];
            this.quanLyTrucTiep = data["quanLyTrucTiep"];
            this.trangThaiLamViecCode = data["trangThaiLamViecCode"];
            this.bac = data["bac"];
            this.cap = data["cap"];
            this.chucDanh = data["chucDanh"];
            this.maChamCong = data["maChamCong"];
            this.diaChiLHKC = data["diaChiLHKC"];
            this.emailLHKC = data["emailLHKC"];
            this.dtDiDongLHKC = data["dtDiDongLHKC"];
            this.dtNhaRiengLHKC = data["dtNhaRiengLHKC"];
            this.quanHeLHKC = data["quanHeLHKC"];
            this.hoVaTenLHKC = data["hoVaTenLHKC"];
            this.diaChiHN = data["diaChiHN"];
            this.tinhThanhIDHN = data["tinhThanhIDHN"];
            this.quocGiaHN = data["quocGiaHN"];
            this.laChuHo = data["laChuHo"];
            this.maSoHoGiaDinh = data["maSoHoGiaDinh"];
            this.soSoHoKhau = data["soSoHoKhau"];
            this.diaChiHKTT = data["diaChiHKTT"];
            this.tinhThanhIDHKTT = data["tinhThanhIDHKTT"];
            this.tinhThanhID = data["tinhThanhID"];
            this.quocGiaHKTT = data["quocGiaHKTT"];
            this.facebook = data["facebook"];
            this.skype = data["skype"];
            this.noiSinh = data["noiSinh"];
            this.nguyenQuan = data["nguyenQuan"];
            this.emailKhac = data["emailKhac"];
            this.emailCoQuan = data["emailCoQuan"];
            this.emailCaNhan = data["emailCaNhan"];
            this.dtKhac = data["dtKhac"];
            this.dtNhaRieng = data["dtNhaRieng"];
            this.dtCoQuan = data["dtCoQuan"];
            this.dtDiDong = data["dtDiDong"];
            this.tepDinhKem = data["tepDinhKem"];
            this.tinhTrangHonNhanCode = data["tinhTrangHonNhanCode"];
            this.xepLoaiCode = data["xepLoaiCode"];
            this.namTotNghiep = data["namTotNghiep"];
            this.chuyenNganh = data["chuyenNganh"];
            this.khoa = data["khoa"];
            this.trinhDoDaoTaoCode = data["trinhDoDaoTaoCode"];
            this.trinhDoVanHoa = data["trinhDoVanHoa"];
            this.ngayHetHan = data["ngayHetHan"] ? moment(data["ngayHetHan"].toString()) : <any>undefined;
            this.noiCap = data["noiCap"];
            this.ngayCap = data["ngayCap"] ? moment(data["ngayCap"].toString()) : <any>undefined;
            this.soCMND = data["soCMND"];
            this.quocTich = data["quocTich"];
            this.tonGiao = data["tonGiao"];
            this.danToc = data["danToc"];
            this.viTriCongViecCode = data["viTriCongViecCode"];
            this.donViCongTacID = data["donViCongTacID"];
            this.mstCaNhan = data["mstCaNhan"];
            this.ngaySinh = data["ngaySinh"] ? moment(data["ngaySinh"].toString()) : <any>undefined;
            this.gioiTinhCode = data["gioiTinhCode"];
            this.anhDaiDien = data["anhDaiDien"];
            this.hoVaTen = data["hoVaTen"];
            this.maNhanVien = data["maNhanVien"];
            this.chiNhanh = data["chiNhanh"];
            this.dvt = data["dvt"];
            this.ngayKyHDKTH = data["ngayKyHDKTH"] ? moment(data["ngayKyHDKTH"].toString()) : <any>undefined;
            this.ngayKyHD36TH = data["ngayKyHD36TH"] ? moment(data["ngayKyHD36TH"].toString()) : <any>undefined;
            this.ngayKyHD12TH = data["ngayKyHD12TH"] ? moment(data["ngayKyHD12TH"].toString()) : <any>undefined;
            this.ngayKyHDTV = data["ngayKyHDTV"] ? moment(data["ngayKyHDTV"].toString()) : <any>undefined;
            this.ngayKYHDCTV = data["ngayKYHDCTV"] ? moment(data["ngayKYHDCTV"].toString()) : <any>undefined;
            this.ngayKyHDKV = data["ngayKyHDKV"] ? moment(data["ngayKyHDKV"].toString()) : <any>undefined;
            this.ngayKYHDTT = data["ngayKYHDTT"] ? moment(data["ngayKYHDTT"].toString()) : <any>undefined;
            this.ngayKyHD = data["ngayKyHD"] ? moment(data["ngayKyHD"].toString()) : <any>undefined;
            this.nguoiNhapCV = data["nguoiNhapCV"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HoSoDto {
        data = typeof data === 'object' ? data : {};
        let result = new HoSoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maHoSo"] = this.maHoSo;
        data["tenCty"] = this.tenCty;
        data["sdt"] = this.sdt;
        data["hopDongHienTai"] = this.hopDongHienTai;
        data["soHD"] = this.soHD;
        data["donViCongTacName"] = this.donViCongTacName;
        data["choNgoi"] = this.choNgoi;
        data["noiDaoTaoID"] = this.noiDaoTaoID;
        data["loaiHopDongID"] = this.loaiHopDongID;
        data["maSoNoiKCB"] = this.maSoNoiKCB;
        data["noiDangKyKCBID"] = this.noiDangKyKCBID;
        data["ngayHetHanBHYT"] = this.ngayHetHanBHYT ? this.ngayHetHanBHYT.toISOString() : <any>undefined;
        data["soTheBHYT"] = this.soTheBHYT;
        data["maTinhCap"] = this.maTinhCap;
        data["maSoBHXH"] = this.maSoBHXH;
        data["soSoBHXH"] = this.soSoBHXH;
        data["tyLeDongBH"] = this.tyLeDongBH;
        data["ngayThamGiaBH"] = this.ngayThamGiaBH ? this.ngayThamGiaBH.toISOString() : <any>undefined;
        data["thamGiaCongDoan"] = this.thamGiaCongDoan;
        data["nganHangCode"] = this.nganHangCode;
        data["tkNganHang"] = this.tkNganHang;
        data["donViSoCongChuanCode"] = this.donViSoCongChuanCode;
        data["soCongChuan"] = this.soCongChuan;
        data["luongDongBH"] = this.luongDongBH;
        data["luongCoBan"] = this.luongCoBan;
        data["bacLuongCode"] = this.bacLuongCode;
        data["soNgayPhep"] = this.soNgayPhep;
        data["ngayChinhThuc"] = this.ngayChinhThuc ? this.ngayChinhThuc.toISOString() : <any>undefined;
        data["ngayThuViec"] = this.ngayThuViec ? this.ngayThuViec.toISOString() : <any>undefined;
        data["ngayTapSu"] = this.ngayTapSu ? this.ngayTapSu.toISOString() : <any>undefined;
        data["soSoQLLaoDong"] = this.soSoQLLaoDong;
        data["diaDiemLamViecCode"] = this.diaDiemLamViecCode;
        data["quanLyGianTiep"] = this.quanLyGianTiep;
        data["quanLyTrucTiep"] = this.quanLyTrucTiep;
        data["trangThaiLamViecCode"] = this.trangThaiLamViecCode;
        data["bac"] = this.bac;
        data["cap"] = this.cap;
        data["chucDanh"] = this.chucDanh;
        data["maChamCong"] = this.maChamCong;
        data["diaChiLHKC"] = this.diaChiLHKC;
        data["emailLHKC"] = this.emailLHKC;
        data["dtDiDongLHKC"] = this.dtDiDongLHKC;
        data["dtNhaRiengLHKC"] = this.dtNhaRiengLHKC;
        data["quanHeLHKC"] = this.quanHeLHKC;
        data["hoVaTenLHKC"] = this.hoVaTenLHKC;
        data["diaChiHN"] = this.diaChiHN;
        data["tinhThanhIDHN"] = this.tinhThanhIDHN;
        data["quocGiaHN"] = this.quocGiaHN;
        data["laChuHo"] = this.laChuHo;
        data["maSoHoGiaDinh"] = this.maSoHoGiaDinh;
        data["soSoHoKhau"] = this.soSoHoKhau;
        data["diaChiHKTT"] = this.diaChiHKTT;
        data["tinhThanhIDHKTT"] = this.tinhThanhIDHKTT;
        data["tinhThanhID"] = this.tinhThanhID;
        data["quocGiaHKTT"] = this.quocGiaHKTT;
        data["facebook"] = this.facebook;
        data["skype"] = this.skype;
        data["noiSinh"] = this.noiSinh;
        data["nguyenQuan"] = this.nguyenQuan;
        data["emailKhac"] = this.emailKhac;
        data["emailCoQuan"] = this.emailCoQuan;
        data["emailCaNhan"] = this.emailCaNhan;
        data["dtKhac"] = this.dtKhac;
        data["dtNhaRieng"] = this.dtNhaRieng;
        data["dtCoQuan"] = this.dtCoQuan;
        data["dtDiDong"] = this.dtDiDong;
        data["tepDinhKem"] = this.tepDinhKem;
        data["tinhTrangHonNhanCode"] = this.tinhTrangHonNhanCode;
        data["xepLoaiCode"] = this.xepLoaiCode;
        data["namTotNghiep"] = this.namTotNghiep;
        data["chuyenNganh"] = this.chuyenNganh;
        data["khoa"] = this.khoa;
        data["trinhDoDaoTaoCode"] = this.trinhDoDaoTaoCode;
        data["trinhDoVanHoa"] = this.trinhDoVanHoa;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        data["noiCap"] = this.noiCap;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["soCMND"] = this.soCMND;
        data["quocTich"] = this.quocTich;
        data["tonGiao"] = this.tonGiao;
        data["danToc"] = this.danToc;
        data["viTriCongViecCode"] = this.viTriCongViecCode;
        data["donViCongTacID"] = this.donViCongTacID;
        data["mstCaNhan"] = this.mstCaNhan;
        data["ngaySinh"] = this.ngaySinh ? this.ngaySinh.toISOString() : <any>undefined;
        data["gioiTinhCode"] = this.gioiTinhCode;
        data["anhDaiDien"] = this.anhDaiDien;
        data["hoVaTen"] = this.hoVaTen;
        data["maNhanVien"] = this.maNhanVien;
        data["chiNhanh"] = this.chiNhanh;
        data["dvt"] = this.dvt;
        data["ngayKyHDKTH"] = this.ngayKyHDKTH ? this.ngayKyHDKTH.toISOString() : <any>undefined;
        data["ngayKyHD36TH"] = this.ngayKyHD36TH ? this.ngayKyHD36TH.toISOString() : <any>undefined;
        data["ngayKyHD12TH"] = this.ngayKyHD12TH ? this.ngayKyHD12TH.toISOString() : <any>undefined;
        data["ngayKyHDTV"] = this.ngayKyHDTV ? this.ngayKyHDTV.toISOString() : <any>undefined;
        data["ngayKYHDCTV"] = this.ngayKYHDCTV ? this.ngayKYHDCTV.toISOString() : <any>undefined;
        data["ngayKyHDKV"] = this.ngayKyHDKV ? this.ngayKyHDKV.toISOString() : <any>undefined;
        data["ngayKYHDTT"] = this.ngayKYHDTT ? this.ngayKYHDTT.toISOString() : <any>undefined;
        data["ngayKyHD"] = this.ngayKyHD ? this.ngayKyHD.toISOString() : <any>undefined;
        data["nguoiNhapCV"] = this.nguoiNhapCV;
        data["id"] = this.id;
        return data; 
    }

    clone(): HoSoDto {
        const json = this.toJSON();
        let result = new HoSoDto();
        result.init(json);
        return result;
    }
}

export interface IHoSoDto {
    maHoSo: string | undefined;
    tenCty: string | undefined;
    sdt: string | undefined;
    hopDongHienTai: string | undefined;
    soHD: string | undefined;
    donViCongTacName: string | undefined;
    choNgoi: string | undefined;
    noiDaoTaoID: number | undefined;
    loaiHopDongID: number | undefined;
    maSoNoiKCB: string | undefined;
    noiDangKyKCBID: number | undefined;
    ngayHetHanBHYT: moment.Moment | undefined;
    soTheBHYT: string | undefined;
    maTinhCap: string | undefined;
    maSoBHXH: string | undefined;
    soSoBHXH: string | undefined;
    tyLeDongBH: number;
    ngayThamGiaBH: moment.Moment | undefined;
    thamGiaCongDoan: boolean;
    nganHangCode: string | undefined;
    tkNganHang: string | undefined;
    donViSoCongChuanCode: string | undefined;
    soCongChuan: string | undefined;
    luongDongBH: string | undefined;
    luongCoBan: string | undefined;
    bacLuongCode: string | undefined;
    soNgayPhep: number;
    ngayChinhThuc: moment.Moment | undefined;
    ngayThuViec: moment.Moment | undefined;
    ngayTapSu: moment.Moment | undefined;
    soSoQLLaoDong: string | undefined;
    diaDiemLamViecCode: string | undefined;
    quanLyGianTiep: string | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiLamViecCode: string | undefined;
    bac: string | undefined;
    cap: string | undefined;
    chucDanh: string | undefined;
    maChamCong: string | undefined;
    diaChiLHKC: string | undefined;
    emailLHKC: string | undefined;
    dtDiDongLHKC: string | undefined;
    dtNhaRiengLHKC: string | undefined;
    quanHeLHKC: string | undefined;
    hoVaTenLHKC: string | undefined;
    diaChiHN: string | undefined;
    tinhThanhIDHN: number | undefined;
    quocGiaHN: string | undefined;
    laChuHo: boolean;
    maSoHoGiaDinh: string | undefined;
    soSoHoKhau: string | undefined;
    diaChiHKTT: string | undefined;
    tinhThanhIDHKTT: number | undefined;
    tinhThanhID: number | undefined;
    quocGiaHKTT: string | undefined;
    facebook: string | undefined;
    skype: string | undefined;
    noiSinh: string | undefined;
    nguyenQuan: string | undefined;
    emailKhac: string | undefined;
    emailCoQuan: string | undefined;
    emailCaNhan: string | undefined;
    dtKhac: string | undefined;
    dtNhaRieng: string | undefined;
    dtCoQuan: string | undefined;
    dtDiDong: string | undefined;
    tepDinhKem: string | undefined;
    tinhTrangHonNhanCode: string | undefined;
    xepLoaiCode: string | undefined;
    namTotNghiep: number;
    chuyenNganh: string | undefined;
    khoa: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    trinhDoVanHoa: string | undefined;
    ngayHetHan: moment.Moment | undefined;
    noiCap: string | undefined;
    ngayCap: moment.Moment | undefined;
    soCMND: string | undefined;
    quocTich: string | undefined;
    tonGiao: string | undefined;
    danToc: string | undefined;
    viTriCongViecCode: string | undefined;
    donViCongTacID: number | undefined;
    mstCaNhan: string | undefined;
    ngaySinh: moment.Moment | undefined;
    gioiTinhCode: string | undefined;
    anhDaiDien: string | undefined;
    hoVaTen: string | undefined;
    maNhanVien: string | undefined;
    chiNhanh: string | undefined;
    dvt: string | undefined;
    ngayKyHDKTH: moment.Moment | undefined;
    ngayKyHD36TH: moment.Moment | undefined;
    ngayKyHD12TH: moment.Moment | undefined;
    ngayKyHDTV: moment.Moment | undefined;
    ngayKYHDCTV: moment.Moment | undefined;
    ngayKyHDKV: moment.Moment | undefined;
    ngayKYHDTT: moment.Moment | undefined;
    ngayKyHD: moment.Moment | undefined;
    nguoiNhapCV: string | undefined;
    id: number;
}

export class OrganizationUnit implements IOrganizationUnit {
    tenantId: number | undefined;
    parent: OrganizationUnit;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    children: OrganizationUnit[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IOrganizationUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parent = new OrganizationUnit();
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.parent = data["parent"] ? OrganizationUnit.fromJS(data["parent"]) : new OrganizationUnit();
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(OrganizationUnit.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnit {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnit {
        const json = this.toJSON();
        let result = new OrganizationUnit();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnit {
    tenantId: number | undefined;
    parent: OrganizationUnit;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    children: OrganizationUnit[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class CreateOrEditHoSoDto implements ICreateOrEditHoSoDto {
    maHoSo: string | undefined;
    tenCty: string | undefined;
    hopDongHienTai: string | undefined;
    soHD: string | undefined;
    donViCongTacName: string | undefined;
    choNgoi: string | undefined;
    noiDaoTaoID: number | undefined;
    loaiHopDongID: number | undefined;
    maSoNoiKCB: string | undefined;
    noiDangKyKCBID: number | undefined;
    ngayHetHanBHYT: moment.Moment;
    soTheBHYT: string | undefined;
    maTinhCap: string | undefined;
    maSoBHXH: string | undefined;
    soSoBHXH: string | undefined;
    tyLeDongBH: number;
    ngayThamGiaBH: moment.Moment;
    thamGiaCongDoan: boolean;
    nganHangCode: string | undefined;
    tkNganHang: string | undefined;
    donViSoCongChuanCode: string | undefined;
    soCongChuan: string | undefined;
    luongDongBH: string | undefined;
    luongCoBan: string | undefined;
    bacLuongCode: string | undefined;
    soNgayPhep: number;
    ngayChinhThuc: moment.Moment;
    ngayThuViec: moment.Moment;
    ngayTapSu: moment.Moment;
    soSoQLLaoDong: string | undefined;
    diaDiemLamViecCode: string | undefined;
    quanLyGianTiep: string | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiLamViecCode: string | undefined;
    bac: string | undefined;
    cap: string | undefined;
    chucDanh: string | undefined;
    maChamCong: string | undefined;
    diaChiLHKC: string | undefined;
    emailLHKC: string | undefined;
    dtDiDongLHKC: string | undefined;
    dtNhaRiengLHKC: string | undefined;
    quanHeLHKC: string | undefined;
    hoVaTenLHKC: string | undefined;
    diaChiHN: string | undefined;
    tinhThanhIDHN: number | undefined;
    quocGiaHN: string | undefined;
    laChuHo: boolean;
    maSoHoGiaDinh: string | undefined;
    soSoHoKhau: string | undefined;
    diaChiHKTT: string | undefined;
    tinhThanhIDHKTT: number | undefined;
    quocGiaHKTT: string | undefined;
    facebook: string | undefined;
    skype: string | undefined;
    noiSinh: string | undefined;
    tinhThanhID: number | undefined;
    nguyenQuan: string | undefined;
    emailKhac: string | undefined;
    emailCoQuan: string | undefined;
    emailCaNhan: string | undefined;
    dtKhac: string | undefined;
    dtNhaRieng: string | undefined;
    dtCoQuan: string | undefined;
    dtDiDong: string | undefined;
    tepDinhKem: string | undefined;
    tinhTrangHonNhanCode: string | undefined;
    xepLoaiCode: string | undefined;
    namTotNghiep: number;
    chuyenNganh: string | undefined;
    khoa: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    trinhDoVanHoa: string | undefined;
    ngayHetHan: moment.Moment | undefined;
    noiCap: string | undefined;
    ngayCap: moment.Moment | undefined;
    soCMND: string | undefined;
    quocTich: string | undefined;
    tonGiao: string | undefined;
    danToc: string | undefined;
    viTriCongViecCode: string | undefined;
    donViCongTacID: number | undefined;
    mstCaNhan: string | undefined;
    ngaySinh: moment.Moment | undefined;
    gioiTinhCode: string | undefined;
    anhDaiDien: string | undefined;
    hoVaTen: string | undefined;
    maNhanVien: string | undefined;
    chiNhanh: string | undefined;
    dvt: string | undefined;
    ngayKyHDKTH: moment.Moment | undefined;
    ngayKyHD36TH: moment.Moment | undefined;
    ngayKyHD12TH: moment.Moment | undefined;
    ngayKyHDTV: moment.Moment | undefined;
    ngayKYHDCTV: moment.Moment | undefined;
    ngayKyHDKV: moment.Moment | undefined;
    ngayKYHDTT: moment.Moment | undefined;
    ngayKyHD: moment.Moment | undefined;
    sdt: string | undefined;
    nguoiNhapCV: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditHoSoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maHoSo = data["maHoSo"];
            this.tenCty = data["tenCty"];
            this.hopDongHienTai = data["hopDongHienTai"];
            this.soHD = data["soHD"];
            this.donViCongTacName = data["donViCongTacName"];
            this.choNgoi = data["choNgoi"];
            this.noiDaoTaoID = data["noiDaoTaoID"];
            this.loaiHopDongID = data["loaiHopDongID"];
            this.maSoNoiKCB = data["maSoNoiKCB"];
            this.noiDangKyKCBID = data["noiDangKyKCBID"];
            this.ngayHetHanBHYT = data["ngayHetHanBHYT"] ? moment(data["ngayHetHanBHYT"].toString()) : <any>undefined;
            this.soTheBHYT = data["soTheBHYT"];
            this.maTinhCap = data["maTinhCap"];
            this.maSoBHXH = data["maSoBHXH"];
            this.soSoBHXH = data["soSoBHXH"];
            this.tyLeDongBH = data["tyLeDongBH"];
            this.ngayThamGiaBH = data["ngayThamGiaBH"] ? moment(data["ngayThamGiaBH"].toString()) : <any>undefined;
            this.thamGiaCongDoan = data["thamGiaCongDoan"];
            this.nganHangCode = data["nganHangCode"];
            this.tkNganHang = data["tkNganHang"];
            this.donViSoCongChuanCode = data["donViSoCongChuanCode"];
            this.soCongChuan = data["soCongChuan"];
            this.luongDongBH = data["luongDongBH"];
            this.luongCoBan = data["luongCoBan"];
            this.bacLuongCode = data["bacLuongCode"];
            this.soNgayPhep = data["soNgayPhep"];
            this.ngayChinhThuc = data["ngayChinhThuc"] ? moment(data["ngayChinhThuc"].toString()) : <any>undefined;
            this.ngayThuViec = data["ngayThuViec"] ? moment(data["ngayThuViec"].toString()) : <any>undefined;
            this.ngayTapSu = data["ngayTapSu"] ? moment(data["ngayTapSu"].toString()) : <any>undefined;
            this.soSoQLLaoDong = data["soSoQLLaoDong"];
            this.diaDiemLamViecCode = data["diaDiemLamViecCode"];
            this.quanLyGianTiep = data["quanLyGianTiep"];
            this.quanLyTrucTiep = data["quanLyTrucTiep"];
            this.trangThaiLamViecCode = data["trangThaiLamViecCode"];
            this.bac = data["bac"];
            this.cap = data["cap"];
            this.chucDanh = data["chucDanh"];
            this.maChamCong = data["maChamCong"];
            this.diaChiLHKC = data["diaChiLHKC"];
            this.emailLHKC = data["emailLHKC"];
            this.dtDiDongLHKC = data["dtDiDongLHKC"];
            this.dtNhaRiengLHKC = data["dtNhaRiengLHKC"];
            this.quanHeLHKC = data["quanHeLHKC"];
            this.hoVaTenLHKC = data["hoVaTenLHKC"];
            this.diaChiHN = data["diaChiHN"];
            this.tinhThanhIDHN = data["tinhThanhIDHN"];
            this.quocGiaHN = data["quocGiaHN"];
            this.laChuHo = data["laChuHo"];
            this.maSoHoGiaDinh = data["maSoHoGiaDinh"];
            this.soSoHoKhau = data["soSoHoKhau"];
            this.diaChiHKTT = data["diaChiHKTT"];
            this.tinhThanhIDHKTT = data["tinhThanhIDHKTT"];
            this.quocGiaHKTT = data["quocGiaHKTT"];
            this.facebook = data["facebook"];
            this.skype = data["skype"];
            this.noiSinh = data["noiSinh"];
            this.tinhThanhID = data["tinhThanhID"];
            this.nguyenQuan = data["nguyenQuan"];
            this.emailKhac = data["emailKhac"];
            this.emailCoQuan = data["emailCoQuan"];
            this.emailCaNhan = data["emailCaNhan"];
            this.dtKhac = data["dtKhac"];
            this.dtNhaRieng = data["dtNhaRieng"];
            this.dtCoQuan = data["dtCoQuan"];
            this.dtDiDong = data["dtDiDong"];
            this.tepDinhKem = data["tepDinhKem"];
            this.tinhTrangHonNhanCode = data["tinhTrangHonNhanCode"];
            this.xepLoaiCode = data["xepLoaiCode"];
            this.namTotNghiep = data["namTotNghiep"];
            this.chuyenNganh = data["chuyenNganh"];
            this.khoa = data["khoa"];
            this.trinhDoDaoTaoCode = data["trinhDoDaoTaoCode"];
            this.trinhDoVanHoa = data["trinhDoVanHoa"];
            this.ngayHetHan = data["ngayHetHan"] ? moment(data["ngayHetHan"].toString()) : <any>undefined;
            this.noiCap = data["noiCap"];
            this.ngayCap = data["ngayCap"] ? moment(data["ngayCap"].toString()) : <any>undefined;
            this.soCMND = data["soCMND"];
            this.quocTich = data["quocTich"];
            this.tonGiao = data["tonGiao"];
            this.danToc = data["danToc"];
            this.viTriCongViecCode = data["viTriCongViecCode"];
            this.donViCongTacID = data["donViCongTacID"];
            this.mstCaNhan = data["mstCaNhan"];
            this.ngaySinh = data["ngaySinh"] ? moment(data["ngaySinh"].toString()) : <any>undefined;
            this.gioiTinhCode = data["gioiTinhCode"];
            this.anhDaiDien = data["anhDaiDien"];
            this.hoVaTen = data["hoVaTen"];
            this.maNhanVien = data["maNhanVien"];
            this.chiNhanh = data["chiNhanh"];
            this.dvt = data["dvt"];
            this.ngayKyHDKTH = data["ngayKyHDKTH"] ? moment(data["ngayKyHDKTH"].toString()) : <any>undefined;
            this.ngayKyHD36TH = data["ngayKyHD36TH"] ? moment(data["ngayKyHD36TH"].toString()) : <any>undefined;
            this.ngayKyHD12TH = data["ngayKyHD12TH"] ? moment(data["ngayKyHD12TH"].toString()) : <any>undefined;
            this.ngayKyHDTV = data["ngayKyHDTV"] ? moment(data["ngayKyHDTV"].toString()) : <any>undefined;
            this.ngayKYHDCTV = data["ngayKYHDCTV"] ? moment(data["ngayKYHDCTV"].toString()) : <any>undefined;
            this.ngayKyHDKV = data["ngayKyHDKV"] ? moment(data["ngayKyHDKV"].toString()) : <any>undefined;
            this.ngayKYHDTT = data["ngayKYHDTT"] ? moment(data["ngayKYHDTT"].toString()) : <any>undefined;
            this.ngayKyHD = data["ngayKyHD"] ? moment(data["ngayKyHD"].toString()) : <any>undefined;
            this.sdt = data["sdt"];
            this.nguoiNhapCV = data["nguoiNhapCV"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditHoSoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditHoSoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maHoSo"] = this.maHoSo;
        data["tenCty"] = this.tenCty;
        data["hopDongHienTai"] = this.hopDongHienTai;
        data["soHD"] = this.soHD;
        data["donViCongTacName"] = this.donViCongTacName;
        data["choNgoi"] = this.choNgoi;
        data["noiDaoTaoID"] = this.noiDaoTaoID;
        data["loaiHopDongID"] = this.loaiHopDongID;
        data["maSoNoiKCB"] = this.maSoNoiKCB;
        data["noiDangKyKCBID"] = this.noiDangKyKCBID;
        data["ngayHetHanBHYT"] = this.ngayHetHanBHYT ? this.ngayHetHanBHYT.toISOString() : <any>undefined;
        data["soTheBHYT"] = this.soTheBHYT;
        data["maTinhCap"] = this.maTinhCap;
        data["maSoBHXH"] = this.maSoBHXH;
        data["soSoBHXH"] = this.soSoBHXH;
        data["tyLeDongBH"] = this.tyLeDongBH;
        data["ngayThamGiaBH"] = this.ngayThamGiaBH ? this.ngayThamGiaBH.toISOString() : <any>undefined;
        data["thamGiaCongDoan"] = this.thamGiaCongDoan;
        data["nganHangCode"] = this.nganHangCode;
        data["tkNganHang"] = this.tkNganHang;
        data["donViSoCongChuanCode"] = this.donViSoCongChuanCode;
        data["soCongChuan"] = this.soCongChuan;
        data["luongDongBH"] = this.luongDongBH;
        data["luongCoBan"] = this.luongCoBan;
        data["bacLuongCode"] = this.bacLuongCode;
        data["soNgayPhep"] = this.soNgayPhep;
        data["ngayChinhThuc"] = this.ngayChinhThuc ? this.ngayChinhThuc.toISOString() : <any>undefined;
        data["ngayThuViec"] = this.ngayThuViec ? this.ngayThuViec.toISOString() : <any>undefined;
        data["ngayTapSu"] = this.ngayTapSu ? this.ngayTapSu.toISOString() : <any>undefined;
        data["soSoQLLaoDong"] = this.soSoQLLaoDong;
        data["diaDiemLamViecCode"] = this.diaDiemLamViecCode;
        data["quanLyGianTiep"] = this.quanLyGianTiep;
        data["quanLyTrucTiep"] = this.quanLyTrucTiep;
        data["trangThaiLamViecCode"] = this.trangThaiLamViecCode;
        data["bac"] = this.bac;
        data["cap"] = this.cap;
        data["chucDanh"] = this.chucDanh;
        data["maChamCong"] = this.maChamCong;
        data["diaChiLHKC"] = this.diaChiLHKC;
        data["emailLHKC"] = this.emailLHKC;
        data["dtDiDongLHKC"] = this.dtDiDongLHKC;
        data["dtNhaRiengLHKC"] = this.dtNhaRiengLHKC;
        data["quanHeLHKC"] = this.quanHeLHKC;
        data["hoVaTenLHKC"] = this.hoVaTenLHKC;
        data["diaChiHN"] = this.diaChiHN;
        data["tinhThanhIDHN"] = this.tinhThanhIDHN;
        data["quocGiaHN"] = this.quocGiaHN;
        data["laChuHo"] = this.laChuHo;
        data["maSoHoGiaDinh"] = this.maSoHoGiaDinh;
        data["soSoHoKhau"] = this.soSoHoKhau;
        data["diaChiHKTT"] = this.diaChiHKTT;
        data["tinhThanhIDHKTT"] = this.tinhThanhIDHKTT;
        data["quocGiaHKTT"] = this.quocGiaHKTT;
        data["facebook"] = this.facebook;
        data["skype"] = this.skype;
        data["noiSinh"] = this.noiSinh;
        data["tinhThanhID"] = this.tinhThanhID;
        data["nguyenQuan"] = this.nguyenQuan;
        data["emailKhac"] = this.emailKhac;
        data["emailCoQuan"] = this.emailCoQuan;
        data["emailCaNhan"] = this.emailCaNhan;
        data["dtKhac"] = this.dtKhac;
        data["dtNhaRieng"] = this.dtNhaRieng;
        data["dtCoQuan"] = this.dtCoQuan;
        data["dtDiDong"] = this.dtDiDong;
        data["tepDinhKem"] = this.tepDinhKem;
        data["tinhTrangHonNhanCode"] = this.tinhTrangHonNhanCode;
        data["xepLoaiCode"] = this.xepLoaiCode;
        data["namTotNghiep"] = this.namTotNghiep;
        data["chuyenNganh"] = this.chuyenNganh;
        data["khoa"] = this.khoa;
        data["trinhDoDaoTaoCode"] = this.trinhDoDaoTaoCode;
        data["trinhDoVanHoa"] = this.trinhDoVanHoa;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        data["noiCap"] = this.noiCap;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["soCMND"] = this.soCMND;
        data["quocTich"] = this.quocTich;
        data["tonGiao"] = this.tonGiao;
        data["danToc"] = this.danToc;
        data["viTriCongViecCode"] = this.viTriCongViecCode;
        data["donViCongTacID"] = this.donViCongTacID;
        data["mstCaNhan"] = this.mstCaNhan;
        data["ngaySinh"] = this.ngaySinh ? this.ngaySinh.toISOString() : <any>undefined;
        data["gioiTinhCode"] = this.gioiTinhCode;
        data["anhDaiDien"] = this.anhDaiDien;
        data["hoVaTen"] = this.hoVaTen;
        data["maNhanVien"] = this.maNhanVien;
        data["chiNhanh"] = this.chiNhanh;
        data["dvt"] = this.dvt;
        data["ngayKyHDKTH"] = this.ngayKyHDKTH ? this.ngayKyHDKTH.toISOString() : <any>undefined;
        data["ngayKyHD36TH"] = this.ngayKyHD36TH ? this.ngayKyHD36TH.toISOString() : <any>undefined;
        data["ngayKyHD12TH"] = this.ngayKyHD12TH ? this.ngayKyHD12TH.toISOString() : <any>undefined;
        data["ngayKyHDTV"] = this.ngayKyHDTV ? this.ngayKyHDTV.toISOString() : <any>undefined;
        data["ngayKYHDCTV"] = this.ngayKYHDCTV ? this.ngayKYHDCTV.toISOString() : <any>undefined;
        data["ngayKyHDKV"] = this.ngayKyHDKV ? this.ngayKyHDKV.toISOString() : <any>undefined;
        data["ngayKYHDTT"] = this.ngayKYHDTT ? this.ngayKYHDTT.toISOString() : <any>undefined;
        data["ngayKyHD"] = this.ngayKyHD ? this.ngayKyHD.toISOString() : <any>undefined;
        data["sdt"] = this.sdt;
        data["nguoiNhapCV"] = this.nguoiNhapCV;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditHoSoDto {
        const json = this.toJSON();
        let result = new CreateOrEditHoSoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditHoSoDto {
    maHoSo: string | undefined;
    tenCty: string | undefined;
    hopDongHienTai: string | undefined;
    soHD: string | undefined;
    donViCongTacName: string | undefined;
    choNgoi: string | undefined;
    noiDaoTaoID: number | undefined;
    loaiHopDongID: number | undefined;
    maSoNoiKCB: string | undefined;
    noiDangKyKCBID: number | undefined;
    ngayHetHanBHYT: moment.Moment;
    soTheBHYT: string | undefined;
    maTinhCap: string | undefined;
    maSoBHXH: string | undefined;
    soSoBHXH: string | undefined;
    tyLeDongBH: number;
    ngayThamGiaBH: moment.Moment;
    thamGiaCongDoan: boolean;
    nganHangCode: string | undefined;
    tkNganHang: string | undefined;
    donViSoCongChuanCode: string | undefined;
    soCongChuan: string | undefined;
    luongDongBH: string | undefined;
    luongCoBan: string | undefined;
    bacLuongCode: string | undefined;
    soNgayPhep: number;
    ngayChinhThuc: moment.Moment;
    ngayThuViec: moment.Moment;
    ngayTapSu: moment.Moment;
    soSoQLLaoDong: string | undefined;
    diaDiemLamViecCode: string | undefined;
    quanLyGianTiep: string | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiLamViecCode: string | undefined;
    bac: string | undefined;
    cap: string | undefined;
    chucDanh: string | undefined;
    maChamCong: string | undefined;
    diaChiLHKC: string | undefined;
    emailLHKC: string | undefined;
    dtDiDongLHKC: string | undefined;
    dtNhaRiengLHKC: string | undefined;
    quanHeLHKC: string | undefined;
    hoVaTenLHKC: string | undefined;
    diaChiHN: string | undefined;
    tinhThanhIDHN: number | undefined;
    quocGiaHN: string | undefined;
    laChuHo: boolean;
    maSoHoGiaDinh: string | undefined;
    soSoHoKhau: string | undefined;
    diaChiHKTT: string | undefined;
    tinhThanhIDHKTT: number | undefined;
    quocGiaHKTT: string | undefined;
    facebook: string | undefined;
    skype: string | undefined;
    noiSinh: string | undefined;
    tinhThanhID: number | undefined;
    nguyenQuan: string | undefined;
    emailKhac: string | undefined;
    emailCoQuan: string | undefined;
    emailCaNhan: string | undefined;
    dtKhac: string | undefined;
    dtNhaRieng: string | undefined;
    dtCoQuan: string | undefined;
    dtDiDong: string | undefined;
    tepDinhKem: string | undefined;
    tinhTrangHonNhanCode: string | undefined;
    xepLoaiCode: string | undefined;
    namTotNghiep: number;
    chuyenNganh: string | undefined;
    khoa: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    trinhDoVanHoa: string | undefined;
    ngayHetHan: moment.Moment | undefined;
    noiCap: string | undefined;
    ngayCap: moment.Moment | undefined;
    soCMND: string | undefined;
    quocTich: string | undefined;
    tonGiao: string | undefined;
    danToc: string | undefined;
    viTriCongViecCode: string | undefined;
    donViCongTacID: number | undefined;
    mstCaNhan: string | undefined;
    ngaySinh: moment.Moment | undefined;
    gioiTinhCode: string | undefined;
    anhDaiDien: string | undefined;
    hoVaTen: string | undefined;
    maNhanVien: string | undefined;
    chiNhanh: string | undefined;
    dvt: string | undefined;
    ngayKyHDKTH: moment.Moment | undefined;
    ngayKyHD36TH: moment.Moment | undefined;
    ngayKyHD12TH: moment.Moment | undefined;
    ngayKyHDTV: moment.Moment | undefined;
    ngayKYHDCTV: moment.Moment | undefined;
    ngayKyHDKV: moment.Moment | undefined;
    ngayKYHDTT: moment.Moment | undefined;
    ngayKyHD: moment.Moment | undefined;
    sdt: string | undefined;
    nguoiNhapCV: string | undefined;
    id: number | undefined;
}

export class GetHoSoForViewDto implements IGetHoSoForViewDto {
    hoSo: HoSoDto;
    viTriCongViecValue: string | undefined;
    gioiTinhValue: string | undefined;
    tinhTrangHonNhanValue: string | undefined;
    trinhDoDaoTaoValue: string | undefined;
    xepLoaiValue: string | undefined;
    noiDangKyValue: string | undefined;
    noiDaoTaoValue: string | undefined;
    loaiHopDongValue: string | undefined;
    tinhThanhIDHKTTValue: string | undefined;
    tinhThanhIDHNValue: string | undefined;
    tinhThanhValue: string | undefined;
    hopDongValue: string | undefined;
    donViCongTacValue: string | undefined;
    tinhTrangNhanSuValue: string | undefined;

    constructor(data?: IGetHoSoForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hoSo = new HoSoDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.hoSo = data["hoSo"] ? HoSoDto.fromJS(data["hoSo"]) : new HoSoDto();
            this.viTriCongViecValue = data["viTriCongViecValue"];
            this.gioiTinhValue = data["gioiTinhValue"];
            this.tinhTrangHonNhanValue = data["tinhTrangHonNhanValue"];
            this.trinhDoDaoTaoValue = data["trinhDoDaoTaoValue"];
            this.xepLoaiValue = data["xepLoaiValue"];
            this.noiDangKyValue = data["noiDangKyValue"];
            this.noiDaoTaoValue = data["noiDaoTaoValue"];
            this.loaiHopDongValue = data["loaiHopDongValue"];
            this.tinhThanhIDHKTTValue = data["tinhThanhIDHKTTValue"];
            this.tinhThanhIDHNValue = data["tinhThanhIDHNValue"];
            this.tinhThanhValue = data["tinhThanhValue"];
            this.hopDongValue = data["hopDongValue"];
            this.donViCongTacValue = data["donViCongTacValue"];
            this.tinhTrangNhanSuValue = data["tinhTrangNhanSuValue"];
        }
    }

    static fromJS(data: any): GetHoSoForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetHoSoForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hoSo"] = this.hoSo ? this.hoSo.toJSON() : <any>undefined;
        data["viTriCongViecValue"] = this.viTriCongViecValue;
        data["gioiTinhValue"] = this.gioiTinhValue;
        data["tinhTrangHonNhanValue"] = this.tinhTrangHonNhanValue;
        data["trinhDoDaoTaoValue"] = this.trinhDoDaoTaoValue;
        data["xepLoaiValue"] = this.xepLoaiValue;
        data["noiDangKyValue"] = this.noiDangKyValue;
        data["noiDaoTaoValue"] = this.noiDaoTaoValue;
        data["loaiHopDongValue"] = this.loaiHopDongValue;
        data["tinhThanhIDHKTTValue"] = this.tinhThanhIDHKTTValue;
        data["tinhThanhIDHNValue"] = this.tinhThanhIDHNValue;
        data["tinhThanhValue"] = this.tinhThanhValue;
        data["hopDongValue"] = this.hopDongValue;
        data["donViCongTacValue"] = this.donViCongTacValue;
        data["tinhTrangNhanSuValue"] = this.tinhTrangNhanSuValue;
        return data; 
    }

    clone(): GetHoSoForViewDto {
        const json = this.toJSON();
        let result = new GetHoSoForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetHoSoForViewDto {
    hoSo: HoSoDto;
    viTriCongViecValue: string | undefined;
    gioiTinhValue: string | undefined;
    tinhTrangHonNhanValue: string | undefined;
    trinhDoDaoTaoValue: string | undefined;
    xepLoaiValue: string | undefined;
    noiDangKyValue: string | undefined;
    noiDaoTaoValue: string | undefined;
    loaiHopDongValue: string | undefined;
    tinhThanhIDHKTTValue: string | undefined;
    tinhThanhIDHNValue: string | undefined;
    tinhThanhValue: string | undefined;
    hopDongValue: string | undefined;
    donViCongTacValue: string | undefined;
    tinhTrangNhanSuValue: string | undefined;
}

export class PagedResultDtoOfGetHoSoForViewDto implements IPagedResultDtoOfGetHoSoForViewDto {
    totalCount: number;
    items: GetHoSoForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetHoSoForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetHoSoForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetHoSoForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetHoSoForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetHoSoForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetHoSoForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetHoSoForViewDto {
    totalCount: number;
    items: GetHoSoForViewDto[] | undefined;
}

export class CreateOrEditUngVienDto implements ICreateOrEditUngVienDto {
    maUngVien: string | undefined;
    hoVaTen: string | undefined;
    donViCongTacID: number | undefined;
    viTriUngTuyenCode: string | undefined;
    kenhTuyenDungCode: string | undefined;
    gioiTinhCode: string | undefined;
    ngaySinh: moment.Moment | undefined;
    soCMND: string | undefined;
    ngayCap: moment.Moment | undefined;
    noiCap: string | undefined;
    tinhThanhID: number | undefined;
    tinhTrangHonNhanCode: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    trinhDoVanHoa: string | undefined;
    noiDaoTaoID: number | undefined;
    khoa: string | undefined;
    chuyenNganh: string | undefined;
    xepLoaiCode: string | undefined;
    namTotNghiep: number | undefined;
    trangThaiCode: string | undefined;
    tienDoTuyenDungCode: string | undefined;
    tepDinhKem: string | undefined;
    recorD_STATUS: string | undefined;
    markeR_ID: number | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: number | undefined;
    approvE_DT: moment.Moment | undefined;
    dienThoai: string | undefined;
    email: string | undefined;
    diaChi: string | undefined;
    time1: string | undefined;
    day1: moment.Moment | undefined;
    time2: string | undefined;
    day2: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    time3: string | undefined;
    day3: moment.Moment | undefined;
    note: string | undefined;
    tenCTY: string | undefined;
    nvPhuTrach: string | undefined;
    maNguoiPheDuyet: number | undefined;
    ngayPheDuyet: moment.Moment | undefined;
    dungLuong: string | undefined;
    tieuDe: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditUngVienDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maUngVien = data["maUngVien"];
            this.hoVaTen = data["hoVaTen"];
            this.donViCongTacID = data["donViCongTacID"];
            this.viTriUngTuyenCode = data["viTriUngTuyenCode"];
            this.kenhTuyenDungCode = data["kenhTuyenDungCode"];
            this.gioiTinhCode = data["gioiTinhCode"];
            this.ngaySinh = data["ngaySinh"] ? moment(data["ngaySinh"].toString()) : <any>undefined;
            this.soCMND = data["soCMND"];
            this.ngayCap = data["ngayCap"] ? moment(data["ngayCap"].toString()) : <any>undefined;
            this.noiCap = data["noiCap"];
            this.tinhThanhID = data["tinhThanhID"];
            this.tinhTrangHonNhanCode = data["tinhTrangHonNhanCode"];
            this.trinhDoDaoTaoCode = data["trinhDoDaoTaoCode"];
            this.trinhDoVanHoa = data["trinhDoVanHoa"];
            this.noiDaoTaoID = data["noiDaoTaoID"];
            this.khoa = data["khoa"];
            this.chuyenNganh = data["chuyenNganh"];
            this.xepLoaiCode = data["xepLoaiCode"];
            this.namTotNghiep = data["namTotNghiep"];
            this.trangThaiCode = data["trangThaiCode"];
            this.tienDoTuyenDungCode = data["tienDoTuyenDungCode"];
            this.tepDinhKem = data["tepDinhKem"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.markeR_ID = data["markeR_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.dienThoai = data["dienThoai"];
            this.email = data["email"];
            this.diaChi = data["diaChi"];
            this.time1 = data["time1"];
            this.day1 = data["day1"] ? moment(data["day1"].toString()) : <any>undefined;
            this.time2 = data["time2"];
            this.day2 = data["day2"] ? moment(data["day2"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.time3 = data["time3"];
            this.day3 = data["day3"] ? moment(data["day3"].toString()) : <any>undefined;
            this.note = data["note"];
            this.tenCTY = data["tenCTY"];
            this.nvPhuTrach = data["nvPhuTrach"];
            this.maNguoiPheDuyet = data["maNguoiPheDuyet"];
            this.ngayPheDuyet = data["ngayPheDuyet"] ? moment(data["ngayPheDuyet"].toString()) : <any>undefined;
            this.dungLuong = data["dungLuong"];
            this.tieuDe = data["tieuDe"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUngVienDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUngVienDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maUngVien"] = this.maUngVien;
        data["hoVaTen"] = this.hoVaTen;
        data["donViCongTacID"] = this.donViCongTacID;
        data["viTriUngTuyenCode"] = this.viTriUngTuyenCode;
        data["kenhTuyenDungCode"] = this.kenhTuyenDungCode;
        data["gioiTinhCode"] = this.gioiTinhCode;
        data["ngaySinh"] = this.ngaySinh ? this.ngaySinh.toISOString() : <any>undefined;
        data["soCMND"] = this.soCMND;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["noiCap"] = this.noiCap;
        data["tinhThanhID"] = this.tinhThanhID;
        data["tinhTrangHonNhanCode"] = this.tinhTrangHonNhanCode;
        data["trinhDoDaoTaoCode"] = this.trinhDoDaoTaoCode;
        data["trinhDoVanHoa"] = this.trinhDoVanHoa;
        data["noiDaoTaoID"] = this.noiDaoTaoID;
        data["khoa"] = this.khoa;
        data["chuyenNganh"] = this.chuyenNganh;
        data["xepLoaiCode"] = this.xepLoaiCode;
        data["namTotNghiep"] = this.namTotNghiep;
        data["trangThaiCode"] = this.trangThaiCode;
        data["tienDoTuyenDungCode"] = this.tienDoTuyenDungCode;
        data["tepDinhKem"] = this.tepDinhKem;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["markeR_ID"] = this.markeR_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["dienThoai"] = this.dienThoai;
        data["email"] = this.email;
        data["diaChi"] = this.diaChi;
        data["time1"] = this.time1;
        data["day1"] = this.day1 ? this.day1.toISOString() : <any>undefined;
        data["time2"] = this.time2;
        data["day2"] = this.day2 ? this.day2.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["time3"] = this.time3;
        data["day3"] = this.day3 ? this.day3.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["tenCTY"] = this.tenCTY;
        data["nvPhuTrach"] = this.nvPhuTrach;
        data["maNguoiPheDuyet"] = this.maNguoiPheDuyet;
        data["ngayPheDuyet"] = this.ngayPheDuyet ? this.ngayPheDuyet.toISOString() : <any>undefined;
        data["dungLuong"] = this.dungLuong;
        data["tieuDe"] = this.tieuDe;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditUngVienDto {
        const json = this.toJSON();
        let result = new CreateOrEditUngVienDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditUngVienDto {
    maUngVien: string | undefined;
    hoVaTen: string | undefined;
    donViCongTacID: number | undefined;
    viTriUngTuyenCode: string | undefined;
    kenhTuyenDungCode: string | undefined;
    gioiTinhCode: string | undefined;
    ngaySinh: moment.Moment | undefined;
    soCMND: string | undefined;
    ngayCap: moment.Moment | undefined;
    noiCap: string | undefined;
    tinhThanhID: number | undefined;
    tinhTrangHonNhanCode: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    trinhDoVanHoa: string | undefined;
    noiDaoTaoID: number | undefined;
    khoa: string | undefined;
    chuyenNganh: string | undefined;
    xepLoaiCode: string | undefined;
    namTotNghiep: number | undefined;
    trangThaiCode: string | undefined;
    tienDoTuyenDungCode: string | undefined;
    tepDinhKem: string | undefined;
    recorD_STATUS: string | undefined;
    markeR_ID: number | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: number | undefined;
    approvE_DT: moment.Moment | undefined;
    dienThoai: string | undefined;
    email: string | undefined;
    diaChi: string | undefined;
    time1: string | undefined;
    day1: moment.Moment | undefined;
    time2: string | undefined;
    day2: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    time3: string | undefined;
    day3: moment.Moment | undefined;
    note: string | undefined;
    tenCTY: string | undefined;
    nvPhuTrach: string | undefined;
    maNguoiPheDuyet: number | undefined;
    ngayPheDuyet: moment.Moment | undefined;
    dungLuong: string | undefined;
    tieuDe: string | undefined;
    id: number | undefined;
}

export class GetUngVienForEditOutput implements IGetUngVienForEditOutput {
    ungVien: CreateOrEditUngVienDto;
    organizationUnitList: ListResultDtoOfOrganizationUnitDto;
    noiDaoTaoList: NoiDaoTaoDto[] | undefined;
    tinhThanhList: TinhThanhDto[] | undefined;
    templateList: TemplateDto[] | undefined;
    congViecList: OrganizationUnitDto[] | undefined;
    lichSuLamViecList: LichSuLamViecDto[] | undefined;
    lichSuUploadList: LichSuUploadDto[] | undefined;
    configEmail: GetConfigEmailForViewDto;
    viTriCongViec: TruongGiaoDichDto[] | undefined;
    tienDoTuyenDung: TruongGiaoDichDto[] | undefined;
    trangThai: TruongGiaoDichDto[] | undefined;
    kenhTuyenDung: TruongGiaoDichDto[] | undefined;
    congty: TruongGiaoDichDto[] | undefined;
    gioiTinh: TruongGiaoDichDto[] | undefined;
    tinhTrangHonNhan: TruongGiaoDichDto[] | undefined;
    trinhDoDaoTao: TruongGiaoDichDto[] | undefined;
    xepLoaiHocLuc: TruongGiaoDichDto[] | undefined;
    tinhTrangNhanSu: TruongGiaoDichDto[] | undefined;
    noiKhamBenhList: DangKyKCBDto[] | undefined;
    defaultCbbOption: TruongGiaoDichDto[] | undefined;

    constructor(data?: IGetUngVienForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ungVien = new CreateOrEditUngVienDto();
            this.organizationUnitList = new ListResultDtoOfOrganizationUnitDto();
            this.configEmail = new GetConfigEmailForViewDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ungVien = data["ungVien"] ? CreateOrEditUngVienDto.fromJS(data["ungVien"]) : new CreateOrEditUngVienDto();
            this.organizationUnitList = data["organizationUnitList"] ? ListResultDtoOfOrganizationUnitDto.fromJS(data["organizationUnitList"]) : new ListResultDtoOfOrganizationUnitDto();
            if (data["noiDaoTaoList"] && data["noiDaoTaoList"].constructor === Array) {
                this.noiDaoTaoList = [];
                for (let item of data["noiDaoTaoList"])
                    this.noiDaoTaoList.push(NoiDaoTaoDto.fromJS(item));
            }
            if (data["tinhThanhList"] && data["tinhThanhList"].constructor === Array) {
                this.tinhThanhList = [];
                for (let item of data["tinhThanhList"])
                    this.tinhThanhList.push(TinhThanhDto.fromJS(item));
            }
            if (data["templateList"] && data["templateList"].constructor === Array) {
                this.templateList = [];
                for (let item of data["templateList"])
                    this.templateList.push(TemplateDto.fromJS(item));
            }
            if (data["congViecList"] && data["congViecList"].constructor === Array) {
                this.congViecList = [];
                for (let item of data["congViecList"])
                    this.congViecList.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["lichSuLamViecList"] && data["lichSuLamViecList"].constructor === Array) {
                this.lichSuLamViecList = [];
                for (let item of data["lichSuLamViecList"])
                    this.lichSuLamViecList.push(LichSuLamViecDto.fromJS(item));
            }
            if (data["lichSuUploadList"] && data["lichSuUploadList"].constructor === Array) {
                this.lichSuUploadList = [];
                for (let item of data["lichSuUploadList"])
                    this.lichSuUploadList.push(LichSuUploadDto.fromJS(item));
            }
            this.configEmail = data["configEmail"] ? GetConfigEmailForViewDto.fromJS(data["configEmail"]) : new GetConfigEmailForViewDto();
            if (data["viTriCongViec"] && data["viTriCongViec"].constructor === Array) {
                this.viTriCongViec = [];
                for (let item of data["viTriCongViec"])
                    this.viTriCongViec.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["tienDoTuyenDung"] && data["tienDoTuyenDung"].constructor === Array) {
                this.tienDoTuyenDung = [];
                for (let item of data["tienDoTuyenDung"])
                    this.tienDoTuyenDung.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["trangThai"] && data["trangThai"].constructor === Array) {
                this.trangThai = [];
                for (let item of data["trangThai"])
                    this.trangThai.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["kenhTuyenDung"] && data["kenhTuyenDung"].constructor === Array) {
                this.kenhTuyenDung = [];
                for (let item of data["kenhTuyenDung"])
                    this.kenhTuyenDung.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["congty"] && data["congty"].constructor === Array) {
                this.congty = [];
                for (let item of data["congty"])
                    this.congty.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["gioiTinh"] && data["gioiTinh"].constructor === Array) {
                this.gioiTinh = [];
                for (let item of data["gioiTinh"])
                    this.gioiTinh.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["tinhTrangHonNhan"] && data["tinhTrangHonNhan"].constructor === Array) {
                this.tinhTrangHonNhan = [];
                for (let item of data["tinhTrangHonNhan"])
                    this.tinhTrangHonNhan.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["trinhDoDaoTao"] && data["trinhDoDaoTao"].constructor === Array) {
                this.trinhDoDaoTao = [];
                for (let item of data["trinhDoDaoTao"])
                    this.trinhDoDaoTao.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["xepLoaiHocLuc"] && data["xepLoaiHocLuc"].constructor === Array) {
                this.xepLoaiHocLuc = [];
                for (let item of data["xepLoaiHocLuc"])
                    this.xepLoaiHocLuc.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["tinhTrangNhanSu"] && data["tinhTrangNhanSu"].constructor === Array) {
                this.tinhTrangNhanSu = [];
                for (let item of data["tinhTrangNhanSu"])
                    this.tinhTrangNhanSu.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["noiKhamBenhList"] && data["noiKhamBenhList"].constructor === Array) {
                this.noiKhamBenhList = [];
                for (let item of data["noiKhamBenhList"])
                    this.noiKhamBenhList.push(DangKyKCBDto.fromJS(item));
            }
            if (data["defaultCbbOption"] && data["defaultCbbOption"].constructor === Array) {
                this.defaultCbbOption = [];
                for (let item of data["defaultCbbOption"])
                    this.defaultCbbOption.push(TruongGiaoDichDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUngVienForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUngVienForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ungVien"] = this.ungVien ? this.ungVien.toJSON() : <any>undefined;
        data["organizationUnitList"] = this.organizationUnitList ? this.organizationUnitList.toJSON() : <any>undefined;
        if (this.noiDaoTaoList && this.noiDaoTaoList.constructor === Array) {
            data["noiDaoTaoList"] = [];
            for (let item of this.noiDaoTaoList)
                data["noiDaoTaoList"].push(item.toJSON());
        }
        if (this.tinhThanhList && this.tinhThanhList.constructor === Array) {
            data["tinhThanhList"] = [];
            for (let item of this.tinhThanhList)
                data["tinhThanhList"].push(item.toJSON());
        }
        if (this.templateList && this.templateList.constructor === Array) {
            data["templateList"] = [];
            for (let item of this.templateList)
                data["templateList"].push(item.toJSON());
        }
        if (this.congViecList && this.congViecList.constructor === Array) {
            data["congViecList"] = [];
            for (let item of this.congViecList)
                data["congViecList"].push(item.toJSON());
        }
        if (this.lichSuLamViecList && this.lichSuLamViecList.constructor === Array) {
            data["lichSuLamViecList"] = [];
            for (let item of this.lichSuLamViecList)
                data["lichSuLamViecList"].push(item.toJSON());
        }
        if (this.lichSuUploadList && this.lichSuUploadList.constructor === Array) {
            data["lichSuUploadList"] = [];
            for (let item of this.lichSuUploadList)
                data["lichSuUploadList"].push(item.toJSON());
        }
        data["configEmail"] = this.configEmail ? this.configEmail.toJSON() : <any>undefined;
        if (this.viTriCongViec && this.viTriCongViec.constructor === Array) {
            data["viTriCongViec"] = [];
            for (let item of this.viTriCongViec)
                data["viTriCongViec"].push(item.toJSON());
        }
        if (this.tienDoTuyenDung && this.tienDoTuyenDung.constructor === Array) {
            data["tienDoTuyenDung"] = [];
            for (let item of this.tienDoTuyenDung)
                data["tienDoTuyenDung"].push(item.toJSON());
        }
        if (this.trangThai && this.trangThai.constructor === Array) {
            data["trangThai"] = [];
            for (let item of this.trangThai)
                data["trangThai"].push(item.toJSON());
        }
        if (this.kenhTuyenDung && this.kenhTuyenDung.constructor === Array) {
            data["kenhTuyenDung"] = [];
            for (let item of this.kenhTuyenDung)
                data["kenhTuyenDung"].push(item.toJSON());
        }
        if (this.congty && this.congty.constructor === Array) {
            data["congty"] = [];
            for (let item of this.congty)
                data["congty"].push(item.toJSON());
        }
        if (this.gioiTinh && this.gioiTinh.constructor === Array) {
            data["gioiTinh"] = [];
            for (let item of this.gioiTinh)
                data["gioiTinh"].push(item.toJSON());
        }
        if (this.tinhTrangHonNhan && this.tinhTrangHonNhan.constructor === Array) {
            data["tinhTrangHonNhan"] = [];
            for (let item of this.tinhTrangHonNhan)
                data["tinhTrangHonNhan"].push(item.toJSON());
        }
        if (this.trinhDoDaoTao && this.trinhDoDaoTao.constructor === Array) {
            data["trinhDoDaoTao"] = [];
            for (let item of this.trinhDoDaoTao)
                data["trinhDoDaoTao"].push(item.toJSON());
        }
        if (this.xepLoaiHocLuc && this.xepLoaiHocLuc.constructor === Array) {
            data["xepLoaiHocLuc"] = [];
            for (let item of this.xepLoaiHocLuc)
                data["xepLoaiHocLuc"].push(item.toJSON());
        }
        if (this.tinhTrangNhanSu && this.tinhTrangNhanSu.constructor === Array) {
            data["tinhTrangNhanSu"] = [];
            for (let item of this.tinhTrangNhanSu)
                data["tinhTrangNhanSu"].push(item.toJSON());
        }
        if (this.noiKhamBenhList && this.noiKhamBenhList.constructor === Array) {
            data["noiKhamBenhList"] = [];
            for (let item of this.noiKhamBenhList)
                data["noiKhamBenhList"].push(item.toJSON());
        }
        if (this.defaultCbbOption && this.defaultCbbOption.constructor === Array) {
            data["defaultCbbOption"] = [];
            for (let item of this.defaultCbbOption)
                data["defaultCbbOption"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetUngVienForEditOutput {
        const json = this.toJSON();
        let result = new GetUngVienForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUngVienForEditOutput {
    ungVien: CreateOrEditUngVienDto;
    organizationUnitList: ListResultDtoOfOrganizationUnitDto;
    noiDaoTaoList: NoiDaoTaoDto[] | undefined;
    tinhThanhList: TinhThanhDto[] | undefined;
    templateList: TemplateDto[] | undefined;
    congViecList: OrganizationUnitDto[] | undefined;
    lichSuLamViecList: LichSuLamViecDto[] | undefined;
    lichSuUploadList: LichSuUploadDto[] | undefined;
    configEmail: GetConfigEmailForViewDto;
    viTriCongViec: TruongGiaoDichDto[] | undefined;
    tienDoTuyenDung: TruongGiaoDichDto[] | undefined;
    trangThai: TruongGiaoDichDto[] | undefined;
    kenhTuyenDung: TruongGiaoDichDto[] | undefined;
    congty: TruongGiaoDichDto[] | undefined;
    gioiTinh: TruongGiaoDichDto[] | undefined;
    tinhTrangHonNhan: TruongGiaoDichDto[] | undefined;
    trinhDoDaoTao: TruongGiaoDichDto[] | undefined;
    xepLoaiHocLuc: TruongGiaoDichDto[] | undefined;
    tinhTrangNhanSu: TruongGiaoDichDto[] | undefined;
    noiKhamBenhList: DangKyKCBDto[] | undefined;
    defaultCbbOption: TruongGiaoDichDto[] | undefined;
}

export class ListInfoHoSo implements IListInfoHoSo {
    maChamCong: string | undefined;
    maNhanVien: string | undefined;
    hoVaTen: string | undefined;
    chucDanh: string | undefined;
    phongBan: string | undefined;
    hopDongHienTai: string | undefined;
    ngaySinh: moment.Moment | undefined;
    gioiTinh: string | undefined;
    trinhDoDaoTao: string | undefined;
    noiDaoTao: string | undefined;
    chuyenNganh: string | undefined;
    xepLoai: string | undefined;
    soCMND: string | undefined;
    ngayCap: moment.Moment | undefined;
    noiCap: string | undefined;
    mstCaNhan: string | undefined;
    nguyenQuan: string | undefined;
    diaChiHKTT: string | undefined;
    sdt: string | undefined;
    skype: string | undefined;
    emailCaNhan: string | undefined;
    facebook: string | undefined;
    ngayHetHan: moment.Moment | undefined;
    ngayKyHD: moment.Moment | undefined;
    ngayKyHDTT: moment.Moment | undefined;
    ngayKyHDKV: moment.Moment | undefined;
    ngayKyHDCTV: moment.Moment | undefined;
    ngayKyHDTv: moment.Moment | undefined;
    ngayKyHD12: moment.Moment | undefined;
    ngayKyHD36: moment.Moment | undefined;
    ngayKyHDKTH: moment.Moment | undefined;
    stk: string | undefined;
    nganHang: string | undefined;
    chiNhanh: string | undefined;
    soHD: string | undefined;
    mucLuong: number;
    dvt: string | undefined;
    choNgoi: string | undefined;
    tenCTY: string | undefined;
    ghiChu: string | undefined;
    namTotNghiep: number | undefined;
    anhDaiDien: string | undefined;
    donViCongTac: string | undefined;
    viTriCongViecCode: string | undefined;
    danToc: string | undefined;
    tonGiao: string | undefined;
    quocTich: string | undefined;
    trinhDoVanHoa: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    khoa: string | undefined;
    tinhTrangHonNhanCode: string | undefined;
    tepDinhKem: string | undefined;
    dtDiDong: string | undefined;
    dtCoQuan: string | undefined;
    dtNhaRieng: string | undefined;
    dtKhac: string | undefined;
    emailCoQuan: string | undefined;
    emailKhac: string | undefined;
    tinhThanhID: number | undefined;
    noiSinh: string | undefined;
    quocGiaHKTT: string | undefined;
    tinhThanhHKTT: string | undefined;
    soSoHoKhau: string | undefined;
    maSoHoGiaDinh: string | undefined;
    laChuHo: boolean;
    quocGiaHN: string | undefined;
    tinhThanhHN: string | undefined;
    diaChiHN: string | undefined;
    hoVaTenLHKC: string | undefined;
    quanHeLHKC: string | undefined;
    dtDiDongLHKC: string | undefined;
    dtNhaRiengLHKC: string | undefined;
    emailLHKC: string | undefined;
    diaChiLHKC: string | undefined;
    cap: string | undefined;
    bac: string | undefined;
    trangThaiLamViecCode: string | undefined;
    quanLyTrucTiep: string | undefined;
    quanLyGianTiep: string | undefined;
    diaDiemLamViecCode: string | undefined;
    soSoQLLaoDong: string | undefined;
    ngayTapSu: moment.Moment | undefined;
    ngayThuViec: moment.Moment | undefined;
    ngayChinhThuc: moment.Moment | undefined;
    soNgayPhep: number | undefined;
    bacLuongCode: string | undefined;
    luongCoBan: number | undefined;
    luongDongBH: number | undefined;
    soCongChuan: number | undefined;
    donViSoCongChuanCode: string | undefined;
    tkNganHang: string | undefined;
    nganHangCode: string | undefined;
    thamGiaCongDoan: boolean;
    ngayThamGiaBH: moment.Moment | undefined;
    tyLeDongBH: number | undefined;
    soSoBHXH: string | undefined;
    maSoBHXH: string | undefined;
    maTinhCap: string | undefined;
    soTheBHYT: string | undefined;
    ngayHetHanBHYT: moment.Moment | undefined;
    noiDangKyKCBID: number | undefined;
    maSoNoiKCB: string | undefined;
    stt: string | undefined;
    id: number;

    constructor(data?: IListInfoHoSo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maChamCong = data["maChamCong"];
            this.maNhanVien = data["maNhanVien"];
            this.hoVaTen = data["hoVaTen"];
            this.chucDanh = data["chucDanh"];
            this.phongBan = data["phongBan"];
            this.hopDongHienTai = data["hopDongHienTai"];
            this.ngaySinh = data["ngaySinh"] ? moment(data["ngaySinh"].toString()) : <any>undefined;
            this.gioiTinh = data["gioiTinh"];
            this.trinhDoDaoTao = data["trinhDoDaoTao"];
            this.noiDaoTao = data["noiDaoTao"];
            this.chuyenNganh = data["chuyenNganh"];
            this.xepLoai = data["xepLoai"];
            this.soCMND = data["soCMND"];
            this.ngayCap = data["ngayCap"] ? moment(data["ngayCap"].toString()) : <any>undefined;
            this.noiCap = data["noiCap"];
            this.mstCaNhan = data["mstCaNhan"];
            this.nguyenQuan = data["nguyenQuan"];
            this.diaChiHKTT = data["diaChiHKTT"];
            this.sdt = data["sdt"];
            this.skype = data["skype"];
            this.emailCaNhan = data["emailCaNhan"];
            this.facebook = data["facebook"];
            this.ngayHetHan = data["ngayHetHan"] ? moment(data["ngayHetHan"].toString()) : <any>undefined;
            this.ngayKyHD = data["ngayKyHD"] ? moment(data["ngayKyHD"].toString()) : <any>undefined;
            this.ngayKyHDTT = data["ngayKyHDTT"] ? moment(data["ngayKyHDTT"].toString()) : <any>undefined;
            this.ngayKyHDKV = data["ngayKyHDKV"] ? moment(data["ngayKyHDKV"].toString()) : <any>undefined;
            this.ngayKyHDCTV = data["ngayKyHDCTV"] ? moment(data["ngayKyHDCTV"].toString()) : <any>undefined;
            this.ngayKyHDTv = data["ngayKyHDTv"] ? moment(data["ngayKyHDTv"].toString()) : <any>undefined;
            this.ngayKyHD12 = data["ngayKyHD12"] ? moment(data["ngayKyHD12"].toString()) : <any>undefined;
            this.ngayKyHD36 = data["ngayKyHD36"] ? moment(data["ngayKyHD36"].toString()) : <any>undefined;
            this.ngayKyHDKTH = data["ngayKyHDKTH"] ? moment(data["ngayKyHDKTH"].toString()) : <any>undefined;
            this.stk = data["stk"];
            this.nganHang = data["nganHang"];
            this.chiNhanh = data["chiNhanh"];
            this.soHD = data["soHD"];
            this.mucLuong = data["mucLuong"];
            this.dvt = data["dvt"];
            this.choNgoi = data["choNgoi"];
            this.tenCTY = data["tenCTY"];
            this.ghiChu = data["ghiChu"];
            this.namTotNghiep = data["namTotNghiep"];
            this.anhDaiDien = data["anhDaiDien"];
            this.donViCongTac = data["donViCongTac"];
            this.viTriCongViecCode = data["viTriCongViecCode"];
            this.danToc = data["danToc"];
            this.tonGiao = data["tonGiao"];
            this.quocTich = data["quocTich"];
            this.trinhDoVanHoa = data["trinhDoVanHoa"];
            this.trinhDoDaoTaoCode = data["trinhDoDaoTaoCode"];
            this.khoa = data["khoa"];
            this.tinhTrangHonNhanCode = data["tinhTrangHonNhanCode"];
            this.tepDinhKem = data["tepDinhKem"];
            this.dtDiDong = data["dtDiDong"];
            this.dtCoQuan = data["dtCoQuan"];
            this.dtNhaRieng = data["dtNhaRieng"];
            this.dtKhac = data["dtKhac"];
            this.emailCoQuan = data["emailCoQuan"];
            this.emailKhac = data["emailKhac"];
            this.tinhThanhID = data["tinhThanhID"];
            this.noiSinh = data["noiSinh"];
            this.quocGiaHKTT = data["quocGiaHKTT"];
            this.tinhThanhHKTT = data["tinhThanhHKTT"];
            this.soSoHoKhau = data["soSoHoKhau"];
            this.maSoHoGiaDinh = data["maSoHoGiaDinh"];
            this.laChuHo = data["laChuHo"];
            this.quocGiaHN = data["quocGiaHN"];
            this.tinhThanhHN = data["tinhThanhHN"];
            this.diaChiHN = data["diaChiHN"];
            this.hoVaTenLHKC = data["hoVaTenLHKC"];
            this.quanHeLHKC = data["quanHeLHKC"];
            this.dtDiDongLHKC = data["dtDiDongLHKC"];
            this.dtNhaRiengLHKC = data["dtNhaRiengLHKC"];
            this.emailLHKC = data["emailLHKC"];
            this.diaChiLHKC = data["diaChiLHKC"];
            this.cap = data["cap"];
            this.bac = data["bac"];
            this.trangThaiLamViecCode = data["trangThaiLamViecCode"];
            this.quanLyTrucTiep = data["quanLyTrucTiep"];
            this.quanLyGianTiep = data["quanLyGianTiep"];
            this.diaDiemLamViecCode = data["diaDiemLamViecCode"];
            this.soSoQLLaoDong = data["soSoQLLaoDong"];
            this.ngayTapSu = data["ngayTapSu"] ? moment(data["ngayTapSu"].toString()) : <any>undefined;
            this.ngayThuViec = data["ngayThuViec"] ? moment(data["ngayThuViec"].toString()) : <any>undefined;
            this.ngayChinhThuc = data["ngayChinhThuc"] ? moment(data["ngayChinhThuc"].toString()) : <any>undefined;
            this.soNgayPhep = data["soNgayPhep"];
            this.bacLuongCode = data["bacLuongCode"];
            this.luongCoBan = data["luongCoBan"];
            this.luongDongBH = data["luongDongBH"];
            this.soCongChuan = data["soCongChuan"];
            this.donViSoCongChuanCode = data["donViSoCongChuanCode"];
            this.tkNganHang = data["tkNganHang"];
            this.nganHangCode = data["nganHangCode"];
            this.thamGiaCongDoan = data["thamGiaCongDoan"];
            this.ngayThamGiaBH = data["ngayThamGiaBH"] ? moment(data["ngayThamGiaBH"].toString()) : <any>undefined;
            this.tyLeDongBH = data["tyLeDongBH"];
            this.soSoBHXH = data["soSoBHXH"];
            this.maSoBHXH = data["maSoBHXH"];
            this.maTinhCap = data["maTinhCap"];
            this.soTheBHYT = data["soTheBHYT"];
            this.ngayHetHanBHYT = data["ngayHetHanBHYT"] ? moment(data["ngayHetHanBHYT"].toString()) : <any>undefined;
            this.noiDangKyKCBID = data["noiDangKyKCBID"];
            this.maSoNoiKCB = data["maSoNoiKCB"];
            this.stt = data["stt"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ListInfoHoSo {
        data = typeof data === 'object' ? data : {};
        let result = new ListInfoHoSo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maChamCong"] = this.maChamCong;
        data["maNhanVien"] = this.maNhanVien;
        data["hoVaTen"] = this.hoVaTen;
        data["chucDanh"] = this.chucDanh;
        data["phongBan"] = this.phongBan;
        data["hopDongHienTai"] = this.hopDongHienTai;
        data["ngaySinh"] = this.ngaySinh ? this.ngaySinh.toISOString() : <any>undefined;
        data["gioiTinh"] = this.gioiTinh;
        data["trinhDoDaoTao"] = this.trinhDoDaoTao;
        data["noiDaoTao"] = this.noiDaoTao;
        data["chuyenNganh"] = this.chuyenNganh;
        data["xepLoai"] = this.xepLoai;
        data["soCMND"] = this.soCMND;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["noiCap"] = this.noiCap;
        data["mstCaNhan"] = this.mstCaNhan;
        data["nguyenQuan"] = this.nguyenQuan;
        data["diaChiHKTT"] = this.diaChiHKTT;
        data["sdt"] = this.sdt;
        data["skype"] = this.skype;
        data["emailCaNhan"] = this.emailCaNhan;
        data["facebook"] = this.facebook;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        data["ngayKyHD"] = this.ngayKyHD ? this.ngayKyHD.toISOString() : <any>undefined;
        data["ngayKyHDTT"] = this.ngayKyHDTT ? this.ngayKyHDTT.toISOString() : <any>undefined;
        data["ngayKyHDKV"] = this.ngayKyHDKV ? this.ngayKyHDKV.toISOString() : <any>undefined;
        data["ngayKyHDCTV"] = this.ngayKyHDCTV ? this.ngayKyHDCTV.toISOString() : <any>undefined;
        data["ngayKyHDTv"] = this.ngayKyHDTv ? this.ngayKyHDTv.toISOString() : <any>undefined;
        data["ngayKyHD12"] = this.ngayKyHD12 ? this.ngayKyHD12.toISOString() : <any>undefined;
        data["ngayKyHD36"] = this.ngayKyHD36 ? this.ngayKyHD36.toISOString() : <any>undefined;
        data["ngayKyHDKTH"] = this.ngayKyHDKTH ? this.ngayKyHDKTH.toISOString() : <any>undefined;
        data["stk"] = this.stk;
        data["nganHang"] = this.nganHang;
        data["chiNhanh"] = this.chiNhanh;
        data["soHD"] = this.soHD;
        data["mucLuong"] = this.mucLuong;
        data["dvt"] = this.dvt;
        data["choNgoi"] = this.choNgoi;
        data["tenCTY"] = this.tenCTY;
        data["ghiChu"] = this.ghiChu;
        data["namTotNghiep"] = this.namTotNghiep;
        data["anhDaiDien"] = this.anhDaiDien;
        data["donViCongTac"] = this.donViCongTac;
        data["viTriCongViecCode"] = this.viTriCongViecCode;
        data["danToc"] = this.danToc;
        data["tonGiao"] = this.tonGiao;
        data["quocTich"] = this.quocTich;
        data["trinhDoVanHoa"] = this.trinhDoVanHoa;
        data["trinhDoDaoTaoCode"] = this.trinhDoDaoTaoCode;
        data["khoa"] = this.khoa;
        data["tinhTrangHonNhanCode"] = this.tinhTrangHonNhanCode;
        data["tepDinhKem"] = this.tepDinhKem;
        data["dtDiDong"] = this.dtDiDong;
        data["dtCoQuan"] = this.dtCoQuan;
        data["dtNhaRieng"] = this.dtNhaRieng;
        data["dtKhac"] = this.dtKhac;
        data["emailCoQuan"] = this.emailCoQuan;
        data["emailKhac"] = this.emailKhac;
        data["tinhThanhID"] = this.tinhThanhID;
        data["noiSinh"] = this.noiSinh;
        data["quocGiaHKTT"] = this.quocGiaHKTT;
        data["tinhThanhHKTT"] = this.tinhThanhHKTT;
        data["soSoHoKhau"] = this.soSoHoKhau;
        data["maSoHoGiaDinh"] = this.maSoHoGiaDinh;
        data["laChuHo"] = this.laChuHo;
        data["quocGiaHN"] = this.quocGiaHN;
        data["tinhThanhHN"] = this.tinhThanhHN;
        data["diaChiHN"] = this.diaChiHN;
        data["hoVaTenLHKC"] = this.hoVaTenLHKC;
        data["quanHeLHKC"] = this.quanHeLHKC;
        data["dtDiDongLHKC"] = this.dtDiDongLHKC;
        data["dtNhaRiengLHKC"] = this.dtNhaRiengLHKC;
        data["emailLHKC"] = this.emailLHKC;
        data["diaChiLHKC"] = this.diaChiLHKC;
        data["cap"] = this.cap;
        data["bac"] = this.bac;
        data["trangThaiLamViecCode"] = this.trangThaiLamViecCode;
        data["quanLyTrucTiep"] = this.quanLyTrucTiep;
        data["quanLyGianTiep"] = this.quanLyGianTiep;
        data["diaDiemLamViecCode"] = this.diaDiemLamViecCode;
        data["soSoQLLaoDong"] = this.soSoQLLaoDong;
        data["ngayTapSu"] = this.ngayTapSu ? this.ngayTapSu.toISOString() : <any>undefined;
        data["ngayThuViec"] = this.ngayThuViec ? this.ngayThuViec.toISOString() : <any>undefined;
        data["ngayChinhThuc"] = this.ngayChinhThuc ? this.ngayChinhThuc.toISOString() : <any>undefined;
        data["soNgayPhep"] = this.soNgayPhep;
        data["bacLuongCode"] = this.bacLuongCode;
        data["luongCoBan"] = this.luongCoBan;
        data["luongDongBH"] = this.luongDongBH;
        data["soCongChuan"] = this.soCongChuan;
        data["donViSoCongChuanCode"] = this.donViSoCongChuanCode;
        data["tkNganHang"] = this.tkNganHang;
        data["nganHangCode"] = this.nganHangCode;
        data["thamGiaCongDoan"] = this.thamGiaCongDoan;
        data["ngayThamGiaBH"] = this.ngayThamGiaBH ? this.ngayThamGiaBH.toISOString() : <any>undefined;
        data["tyLeDongBH"] = this.tyLeDongBH;
        data["soSoBHXH"] = this.soSoBHXH;
        data["maSoBHXH"] = this.maSoBHXH;
        data["maTinhCap"] = this.maTinhCap;
        data["soTheBHYT"] = this.soTheBHYT;
        data["ngayHetHanBHYT"] = this.ngayHetHanBHYT ? this.ngayHetHanBHYT.toISOString() : <any>undefined;
        data["noiDangKyKCBID"] = this.noiDangKyKCBID;
        data["maSoNoiKCB"] = this.maSoNoiKCB;
        data["stt"] = this.stt;
        data["id"] = this.id;
        return data; 
    }

    clone(): ListInfoHoSo {
        const json = this.toJSON();
        let result = new ListInfoHoSo();
        result.init(json);
        return result;
    }
}

export interface IListInfoHoSo {
    maChamCong: string | undefined;
    maNhanVien: string | undefined;
    hoVaTen: string | undefined;
    chucDanh: string | undefined;
    phongBan: string | undefined;
    hopDongHienTai: string | undefined;
    ngaySinh: moment.Moment | undefined;
    gioiTinh: string | undefined;
    trinhDoDaoTao: string | undefined;
    noiDaoTao: string | undefined;
    chuyenNganh: string | undefined;
    xepLoai: string | undefined;
    soCMND: string | undefined;
    ngayCap: moment.Moment | undefined;
    noiCap: string | undefined;
    mstCaNhan: string | undefined;
    nguyenQuan: string | undefined;
    diaChiHKTT: string | undefined;
    sdt: string | undefined;
    skype: string | undefined;
    emailCaNhan: string | undefined;
    facebook: string | undefined;
    ngayHetHan: moment.Moment | undefined;
    ngayKyHD: moment.Moment | undefined;
    ngayKyHDTT: moment.Moment | undefined;
    ngayKyHDKV: moment.Moment | undefined;
    ngayKyHDCTV: moment.Moment | undefined;
    ngayKyHDTv: moment.Moment | undefined;
    ngayKyHD12: moment.Moment | undefined;
    ngayKyHD36: moment.Moment | undefined;
    ngayKyHDKTH: moment.Moment | undefined;
    stk: string | undefined;
    nganHang: string | undefined;
    chiNhanh: string | undefined;
    soHD: string | undefined;
    mucLuong: number;
    dvt: string | undefined;
    choNgoi: string | undefined;
    tenCTY: string | undefined;
    ghiChu: string | undefined;
    namTotNghiep: number | undefined;
    anhDaiDien: string | undefined;
    donViCongTac: string | undefined;
    viTriCongViecCode: string | undefined;
    danToc: string | undefined;
    tonGiao: string | undefined;
    quocTich: string | undefined;
    trinhDoVanHoa: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    khoa: string | undefined;
    tinhTrangHonNhanCode: string | undefined;
    tepDinhKem: string | undefined;
    dtDiDong: string | undefined;
    dtCoQuan: string | undefined;
    dtNhaRieng: string | undefined;
    dtKhac: string | undefined;
    emailCoQuan: string | undefined;
    emailKhac: string | undefined;
    tinhThanhID: number | undefined;
    noiSinh: string | undefined;
    quocGiaHKTT: string | undefined;
    tinhThanhHKTT: string | undefined;
    soSoHoKhau: string | undefined;
    maSoHoGiaDinh: string | undefined;
    laChuHo: boolean;
    quocGiaHN: string | undefined;
    tinhThanhHN: string | undefined;
    diaChiHN: string | undefined;
    hoVaTenLHKC: string | undefined;
    quanHeLHKC: string | undefined;
    dtDiDongLHKC: string | undefined;
    dtNhaRiengLHKC: string | undefined;
    emailLHKC: string | undefined;
    diaChiLHKC: string | undefined;
    cap: string | undefined;
    bac: string | undefined;
    trangThaiLamViecCode: string | undefined;
    quanLyTrucTiep: string | undefined;
    quanLyGianTiep: string | undefined;
    diaDiemLamViecCode: string | undefined;
    soSoQLLaoDong: string | undefined;
    ngayTapSu: moment.Moment | undefined;
    ngayThuViec: moment.Moment | undefined;
    ngayChinhThuc: moment.Moment | undefined;
    soNgayPhep: number | undefined;
    bacLuongCode: string | undefined;
    luongCoBan: number | undefined;
    luongDongBH: number | undefined;
    soCongChuan: number | undefined;
    donViSoCongChuanCode: string | undefined;
    tkNganHang: string | undefined;
    nganHangCode: string | undefined;
    thamGiaCongDoan: boolean;
    ngayThamGiaBH: moment.Moment | undefined;
    tyLeDongBH: number | undefined;
    soSoBHXH: string | undefined;
    maSoBHXH: string | undefined;
    maTinhCap: string | undefined;
    soTheBHYT: string | undefined;
    ngayHetHanBHYT: moment.Moment | undefined;
    noiDangKyKCBID: number | undefined;
    maSoNoiKCB: string | undefined;
    stt: string | undefined;
    id: number;
}

export class QuyTrinhCongTacDto implements IQuyTrinhCongTacDto {
    tenCty: string | undefined;
    dateTo: moment.Moment;
    dateFrom: moment.Moment;
    viTriCongViecCode: string | undefined;
    donViCongTacID: number | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiCode: string | undefined;
    ghiChu: string | undefined;
    maHoSo: number | undefined;
    id: number;

    constructor(data?: IQuyTrinhCongTacDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenCty = data["tenCty"];
            this.dateTo = data["dateTo"] ? moment(data["dateTo"].toString()) : <any>undefined;
            this.dateFrom = data["dateFrom"] ? moment(data["dateFrom"].toString()) : <any>undefined;
            this.viTriCongViecCode = data["viTriCongViecCode"];
            this.donViCongTacID = data["donViCongTacID"];
            this.quanLyTrucTiep = data["quanLyTrucTiep"];
            this.trangThaiCode = data["trangThaiCode"];
            this.ghiChu = data["ghiChu"];
            this.maHoSo = data["maHoSo"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuyTrinhCongTacDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuyTrinhCongTacDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenCty"] = this.tenCty;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["viTriCongViecCode"] = this.viTriCongViecCode;
        data["donViCongTacID"] = this.donViCongTacID;
        data["quanLyTrucTiep"] = this.quanLyTrucTiep;
        data["trangThaiCode"] = this.trangThaiCode;
        data["ghiChu"] = this.ghiChu;
        data["maHoSo"] = this.maHoSo;
        data["id"] = this.id;
        return data; 
    }

    clone(): QuyTrinhCongTacDto {
        const json = this.toJSON();
        let result = new QuyTrinhCongTacDto();
        result.init(json);
        return result;
    }
}

export interface IQuyTrinhCongTacDto {
    tenCty: string | undefined;
    dateTo: moment.Moment;
    dateFrom: moment.Moment;
    viTriCongViecCode: string | undefined;
    donViCongTacID: number | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiCode: string | undefined;
    ghiChu: string | undefined;
    maHoSo: number | undefined;
    id: number;
}

export class GetQuyTrinhCongTacForViewDto implements IGetQuyTrinhCongTacForViewDto {
    quyTrinhCongTac: QuyTrinhCongTacDto;
    donViCongTacValue: string | undefined;
    loaiHopDongValue: string | undefined;
    viTriCongViecValue: string | undefined;
    hinhThucLamViecValue: string | undefined;

    constructor(data?: IGetQuyTrinhCongTacForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.quyTrinhCongTac = new QuyTrinhCongTacDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.quyTrinhCongTac = data["quyTrinhCongTac"] ? QuyTrinhCongTacDto.fromJS(data["quyTrinhCongTac"]) : new QuyTrinhCongTacDto();
            this.donViCongTacValue = data["donViCongTacValue"];
            this.loaiHopDongValue = data["loaiHopDongValue"];
            this.viTriCongViecValue = data["viTriCongViecValue"];
            this.hinhThucLamViecValue = data["hinhThucLamViecValue"];
        }
    }

    static fromJS(data: any): GetQuyTrinhCongTacForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuyTrinhCongTacForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quyTrinhCongTac"] = this.quyTrinhCongTac ? this.quyTrinhCongTac.toJSON() : <any>undefined;
        data["donViCongTacValue"] = this.donViCongTacValue;
        data["loaiHopDongValue"] = this.loaiHopDongValue;
        data["viTriCongViecValue"] = this.viTriCongViecValue;
        data["hinhThucLamViecValue"] = this.hinhThucLamViecValue;
        return data; 
    }

    clone(): GetQuyTrinhCongTacForViewDto {
        const json = this.toJSON();
        let result = new GetQuyTrinhCongTacForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetQuyTrinhCongTacForViewDto {
    quyTrinhCongTac: QuyTrinhCongTacDto;
    donViCongTacValue: string | undefined;
    loaiHopDongValue: string | undefined;
    viTriCongViecValue: string | undefined;
    hinhThucLamViecValue: string | undefined;
}

export class PagedResultDtoOfGetQuyTrinhCongTacForViewDto implements IPagedResultDtoOfGetQuyTrinhCongTacForViewDto {
    totalCount: number;
    items: GetQuyTrinhCongTacForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetQuyTrinhCongTacForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetQuyTrinhCongTacForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetQuyTrinhCongTacForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetQuyTrinhCongTacForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetQuyTrinhCongTacForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetQuyTrinhCongTacForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetQuyTrinhCongTacForViewDto {
    totalCount: number;
    items: GetQuyTrinhCongTacForViewDto[] | undefined;
}

export class GetHoSoForEditOutput implements IGetHoSoForEditOutput {
    hoSo: CreateOrEditHoSoDto;
    quaTrinhCongTac: PagedResultDtoOfGetQuyTrinhCongTacForViewDto;
    danhSachCV: OrganizationUnitDto[] | undefined;
    lichSuUpload: LichSuUploadDto[] | undefined;

    constructor(data?: IGetHoSoForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hoSo = new CreateOrEditHoSoDto();
            this.quaTrinhCongTac = new PagedResultDtoOfGetQuyTrinhCongTacForViewDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.hoSo = data["hoSo"] ? CreateOrEditHoSoDto.fromJS(data["hoSo"]) : new CreateOrEditHoSoDto();
            this.quaTrinhCongTac = data["quaTrinhCongTac"] ? PagedResultDtoOfGetQuyTrinhCongTacForViewDto.fromJS(data["quaTrinhCongTac"]) : new PagedResultDtoOfGetQuyTrinhCongTacForViewDto();
            if (data["danhSachCV"] && data["danhSachCV"].constructor === Array) {
                this.danhSachCV = [];
                for (let item of data["danhSachCV"])
                    this.danhSachCV.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["lichSuUpload"] && data["lichSuUpload"].constructor === Array) {
                this.lichSuUpload = [];
                for (let item of data["lichSuUpload"])
                    this.lichSuUpload.push(LichSuUploadDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetHoSoForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetHoSoForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hoSo"] = this.hoSo ? this.hoSo.toJSON() : <any>undefined;
        data["quaTrinhCongTac"] = this.quaTrinhCongTac ? this.quaTrinhCongTac.toJSON() : <any>undefined;
        if (this.danhSachCV && this.danhSachCV.constructor === Array) {
            data["danhSachCV"] = [];
            for (let item of this.danhSachCV)
                data["danhSachCV"].push(item.toJSON());
        }
        if (this.lichSuUpload && this.lichSuUpload.constructor === Array) {
            data["lichSuUpload"] = [];
            for (let item of this.lichSuUpload)
                data["lichSuUpload"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetHoSoForEditOutput {
        const json = this.toJSON();
        let result = new GetHoSoForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetHoSoForEditOutput {
    hoSo: CreateOrEditHoSoDto;
    quaTrinhCongTac: PagedResultDtoOfGetQuyTrinhCongTacForViewDto;
    danhSachCV: OrganizationUnitDto[] | undefined;
    lichSuUpload: LichSuUploadDto[] | undefined;
}

export class CreateOrEditHoSoInput implements ICreateOrEditHoSoInput {
    hoSo: CreateOrEditHoSoDto;
    lichSuUpLoad: LichSuUploadNewDto[] | undefined;

    constructor(data?: ICreateOrEditHoSoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hoSo = new CreateOrEditHoSoDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.hoSo = data["hoSo"] ? CreateOrEditHoSoDto.fromJS(data["hoSo"]) : new CreateOrEditHoSoDto();
            if (data["lichSuUpLoad"] && data["lichSuUpLoad"].constructor === Array) {
                this.lichSuUpLoad = [];
                for (let item of data["lichSuUpLoad"])
                    this.lichSuUpLoad.push(LichSuUploadNewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrEditHoSoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditHoSoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hoSo"] = this.hoSo ? this.hoSo.toJSON() : <any>undefined;
        if (this.lichSuUpLoad && this.lichSuUpLoad.constructor === Array) {
            data["lichSuUpLoad"] = [];
            for (let item of this.lichSuUpLoad)
                data["lichSuUpLoad"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateOrEditHoSoInput {
        const json = this.toJSON();
        let result = new CreateOrEditHoSoInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditHoSoInput {
    hoSo: CreateOrEditHoSoDto;
    lichSuUpLoad: LichSuUploadNewDto[] | undefined;
}

export class TopStatsData implements ITopStatsData {
    newTenantsCount: number;
    newSubscriptionAmount: number;
    dashboardPlaceholder1: number;
    dashboardPlaceholder2: number;

    constructor(data?: ITopStatsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
        }
    }

    static fromJS(data: any): TopStatsData {
        data = typeof data === 'object' ? data : {};
        let result = new TopStatsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        return data; 
    }

    clone(): TopStatsData {
        const json = this.toJSON();
        let result = new TopStatsData();
        result.init(json);
        return result;
    }
}

export interface ITopStatsData {
    newTenantsCount: number;
    newSubscriptionAmount: number;
    dashboardPlaceholder1: number;
    dashboardPlaceholder2: number;
}

export class RecentTenant implements IRecentTenant {
    id: number;
    name: string | undefined;
    creationTime: moment.Moment;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): RecentTenant {
        const json = this.toJSON();
        let result = new RecentTenant();
        result.init(json);
        return result;
    }
}

export interface IRecentTenant {
    id: number;
    name: string | undefined;
    creationTime: moment.Moment;
}

export class GetRecentTenantsOutput implements IGetRecentTenantsOutput {
    recentTenants: RecentTenant[] | undefined;
    recentTenantsDayCount: number;
    maxRecentTenantsShownCount: number;
    tenantCreationStartDate: moment.Moment;

    constructor(data?: IGetRecentTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [];
                for (let item of data["recentTenants"])
                    this.recentTenants.push(RecentTenant.fromJS(item));
            }
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRecentTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): GetRecentTenantsOutput {
        const json = this.toJSON();
        let result = new GetRecentTenantsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRecentTenantsOutput {
    recentTenants: RecentTenant[] | undefined;
    recentTenantsDayCount: number;
    maxRecentTenantsShownCount: number;
    tenantCreationStartDate: moment.Moment;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }

    clone(): ExpiringTenant {
        const json = this.toJSON();
        let result = new ExpiringTenant();
        result.init(json);
        return result;
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number;
}

export class GetExpiringTenantsOutput implements IGetExpiringTenantsOutput {
    expiringTenants: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount: number;
    maxExpiringTenantsShownCount: number;
    subscriptionEndDateStart: moment.Moment;
    subscriptionEndDateEnd: moment.Moment;

    constructor(data?: IGetExpiringTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [];
                for (let item of data["expiringTenants"])
                    this.expiringTenants.push(ExpiringTenant.fromJS(item));
            }
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetExpiringTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpiringTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        return data; 
    }

    clone(): GetExpiringTenantsOutput {
        const json = this.toJSON();
        let result = new GetExpiringTenantsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetExpiringTenantsOutput {
    expiringTenants: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount: number;
    maxExpiringTenantsShownCount: number;
    subscriptionEndDateStart: moment.Moment;
    subscriptionEndDateEnd: moment.Moment;
}

export enum ChartDateInterval {
    Daily = 1, 
    Weekly = 2, 
    Monthly = 3, 
}

export class IncomeStastistic implements IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment;
    amount: number;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }

    clone(): IncomeStastistic {
        const json = this.toJSON();
        let result = new IncomeStastistic();
        result.init(json);
        return result;
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment;
    amount: number;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetIncomeStatisticsDataOutput {
        const json = this.toJSON();
        let result = new GetIncomeStatisticsDataOutput();
        result.init(json);
        return result;
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class TenantEdition implements ITenantEdition {
    label: string | undefined;
    value: number;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }

    clone(): TenantEdition {
        const json = this.toJSON();
        let result = new TenantEdition();
        result.init(json);
        return result;
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetEditionTenantStatisticsOutput {
        const json = this.toJSON();
        let result = new GetEditionTenantStatisticsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }

    clone(): GeneralSettingsEditDto {
        const json = this.toJSON();
        let result = new GeneralSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class SessionTimeOutSettingsEditDto implements ISessionTimeOutSettingsEditDto {
    isEnabled: boolean;
    timeOutSecond: number;
    showTimeOutNotificationSecond: number;

    constructor(data?: ISessionTimeOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.timeOutSecond = data["timeOutSecond"];
            this.showTimeOutNotificationSecond = data["showTimeOutNotificationSecond"];
        }
    }

    static fromJS(data: any): SessionTimeOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionTimeOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["timeOutSecond"] = this.timeOutSecond;
        data["showTimeOutNotificationSecond"] = this.showTimeOutNotificationSecond;
        return data; 
    }

    clone(): SessionTimeOutSettingsEditDto {
        const json = this.toJSON();
        let result = new SessionTimeOutSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ISessionTimeOutSettingsEditDto {
    isEnabled: boolean;
    timeOutSecond: number;
    showTimeOutNotificationSecond: number;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    useCaptchaOnLogin: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sessionTimeOutSettings = new SessionTimeOutSettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
            this.useCaptchaOnLogin = data["useCaptchaOnLogin"];
            this.sessionTimeOutSettings = data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(data["sessionTimeOutSettings"]) : new SessionTimeOutSettingsEditDto();
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HostUserManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new HostUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    useCaptchaOnLogin: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }

    clone(): EmailSettingsEditDto {
        const json = this.toJSON();
        let result = new EmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }

    clone(): TenantManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }

    clone(): PasswordComplexitySetting {
        const json = this.toJSON();
        let result = new PasswordComplexitySetting();
        result.init(json);
        return result;
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }

    clone(): UserLockOutSettingsEditDto {
        const json = this.toJSON();
        let result = new UserLockOutSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }

    clone(): TwoFactorLoginSettingsEditDto {
        const json = this.toJSON();
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean;
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.passwordComplexity = new PasswordComplexitySetting();
            this.defaultPasswordComplexity = new PasswordComplexitySetting();
            this.userLockOut = new UserLockOutSettingsEditDto();
            this.twoFactorLogin = new TwoFactorLoginSettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.allowOneConcurrentLoginPerUser = data["allowOneConcurrentLoginPerUser"];
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : new PasswordComplexitySetting();
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : new PasswordComplexitySetting();
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : new UserLockOutSettingsEditDto();
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : new TwoFactorLoginSettingsEditDto();
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowOneConcurrentLoginPerUser"] = this.allowOneConcurrentLoginPerUser;
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SecuritySettingsEditDto {
        const json = this.toJSON();
        let result = new SecuritySettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean;
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }

    clone(): HostBillingSettingsEditDto {
        const json = this.toJSON();
        let result = new HostBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }

    clone(): OtherSettingsEditDto {
        const json = this.toJSON();
        let result = new OtherSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;
    otherSettings: OtherSettingsEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
            this.billing = new HostBillingSettingsEditDto();
            this.otherSettings = new OtherSettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : new HostBillingSettingsEditDto();
            this.otherSettings = data["otherSettings"] ? OtherSettingsEditDto.fromJS(data["otherSettings"]) : new OtherSettingsEditDto();
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HostSettingsEditDto {
        const json = this.toJSON();
        let result = new HostSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;
    otherSettings: OtherSettingsEditDto;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress: string | undefined;
    mailTo: string | undefined;
    mailForm: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    filedinhkem: string | undefined;
    tenTruyCap: string | undefined;
    matKhau: string | undefined;
    congSMTP: number;
    diaChiIP: string | undefined;
    curentTime: string | undefined;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
            this.mailTo = data["mailTo"];
            this.mailForm = data["mailForm"];
            this.subject = data["subject"];
            this.body = data["body"];
            this.filedinhkem = data["filedinhkem"];
            this.tenTruyCap = data["tenTruyCap"];
            this.matKhau = data["matKhau"];
            this.congSMTP = data["congSMTP"];
            this.diaChiIP = data["diaChiIP"];
            this.curentTime = data["curentTime"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["mailTo"] = this.mailTo;
        data["mailForm"] = this.mailForm;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["filedinhkem"] = this.filedinhkem;
        data["tenTruyCap"] = this.tenTruyCap;
        data["matKhau"] = this.matKhau;
        data["congSMTP"] = this.congSMTP;
        data["diaChiIP"] = this.diaChiIP;
        data["curentTime"] = this.curentTime;
        return data; 
    }

    clone(): SendTestEmailInput {
        const json = this.toJSON();
        let result = new SendTestEmailInput();
        result.init(json);
        return result;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string | undefined;
    mailTo: string | undefined;
    mailForm: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    filedinhkem: string | undefined;
    tenTruyCap: string | undefined;
    matKhau: string | undefined;
    congSMTP: number;
    diaChiIP: string | undefined;
    curentTime: string | undefined;
}

export class InstallDto implements IInstallDto {
    connectionString: string | undefined;
    adminPassword: string | undefined;
    webSiteUrl: string | undefined;
    serverUrl: string | undefined;
    defaultLanguage: string | undefined;
    smtpSettings: EmailSettingsEditDto;
    billInfo: HostBillingSettingsEditDto;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.smtpSettings = new EmailSettingsEditDto();
            this.billInfo = new HostBillingSettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : new EmailSettingsEditDto();
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : new HostBillingSettingsEditDto();
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }

    clone(): InstallDto {
        const json = this.toJSON();
        let result = new InstallDto();
        result.init(json);
        return result;
    }
}

export interface IInstallDto {
    connectionString: string | undefined;
    adminPassword: string | undefined;
    webSiteUrl: string | undefined;
    serverUrl: string | undefined;
    defaultLanguage: string | undefined;
    smtpSettings: EmailSettingsEditDto;
    billInfo: HostBillingSettingsEditDto;
}

export class NameValue implements INameValue {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): NameValue {
        const json = this.toJSON();
        let result = new NameValue();
        result.init(json);
        return result;
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [];
                for (let item of data["languages"])
                    this.languages.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AppSettingsJsonDto {
        const json = this.toJSON();
        let result = new AppSettingsJsonDto();
        result.init(json);
        return result;
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist: boolean;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }

    clone(): CheckDatabaseOutput {
        const json = this.toJSON();
        let result = new CheckDatabaseOutput();
        result.init(json);
        return result;
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean;
}

export class InvoiceDto implements IInvoiceDto {
    amount: number;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? moment(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (data["tenantAddress"] && data["tenantAddress"].constructor === Array) {
                this.tenantAddress = [];
                for (let item of data["tenantAddress"])
                    this.tenantAddress.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (data["hostAddress"] && data["hostAddress"].constructor === Array) {
                this.hostAddress = [];
                for (let item of data["hostAddress"])
                    this.hostAddress.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (this.tenantAddress && this.tenantAddress.constructor === Array) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (this.hostAddress && this.hostAddress.constructor === Array) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }

    clone(): InvoiceDto {
        const json = this.toJSON();
        let result = new InvoiceDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDto {
    amount: number;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId: number;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }

    clone(): CreateInvoiceDto {
        const json = this.toJSON();
        let result = new CreateInvoiceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number;
}

export class KeywordDetailDto implements IKeywordDetailDto {
    keywordId: number;
    keyword: string | undefined;
    isLeader: boolean;
    fullName: string | undefined;
    mainHandling: boolean;
    coHandling: boolean;
    toKnow: boolean;
    isActive: boolean;
    order: number;
    userId: number;
    id: number;

    constructor(data?: IKeywordDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.keywordId = data["keywordId"];
            this.keyword = data["keyword"];
            this.isLeader = data["isLeader"];
            this.fullName = data["fullName"];
            this.mainHandling = data["mainHandling"];
            this.coHandling = data["coHandling"];
            this.toKnow = data["toKnow"];
            this.isActive = data["isActive"];
            this.order = data["order"];
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): KeywordDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeywordDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywordId"] = this.keywordId;
        data["keyword"] = this.keyword;
        data["isLeader"] = this.isLeader;
        data["fullName"] = this.fullName;
        data["mainHandling"] = this.mainHandling;
        data["coHandling"] = this.coHandling;
        data["toKnow"] = this.toKnow;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }

    clone(): KeywordDetailDto {
        const json = this.toJSON();
        let result = new KeywordDetailDto();
        result.init(json);
        return result;
    }
}

export interface IKeywordDetailDto {
    keywordId: number;
    keyword: string | undefined;
    isLeader: boolean;
    fullName: string | undefined;
    mainHandling: boolean;
    coHandling: boolean;
    toKnow: boolean;
    isActive: boolean;
    order: number;
    userId: number;
    id: number;
}

export class GetKeywordDetailForViewDto implements IGetKeywordDetailForViewDto {
    keywordDetail: KeywordDetailDto;

    constructor(data?: IGetKeywordDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.keywordDetail = new KeywordDetailDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.keywordDetail = data["keywordDetail"] ? KeywordDetailDto.fromJS(data["keywordDetail"]) : new KeywordDetailDto();
        }
    }

    static fromJS(data: any): GetKeywordDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetKeywordDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywordDetail"] = this.keywordDetail ? this.keywordDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetKeywordDetailForViewDto {
        const json = this.toJSON();
        let result = new GetKeywordDetailForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetKeywordDetailForViewDto {
    keywordDetail: KeywordDetailDto;
}

export class PagedResultDtoOfGetKeywordDetailForViewDto implements IPagedResultDtoOfGetKeywordDetailForViewDto {
    totalCount: number;
    items: GetKeywordDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetKeywordDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetKeywordDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetKeywordDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetKeywordDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetKeywordDetailForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetKeywordDetailForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetKeywordDetailForViewDto {
    totalCount: number;
    items: GetKeywordDetailForViewDto[] | undefined;
}

export class CreateOrEditKeywordDetailDto implements ICreateOrEditKeywordDetailDto {
    keywordId: number;
    isLeader: boolean;
    fullName: string | undefined;
    mainHandling: boolean;
    coHandling: boolean;
    toKnow: boolean;
    isActive: boolean;
    order: number;
    userId: number;
    id: number | undefined;

    constructor(data?: ICreateOrEditKeywordDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.keywordId = data["keywordId"];
            this.isLeader = data["isLeader"];
            this.fullName = data["fullName"];
            this.mainHandling = data["mainHandling"];
            this.coHandling = data["coHandling"];
            this.toKnow = data["toKnow"];
            this.isActive = data["isActive"];
            this.order = data["order"];
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditKeywordDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditKeywordDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywordId"] = this.keywordId;
        data["isLeader"] = this.isLeader;
        data["fullName"] = this.fullName;
        data["mainHandling"] = this.mainHandling;
        data["coHandling"] = this.coHandling;
        data["toKnow"] = this.toKnow;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditKeywordDetailDto {
        const json = this.toJSON();
        let result = new CreateOrEditKeywordDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditKeywordDetailDto {
    keywordId: number;
    isLeader: boolean;
    fullName: string | undefined;
    mainHandling: boolean;
    coHandling: boolean;
    toKnow: boolean;
    isActive: boolean;
    order: number;
    userId: number;
    id: number | undefined;
}

export class GetKeywordDetailForEditOutput implements IGetKeywordDetailForEditOutput {
    keywordDetail: CreateOrEditKeywordDetailDto;

    constructor(data?: IGetKeywordDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.keywordDetail = new CreateOrEditKeywordDetailDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.keywordDetail = data["keywordDetail"] ? CreateOrEditKeywordDetailDto.fromJS(data["keywordDetail"]) : new CreateOrEditKeywordDetailDto();
        }
    }

    static fromJS(data: any): GetKeywordDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetKeywordDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywordDetail"] = this.keywordDetail ? this.keywordDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetKeywordDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetKeywordDetailForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetKeywordDetailForEditOutput {
    keywordDetail: CreateOrEditKeywordDetailDto;
}

export class LabelDto implements ILabelDto {
    name: string | undefined;
    title: string | undefined;
    description: string | undefined;
    icon: string | undefined;
    link: string | undefined;
    parent: number | undefined;
    index: number;
    requiredPermissionName: string | undefined;
    childLabels: LabelDto[] | undefined;
    number: number | undefined;
    sqlString: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: ILabelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.title = data["title"];
            this.description = data["description"];
            this.icon = data["icon"];
            this.link = data["link"];
            this.parent = data["parent"];
            this.index = data["index"];
            this.requiredPermissionName = data["requiredPermissionName"];
            if (data["childLabels"] && data["childLabels"].constructor === Array) {
                this.childLabels = [];
                for (let item of data["childLabels"])
                    this.childLabels.push(LabelDto.fromJS(item));
            }
            this.number = data["number"];
            this.sqlString = data["sqlString"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LabelDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["title"] = this.title;
        data["description"] = this.description;
        data["icon"] = this.icon;
        data["link"] = this.link;
        data["parent"] = this.parent;
        data["index"] = this.index;
        data["requiredPermissionName"] = this.requiredPermissionName;
        if (this.childLabels && this.childLabels.constructor === Array) {
            data["childLabels"] = [];
            for (let item of this.childLabels)
                data["childLabels"].push(item.toJSON());
        }
        data["number"] = this.number;
        data["sqlString"] = this.sqlString;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): LabelDto {
        const json = this.toJSON();
        let result = new LabelDto();
        result.init(json);
        return result;
    }
}

export interface ILabelDto {
    name: string | undefined;
    title: string | undefined;
    description: string | undefined;
    icon: string | undefined;
    link: string | undefined;
    parent: number | undefined;
    index: number;
    requiredPermissionName: string | undefined;
    childLabels: LabelDto[] | undefined;
    number: number | undefined;
    sqlString: string | undefined;
    isActive: boolean;
    id: number;
}

export class GetLabelForViewDto implements IGetLabelForViewDto {
    label: LabelDto;

    constructor(data?: IGetLabelForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.label = new LabelDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"] ? LabelDto.fromJS(data["label"]) : new LabelDto();
        }
    }

    static fromJS(data: any): GetLabelForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLabelForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label ? this.label.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetLabelForViewDto {
        const json = this.toJSON();
        let result = new GetLabelForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetLabelForViewDto {
    label: LabelDto;
}

export class PagedResultDtoOfGetLabelForViewDto implements IPagedResultDtoOfGetLabelForViewDto {
    totalCount: number;
    items: GetLabelForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetLabelForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetLabelForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetLabelForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetLabelForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetLabelForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetLabelForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetLabelForViewDto {
    totalCount: number;
    items: GetLabelForViewDto[] | undefined;
}

export class CreateOrEditLabelDto implements ICreateOrEditLabelDto {
    name: string | undefined;
    title: string | undefined;
    description: string | undefined;
    icon: string | undefined;
    link: string | undefined;
    parent: number | undefined;
    index: number;
    requiredPermissionName: string | undefined;
    sqlString: string | undefined;
    isActive: boolean;
    id: number | undefined;

    constructor(data?: ICreateOrEditLabelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.title = data["title"];
            this.description = data["description"];
            this.icon = data["icon"];
            this.link = data["link"];
            this.parent = data["parent"];
            this.index = data["index"];
            this.requiredPermissionName = data["requiredPermissionName"];
            this.sqlString = data["sqlString"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditLabelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLabelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["title"] = this.title;
        data["description"] = this.description;
        data["icon"] = this.icon;
        data["link"] = this.link;
        data["parent"] = this.parent;
        data["index"] = this.index;
        data["requiredPermissionName"] = this.requiredPermissionName;
        data["sqlString"] = this.sqlString;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditLabelDto {
        const json = this.toJSON();
        let result = new CreateOrEditLabelDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditLabelDto {
    name: string | undefined;
    title: string | undefined;
    description: string | undefined;
    icon: string | undefined;
    link: string | undefined;
    parent: number | undefined;
    index: number;
    requiredPermissionName: string | undefined;
    sqlString: string | undefined;
    isActive: boolean;
    id: number | undefined;
}

export class GetLabelForEditOutput implements IGetLabelForEditOutput {
    label: CreateOrEditLabelDto;

    constructor(data?: IGetLabelForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.label = new CreateOrEditLabelDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"] ? CreateOrEditLabelDto.fromJS(data["label"]) : new CreateOrEditLabelDto();
        }
    }

    static fromJS(data: any): GetLabelForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLabelForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label ? this.label.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetLabelForEditOutput {
        const json = this.toJSON();
        let result = new GetLabelForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLabelForEditOutput {
    label: CreateOrEditLabelDto;
}

export class SqlConfigDto implements ISqlConfigDto {
    code: string | undefined;
    name: string | undefined;
    isRawQuery: boolean;
    sqlContent: string | undefined;
    groupLevel: number | undefined;
    displayType: number | undefined;
    version: number | undefined;
    isDynamicColumn: boolean;
    typeGetColumn: number | undefined;
    id: number;

    constructor(data?: ISqlConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.isRawQuery = data["isRawQuery"];
            this.sqlContent = data["sqlContent"];
            this.groupLevel = data["groupLevel"];
            this.displayType = data["displayType"];
            this.version = data["version"];
            this.isDynamicColumn = data["isDynamicColumn"];
            this.typeGetColumn = data["typeGetColumn"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SqlConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new SqlConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["isRawQuery"] = this.isRawQuery;
        data["sqlContent"] = this.sqlContent;
        data["groupLevel"] = this.groupLevel;
        data["displayType"] = this.displayType;
        data["version"] = this.version;
        data["isDynamicColumn"] = this.isDynamicColumn;
        data["typeGetColumn"] = this.typeGetColumn;
        data["id"] = this.id;
        return data; 
    }

    clone(): SqlConfigDto {
        const json = this.toJSON();
        let result = new SqlConfigDto();
        result.init(json);
        return result;
    }
}

export interface ISqlConfigDto {
    code: string | undefined;
    name: string | undefined;
    isRawQuery: boolean;
    sqlContent: string | undefined;
    groupLevel: number | undefined;
    displayType: number | undefined;
    version: number | undefined;
    isDynamicColumn: boolean;
    typeGetColumn: number | undefined;
    id: number;
}

export class GetDataAndColumnConfig implements IGetDataAndColumnConfig {
    listVanBan: ListVanBan[] | undefined;
    listColumnConfig: SqlConfigDetailDto[] | undefined;

    constructor(data?: IGetDataAndColumnConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["listVanBan"] && data["listVanBan"].constructor === Array) {
                this.listVanBan = [];
                for (let item of data["listVanBan"])
                    this.listVanBan.push(ListVanBan.fromJS(item));
            }
            if (data["listColumnConfig"] && data["listColumnConfig"].constructor === Array) {
                this.listColumnConfig = [];
                for (let item of data["listColumnConfig"])
                    this.listColumnConfig.push(SqlConfigDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDataAndColumnConfig {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataAndColumnConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listVanBan && this.listVanBan.constructor === Array) {
            data["listVanBan"] = [];
            for (let item of this.listVanBan)
                data["listVanBan"].push(item.toJSON());
        }
        if (this.listColumnConfig && this.listColumnConfig.constructor === Array) {
            data["listColumnConfig"] = [];
            for (let item of this.listColumnConfig)
                data["listColumnConfig"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetDataAndColumnConfig {
        const json = this.toJSON();
        let result = new GetDataAndColumnConfig();
        result.init(json);
        return result;
    }
}

export interface IGetDataAndColumnConfig {
    listVanBan: ListVanBan[] | undefined;
    listColumnConfig: SqlConfigDetailDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ApplicationLanguageListDto {
        const json = this.toJSON();
        let result = new ApplicationLanguageListDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetLanguagesOutput {
        const json = this.toJSON();
        let result = new GetLanguagesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id: number | undefined;
    name: string | undefined;
    icon: string | undefined;
    isEnabled: boolean;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): ApplicationLanguageEditDto {
        const json = this.toJSON();
        let result = new ApplicationLanguageEditDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string | undefined;
    icon: string | undefined;
    isEnabled: boolean;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): ComboboxItemDto {
        const json = this.toJSON();
        let result = new ComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [];
                for (let item of data["languageNames"])
                    this.languageNames.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [];
                for (let item of data["flags"])
                    this.flags.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetLanguageForEditOutput {
        const json = this.toJSON();
        let result = new GetLanguageForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateLanguageInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name: string | undefined;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): SetDefaultLanguageInput {
        const json = this.toJSON();
        let result = new SetDefaultLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ISetDefaultLanguageInput {
    name: string | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }

    clone(): LanguageTextListDto {
        const json = this.toJSON();
        let result = new LanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLanguageTextListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName: string | undefined;
    sourceName: string | undefined;
    key: string | undefined;
    value: string | undefined;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdateLanguageTextInput {
        const json = this.toJSON();
        let result = new UpdateLanguageTextInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string | undefined;
    sourceName: string | undefined;
    key: string | undefined;
    value: string | undefined;
}

export class GetLichSuLamViecForViewDto implements IGetLichSuLamViecForViewDto {
    lichSuLamViec: LichSuLamViecDto;

    constructor(data?: IGetLichSuLamViecForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.lichSuLamViec = new LichSuLamViecDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.lichSuLamViec = data["lichSuLamViec"] ? LichSuLamViecDto.fromJS(data["lichSuLamViec"]) : new LichSuLamViecDto();
        }
    }

    static fromJS(data: any): GetLichSuLamViecForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLichSuLamViecForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lichSuLamViec"] = this.lichSuLamViec ? this.lichSuLamViec.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetLichSuLamViecForViewDto {
        const json = this.toJSON();
        let result = new GetLichSuLamViecForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetLichSuLamViecForViewDto {
    lichSuLamViec: LichSuLamViecDto;
}

export class PagedResultDtoOfGetLichSuLamViecForViewDto implements IPagedResultDtoOfGetLichSuLamViecForViewDto {
    totalCount: number;
    items: GetLichSuLamViecForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetLichSuLamViecForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetLichSuLamViecForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetLichSuLamViecForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetLichSuLamViecForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetLichSuLamViecForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetLichSuLamViecForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetLichSuLamViecForViewDto {
    totalCount: number;
    items: GetLichSuLamViecForViewDto[] | undefined;
}

export class CreateOrEditLichSuLamViecDto implements ICreateOrEditLichSuLamViecDto {
    ungVienId: number | undefined;
    phieuNghiPhepID: number | undefined;
    noiDung: string | undefined;
    chuDe: string | undefined;
    tepDinhKem: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditLichSuLamViecDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ungVienId = data["ungVienId"];
            this.phieuNghiPhepID = data["phieuNghiPhepID"];
            this.noiDung = data["noiDung"];
            this.chuDe = data["chuDe"];
            this.tepDinhKem = data["tepDinhKem"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditLichSuLamViecDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLichSuLamViecDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ungVienId"] = this.ungVienId;
        data["phieuNghiPhepID"] = this.phieuNghiPhepID;
        data["noiDung"] = this.noiDung;
        data["chuDe"] = this.chuDe;
        data["tepDinhKem"] = this.tepDinhKem;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditLichSuLamViecDto {
        const json = this.toJSON();
        let result = new CreateOrEditLichSuLamViecDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditLichSuLamViecDto {
    ungVienId: number | undefined;
    phieuNghiPhepID: number | undefined;
    noiDung: string | undefined;
    chuDe: string | undefined;
    tepDinhKem: string | undefined;
    id: number | undefined;
}

export class GetLichSuLamViecForEditOutput implements IGetLichSuLamViecForEditOutput {
    lichSuLamViec: CreateOrEditLichSuLamViecDto;

    constructor(data?: IGetLichSuLamViecForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.lichSuLamViec = new CreateOrEditLichSuLamViecDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.lichSuLamViec = data["lichSuLamViec"] ? CreateOrEditLichSuLamViecDto.fromJS(data["lichSuLamViec"]) : new CreateOrEditLichSuLamViecDto();
        }
    }

    static fromJS(data: any): GetLichSuLamViecForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLichSuLamViecForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lichSuLamViec"] = this.lichSuLamViec ? this.lichSuLamViec.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetLichSuLamViecForEditOutput {
        const json = this.toJSON();
        let result = new GetLichSuLamViecForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLichSuLamViecForEditOutput {
    lichSuLamViec: CreateOrEditLichSuLamViecDto;
}

export class GetLichSuUploadForViewDto implements IGetLichSuUploadForViewDto {
    lichSuUpload: LichSuUploadDto;

    constructor(data?: IGetLichSuUploadForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.lichSuUpload = new LichSuUploadDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.lichSuUpload = data["lichSuUpload"] ? LichSuUploadDto.fromJS(data["lichSuUpload"]) : new LichSuUploadDto();
        }
    }

    static fromJS(data: any): GetLichSuUploadForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLichSuUploadForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lichSuUpload"] = this.lichSuUpload ? this.lichSuUpload.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetLichSuUploadForViewDto {
        const json = this.toJSON();
        let result = new GetLichSuUploadForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetLichSuUploadForViewDto {
    lichSuUpload: LichSuUploadDto;
}

export class PagedResultDtoOfGetLichSuUploadForViewDto implements IPagedResultDtoOfGetLichSuUploadForViewDto {
    totalCount: number;
    items: GetLichSuUploadForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetLichSuUploadForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetLichSuUploadForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetLichSuUploadForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetLichSuUploadForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetLichSuUploadForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetLichSuUploadForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetLichSuUploadForViewDto {
    totalCount: number;
    items: GetLichSuUploadForViewDto[] | undefined;
}

export class CreateOrEditLichSuUploadDto implements ICreateOrEditLichSuUploadDto {
    tenFile: string | undefined;
    dungLuong: string | undefined;
    tieuDe: string | undefined;
    type: string | undefined;
    typeID: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditLichSuUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenFile = data["tenFile"];
            this.dungLuong = data["dungLuong"];
            this.tieuDe = data["tieuDe"];
            this.type = data["type"];
            this.typeID = data["typeID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditLichSuUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLichSuUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenFile"] = this.tenFile;
        data["dungLuong"] = this.dungLuong;
        data["tieuDe"] = this.tieuDe;
        data["type"] = this.type;
        data["typeID"] = this.typeID;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditLichSuUploadDto {
        const json = this.toJSON();
        let result = new CreateOrEditLichSuUploadDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditLichSuUploadDto {
    tenFile: string | undefined;
    dungLuong: string | undefined;
    tieuDe: string | undefined;
    type: string | undefined;
    typeID: string | undefined;
    id: number | undefined;
}

export class GetLichSuUploadForEditOutput implements IGetLichSuUploadForEditOutput {
    lichSuUpload: CreateOrEditLichSuUploadDto;

    constructor(data?: IGetLichSuUploadForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.lichSuUpload = new CreateOrEditLichSuUploadDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.lichSuUpload = data["lichSuUpload"] ? CreateOrEditLichSuUploadDto.fromJS(data["lichSuUpload"]) : new CreateOrEditLichSuUploadDto();
        }
    }

    static fromJS(data: any): GetLichSuUploadForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLichSuUploadForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lichSuUpload"] = this.lichSuUpload ? this.lichSuUpload.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetLichSuUploadForEditOutput {
        const json = this.toJSON();
        let result = new GetLichSuUploadForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLichSuUploadForEditOutput {
    lichSuUpload: CreateOrEditLichSuUploadDto;
}

export class GetDataAndColumnConfigMemorize implements IGetDataAndColumnConfigMemorize {
    listMemorize: ListMemorize[] | undefined;
    listColumnConfigMemorize: SqlConfigDetailDto[] | undefined;

    constructor(data?: IGetDataAndColumnConfigMemorize) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["listMemorize"] && data["listMemorize"].constructor === Array) {
                this.listMemorize = [];
                for (let item of data["listMemorize"])
                    this.listMemorize.push(ListMemorize.fromJS(item));
            }
            if (data["listColumnConfigMemorize"] && data["listColumnConfigMemorize"].constructor === Array) {
                this.listColumnConfigMemorize = [];
                for (let item of data["listColumnConfigMemorize"])
                    this.listColumnConfigMemorize.push(SqlConfigDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDataAndColumnConfigMemorize {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataAndColumnConfigMemorize();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listMemorize && this.listMemorize.constructor === Array) {
            data["listMemorize"] = [];
            for (let item of this.listMemorize)
                data["listMemorize"].push(item.toJSON());
        }
        if (this.listColumnConfigMemorize && this.listColumnConfigMemorize.constructor === Array) {
            data["listColumnConfigMemorize"] = [];
            for (let item of this.listColumnConfigMemorize)
                data["listColumnConfigMemorize"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetDataAndColumnConfigMemorize {
        const json = this.toJSON();
        let result = new GetDataAndColumnConfigMemorize();
        result.init(json);
        return result;
    }
}

export interface IGetDataAndColumnConfigMemorize {
    listMemorize: ListMemorize[] | undefined;
    listColumnConfigMemorize: SqlConfigDetailDto[] | undefined;
}

export class Memorize_KeywordsDto implements IMemorize_KeywordsDto {
    tenGoiNho: string | undefined;
    xuLyChinh: string | undefined;
    dongXuLy: string | undefined;
    deBiet: string | undefined;
    head_ID: number;
    full_Name: string | undefined;
    prefix: string | undefined;
    hire_Date: moment.Moment;
    keyWord: string | undefined;
    isActive: number;
    id: number;

    constructor(data?: IMemorize_KeywordsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenGoiNho = data["tenGoiNho"];
            this.xuLyChinh = data["xuLyChinh"];
            this.dongXuLy = data["dongXuLy"];
            this.deBiet = data["deBiet"];
            this.head_ID = data["head_ID"];
            this.full_Name = data["full_Name"];
            this.prefix = data["prefix"];
            this.hire_Date = data["hire_Date"] ? moment(data["hire_Date"].toString()) : <any>undefined;
            this.keyWord = data["keyWord"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Memorize_KeywordsDto {
        data = typeof data === 'object' ? data : {};
        let result = new Memorize_KeywordsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenGoiNho"] = this.tenGoiNho;
        data["xuLyChinh"] = this.xuLyChinh;
        data["dongXuLy"] = this.dongXuLy;
        data["deBiet"] = this.deBiet;
        data["head_ID"] = this.head_ID;
        data["full_Name"] = this.full_Name;
        data["prefix"] = this.prefix;
        data["hire_Date"] = this.hire_Date ? this.hire_Date.toISOString() : <any>undefined;
        data["keyWord"] = this.keyWord;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): Memorize_KeywordsDto {
        const json = this.toJSON();
        let result = new Memorize_KeywordsDto();
        result.init(json);
        return result;
    }
}

export interface IMemorize_KeywordsDto {
    tenGoiNho: string | undefined;
    xuLyChinh: string | undefined;
    dongXuLy: string | undefined;
    deBiet: string | undefined;
    head_ID: number;
    full_Name: string | undefined;
    prefix: string | undefined;
    hire_Date: moment.Moment;
    keyWord: string | undefined;
    isActive: number;
    id: number;
}

export class GetMemorize_KeywordsForViewDto implements IGetMemorize_KeywordsForViewDto {
    memorize_Keywords: Memorize_KeywordsDto;

    constructor(data?: IGetMemorize_KeywordsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.memorize_Keywords = new Memorize_KeywordsDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.memorize_Keywords = data["memorize_Keywords"] ? Memorize_KeywordsDto.fromJS(data["memorize_Keywords"]) : new Memorize_KeywordsDto();
        }
    }

    static fromJS(data: any): GetMemorize_KeywordsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemorize_KeywordsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memorize_Keywords"] = this.memorize_Keywords ? this.memorize_Keywords.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetMemorize_KeywordsForViewDto {
        const json = this.toJSON();
        let result = new GetMemorize_KeywordsForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetMemorize_KeywordsForViewDto {
    memorize_Keywords: Memorize_KeywordsDto;
}

export class PagedResultDtoOfGetMemorize_KeywordsForViewDto implements IPagedResultDtoOfGetMemorize_KeywordsForViewDto {
    totalCount: number;
    items: GetMemorize_KeywordsForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMemorize_KeywordsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetMemorize_KeywordsForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMemorize_KeywordsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMemorize_KeywordsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetMemorize_KeywordsForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetMemorize_KeywordsForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetMemorize_KeywordsForViewDto {
    totalCount: number;
    items: GetMemorize_KeywordsForViewDto[] | undefined;
}

export class CreateOrEditMemorize_KeywordsDto implements ICreateOrEditMemorize_KeywordsDto {
    tenGoiNho: string | undefined;
    xuLyChinh: string | undefined;
    dongXuLy: string | undefined;
    deBiet: string | undefined;
    head_ID: number;
    full_Name: string | undefined;
    prefix: string | undefined;
    hire_Date: moment.Moment;
    keyWord: string | undefined;
    isActive: number;
    id: number | undefined;

    constructor(data?: ICreateOrEditMemorize_KeywordsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenGoiNho = data["tenGoiNho"];
            this.xuLyChinh = data["xuLyChinh"];
            this.dongXuLy = data["dongXuLy"];
            this.deBiet = data["deBiet"];
            this.head_ID = data["head_ID"];
            this.full_Name = data["full_Name"];
            this.prefix = data["prefix"];
            this.hire_Date = data["hire_Date"] ? moment(data["hire_Date"].toString()) : <any>undefined;
            this.keyWord = data["keyWord"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMemorize_KeywordsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMemorize_KeywordsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenGoiNho"] = this.tenGoiNho;
        data["xuLyChinh"] = this.xuLyChinh;
        data["dongXuLy"] = this.dongXuLy;
        data["deBiet"] = this.deBiet;
        data["head_ID"] = this.head_ID;
        data["full_Name"] = this.full_Name;
        data["prefix"] = this.prefix;
        data["hire_Date"] = this.hire_Date ? this.hire_Date.toISOString() : <any>undefined;
        data["keyWord"] = this.keyWord;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditMemorize_KeywordsDto {
        const json = this.toJSON();
        let result = new CreateOrEditMemorize_KeywordsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditMemorize_KeywordsDto {
    tenGoiNho: string | undefined;
    xuLyChinh: string | undefined;
    dongXuLy: string | undefined;
    deBiet: string | undefined;
    head_ID: number;
    full_Name: string | undefined;
    prefix: string | undefined;
    hire_Date: moment.Moment;
    keyWord: string | undefined;
    isActive: number;
    id: number | undefined;
}

export class GetMemorize_KeywordsForEditOutput implements IGetMemorize_KeywordsForEditOutput {
    memorize_Keywords: CreateOrEditMemorize_KeywordsDto;

    constructor(data?: IGetMemorize_KeywordsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.memorize_Keywords = new CreateOrEditMemorize_KeywordsDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.memorize_Keywords = data["memorize_Keywords"] ? CreateOrEditMemorize_KeywordsDto.fromJS(data["memorize_Keywords"]) : new CreateOrEditMemorize_KeywordsDto();
        }
    }

    static fromJS(data: any): GetMemorize_KeywordsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemorize_KeywordsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memorize_Keywords"] = this.memorize_Keywords ? this.memorize_Keywords.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetMemorize_KeywordsForEditOutput {
        const json = this.toJSON();
        let result = new GetMemorize_KeywordsForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMemorize_KeywordsForEditOutput {
    memorize_Keywords: CreateOrEditMemorize_KeywordsDto;
}

export class MemorizeKeywordDto implements IMemorizeKeywordDto {
    keyWord: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IMemorizeKeywordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.keyWord = data["keyWord"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MemorizeKeywordDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemorizeKeywordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyWord"] = this.keyWord;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): MemorizeKeywordDto {
        const json = this.toJSON();
        let result = new MemorizeKeywordDto();
        result.init(json);
        return result;
    }
}

export interface IMemorizeKeywordDto {
    keyWord: string | undefined;
    isActive: boolean;
    id: number;
}

export class GetMemorizeKeywordForViewDto implements IGetMemorizeKeywordForViewDto {
    memorizeKeyword: MemorizeKeywordDto;

    constructor(data?: IGetMemorizeKeywordForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.memorizeKeyword = new MemorizeKeywordDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.memorizeKeyword = data["memorizeKeyword"] ? MemorizeKeywordDto.fromJS(data["memorizeKeyword"]) : new MemorizeKeywordDto();
        }
    }

    static fromJS(data: any): GetMemorizeKeywordForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemorizeKeywordForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memorizeKeyword"] = this.memorizeKeyword ? this.memorizeKeyword.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetMemorizeKeywordForViewDto {
        const json = this.toJSON();
        let result = new GetMemorizeKeywordForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetMemorizeKeywordForViewDto {
    memorizeKeyword: MemorizeKeywordDto;
}

export class PagedResultDtoOfGetMemorizeKeywordForViewDto implements IPagedResultDtoOfGetMemorizeKeywordForViewDto {
    totalCount: number;
    items: GetMemorizeKeywordForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMemorizeKeywordForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetMemorizeKeywordForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMemorizeKeywordForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMemorizeKeywordForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetMemorizeKeywordForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetMemorizeKeywordForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetMemorizeKeywordForViewDto {
    totalCount: number;
    items: GetMemorizeKeywordForViewDto[] | undefined;
}

export class CreateOrEditMemorizeKeywordDto implements ICreateOrEditMemorizeKeywordDto {
    keyWord: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditMemorizeKeywordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.keyWord = data["keyWord"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMemorizeKeywordDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMemorizeKeywordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyWord"] = this.keyWord;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditMemorizeKeywordDto {
        const json = this.toJSON();
        let result = new CreateOrEditMemorizeKeywordDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditMemorizeKeywordDto {
    keyWord: string | undefined;
    id: number | undefined;
}

export class GetMemorizeKeywordForEditOutput implements IGetMemorizeKeywordForEditOutput {
    memorizeKeyword: CreateOrEditMemorizeKeywordDto;

    constructor(data?: IGetMemorizeKeywordForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.memorizeKeyword = new CreateOrEditMemorizeKeywordDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.memorizeKeyword = data["memorizeKeyword"] ? CreateOrEditMemorizeKeywordDto.fromJS(data["memorizeKeyword"]) : new CreateOrEditMemorizeKeywordDto();
        }
    }

    static fromJS(data: any): GetMemorizeKeywordForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemorizeKeywordForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memorizeKeyword"] = this.memorizeKeyword ? this.memorizeKeyword.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetMemorizeKeywordForEditOutput {
        const json = this.toJSON();
        let result = new GetMemorizeKeywordForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMemorizeKeywordForEditOutput {
    memorizeKeyword: CreateOrEditMemorizeKeywordDto;
}

export class MenuDto implements IMenuDto {
    name: string | undefined;
    title: string | undefined;
    icon: string | undefined;
    description: string | undefined;
    parent: number | undefined;
    link: string | undefined;
    creationTime: moment.Moment;
    lastModificationTime: moment.Moment | undefined;
    isDeleted: boolean;
    deletionTime: moment.Moment | undefined;
    index: number;
    requiredPermissionName: string | undefined;
    dept: number;
    num: string | undefined;
    children: MenuDto[] | undefined;
    numBeforeComma: number;
    numAfterComma: number;
    id: number;

    constructor(data?: IMenuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.title = data["title"];
            this.icon = data["icon"];
            this.description = data["description"];
            this.parent = data["parent"];
            this.link = data["link"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.index = data["index"];
            this.requiredPermissionName = data["requiredPermissionName"];
            this.dept = data["dept"];
            this.num = data["num"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(MenuDto.fromJS(item));
            }
            this.numBeforeComma = data["numBeforeComma"];
            this.numAfterComma = data["numAfterComma"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MenuDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["title"] = this.title;
        data["icon"] = this.icon;
        data["description"] = this.description;
        data["parent"] = this.parent;
        data["link"] = this.link;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["index"] = this.index;
        data["requiredPermissionName"] = this.requiredPermissionName;
        data["dept"] = this.dept;
        data["num"] = this.num;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["numBeforeComma"] = this.numBeforeComma;
        data["numAfterComma"] = this.numAfterComma;
        data["id"] = this.id;
        return data; 
    }

    clone(): MenuDto {
        const json = this.toJSON();
        let result = new MenuDto();
        result.init(json);
        return result;
    }
}

export interface IMenuDto {
    name: string | undefined;
    title: string | undefined;
    icon: string | undefined;
    description: string | undefined;
    parent: number | undefined;
    link: string | undefined;
    creationTime: moment.Moment;
    lastModificationTime: moment.Moment | undefined;
    isDeleted: boolean;
    deletionTime: moment.Moment | undefined;
    index: number;
    requiredPermissionName: string | undefined;
    dept: number;
    num: string | undefined;
    children: MenuDto[] | undefined;
    numBeforeComma: number;
    numAfterComma: number;
    id: number;
}

export class GetMenuForViewDto implements IGetMenuForViewDto {
    menu: MenuDto;

    constructor(data?: IGetMenuForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.menu = new MenuDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.menu = data["menu"] ? MenuDto.fromJS(data["menu"]) : new MenuDto();
        }
    }

    static fromJS(data: any): GetMenuForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenuForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetMenuForViewDto {
        const json = this.toJSON();
        let result = new GetMenuForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetMenuForViewDto {
    menu: MenuDto;
}

export class PagedResultDtoOfGetMenuForViewDto implements IPagedResultDtoOfGetMenuForViewDto {
    totalCount: number;
    items: GetMenuForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMenuForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetMenuForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMenuForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMenuForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetMenuForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetMenuForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetMenuForViewDto {
    totalCount: number;
    items: GetMenuForViewDto[] | undefined;
}

export class CreateOrEditMenuDto implements ICreateOrEditMenuDto {
    name: string | undefined;
    title: string | undefined;
    icon: string | undefined;
    description: string | undefined;
    parent: number | undefined;
    link: string | undefined;
    creationTime: moment.Moment;
    lastModificationTime: moment.Moment | undefined;
    isDeleted: boolean;
    deletionTime: moment.Moment | undefined;
    index: number;
    requiredPermissionName: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditMenuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.title = data["title"];
            this.icon = data["icon"];
            this.description = data["description"];
            this.parent = data["parent"];
            this.link = data["link"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.index = data["index"];
            this.requiredPermissionName = data["requiredPermissionName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMenuDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMenuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["title"] = this.title;
        data["icon"] = this.icon;
        data["description"] = this.description;
        data["parent"] = this.parent;
        data["link"] = this.link;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["index"] = this.index;
        data["requiredPermissionName"] = this.requiredPermissionName;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditMenuDto {
        const json = this.toJSON();
        let result = new CreateOrEditMenuDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditMenuDto {
    name: string | undefined;
    title: string | undefined;
    icon: string | undefined;
    description: string | undefined;
    parent: number | undefined;
    link: string | undefined;
    creationTime: moment.Moment;
    lastModificationTime: moment.Moment | undefined;
    isDeleted: boolean;
    deletionTime: moment.Moment | undefined;
    index: number;
    requiredPermissionName: string | undefined;
    id: number | undefined;
}

export class GetMenuForEditOutput implements IGetMenuForEditOutput {
    menu: CreateOrEditMenuDto;

    constructor(data?: IGetMenuForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.menu = new CreateOrEditMenuDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.menu = data["menu"] ? CreateOrEditMenuDto.fromJS(data["menu"]) : new CreateOrEditMenuDto();
        }
    }

    static fromJS(data: any): GetMenuForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenuForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetMenuForEditOutput {
        const json = this.toJSON();
        let result = new GetMenuForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMenuForEditOutput {
    menu: CreateOrEditMenuDto;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetMenusForViewDto implements IGetMenusForViewDto {
    menus: MenuDto;

    constructor(data?: IGetMenusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.menus = new MenuDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.menus = data["menus"] ? MenuDto.fromJS(data["menus"]) : new MenuDto();
        }
    }

    static fromJS(data: any): GetMenusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menus"] = this.menus ? this.menus.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetMenusForViewDto {
        const json = this.toJSON();
        let result = new GetMenusForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetMenusForViewDto {
    menus: MenuDto;
}

export class PagedResultDtoOfGetMenusForViewDto implements IPagedResultDtoOfGetMenusForViewDto {
    totalCount: number;
    items: GetMenusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMenusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetMenusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMenusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMenusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetMenusForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetMenusForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetMenusForViewDto {
    totalCount: number;
    items: GetMenusForViewDto[] | undefined;
}

export class IdNameDto implements IIdNameDto {
    id: number;
    name: string | undefined;

    constructor(data?: IIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): IdNameDto {
        const json = this.toJSON();
        let result = new IdNameDto();
        result.init(json);
        return result;
    }
}

export interface IIdNameDto {
    id: number;
    name: string | undefined;
}

export class PagedResultDtoOfMenuDto implements IPagedResultDtoOfMenuDto {
    totalCount: number;
    items: MenuDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMenuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(MenuDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMenuDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMenuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfMenuDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfMenuDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfMenuDto {
    totalCount: number;
    items: MenuDto[] | undefined;
}

export class GetNoiDaoTaoForViewDto implements IGetNoiDaoTaoForViewDto {
    noiDaoTao: NoiDaoTaoDto;

    constructor(data?: IGetNoiDaoTaoForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.noiDaoTao = new NoiDaoTaoDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.noiDaoTao = data["noiDaoTao"] ? NoiDaoTaoDto.fromJS(data["noiDaoTao"]) : new NoiDaoTaoDto();
        }
    }

    static fromJS(data: any): GetNoiDaoTaoForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetNoiDaoTaoForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noiDaoTao"] = this.noiDaoTao ? this.noiDaoTao.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetNoiDaoTaoForViewDto {
        const json = this.toJSON();
        let result = new GetNoiDaoTaoForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetNoiDaoTaoForViewDto {
    noiDaoTao: NoiDaoTaoDto;
}

export class PagedResultDtoOfGetNoiDaoTaoForViewDto implements IPagedResultDtoOfGetNoiDaoTaoForViewDto {
    totalCount: number;
    items: GetNoiDaoTaoForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetNoiDaoTaoForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetNoiDaoTaoForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetNoiDaoTaoForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetNoiDaoTaoForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetNoiDaoTaoForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetNoiDaoTaoForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetNoiDaoTaoForViewDto {
    totalCount: number;
    items: GetNoiDaoTaoForViewDto[] | undefined;
}

export class CreateOrEditNoiDaoTaoDto implements ICreateOrEditNoiDaoTaoDto {
    tenNoiDaoTao: string | undefined;
    maNoiDaoTao: string | undefined;
    diaChi: string | undefined;
    khuVuc: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditNoiDaoTaoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenNoiDaoTao = data["tenNoiDaoTao"];
            this.maNoiDaoTao = data["maNoiDaoTao"];
            this.diaChi = data["diaChi"];
            this.khuVuc = data["khuVuc"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditNoiDaoTaoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditNoiDaoTaoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenNoiDaoTao"] = this.tenNoiDaoTao;
        data["maNoiDaoTao"] = this.maNoiDaoTao;
        data["diaChi"] = this.diaChi;
        data["khuVuc"] = this.khuVuc;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditNoiDaoTaoDto {
        const json = this.toJSON();
        let result = new CreateOrEditNoiDaoTaoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditNoiDaoTaoDto {
    tenNoiDaoTao: string | undefined;
    maNoiDaoTao: string | undefined;
    diaChi: string | undefined;
    khuVuc: string | undefined;
    id: number | undefined;
}

export class GetNoiDaoTaoForEditOutput implements IGetNoiDaoTaoForEditOutput {
    noiDaoTao: CreateOrEditNoiDaoTaoDto;

    constructor(data?: IGetNoiDaoTaoForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.noiDaoTao = new CreateOrEditNoiDaoTaoDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.noiDaoTao = data["noiDaoTao"] ? CreateOrEditNoiDaoTaoDto.fromJS(data["noiDaoTao"]) : new CreateOrEditNoiDaoTaoDto();
        }
    }

    static fromJS(data: any): GetNoiDaoTaoForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNoiDaoTaoForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noiDaoTao"] = this.noiDaoTao ? this.noiDaoTao.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetNoiDaoTaoForEditOutput {
        const json = this.toJSON();
        let result = new GetNoiDaoTaoForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNoiDaoTaoForEditOutput {
    noiDaoTao: CreateOrEditNoiDaoTaoDto;
}

export enum UserNotificationState {
    Unread = 0, 
    Read = 1, 
}

export class NotificationData implements INotificationData {
    type: string | undefined;
    properties: { [key: string] : Anonymous3; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["properties"]) {
                this.properties = {};
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key] ? Anonymous3.fromJS(data["properties"][key]) : new Anonymous3();
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }

    clone(): NotificationData {
        const json = this.toJSON();
        let result = new NotificationData();
        result.init(json);
        return result;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : Anonymous3; } | undefined;
}

export enum NotificationSeverity {
    Info = 0, 
    Success = 1, 
    Warn = 2, 
    Error = 3, 
    Fatal = 4, 
}

export class TenantNotification implements ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: EntityId | undefined;
    severity: NotificationSeverity;
    creationTime: moment.Moment;
    id: string;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = new NotificationData();
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : new NotificationData();
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"] ? EntityId.fromJS(data["entityId"]) : <any>undefined;
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId ? this.entityId.toJSON() : <any>undefined;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantNotification {
        const json = this.toJSON();
        let result = new TenantNotification();
        result.init(json);
        return result;
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: EntityId | undefined;
    severity: NotificationSeverity;
    creationTime: moment.Moment;
    id: string;
}

export class UserNotification implements IUserNotification {
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    id: string;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.notification = new TenantNotification();
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : new TenantNotification();
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserNotification {
        const json = this.toJSON();
        let result = new UserNotification();
        result.init(json);
        return result;
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    id: string;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount: number;
    totalCount: number;
    items: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetNotificationsOutput {
        const json = this.toJSON();
        let result = new GetNotificationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number;
    totalCount: number;
    items: UserNotification[] | undefined;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id: string;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfGuid {
        const json = this.toJSON();
        let result = new EntityDtoOfGuid();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfGuid {
    id: string;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string | undefined;
    isSubscribed: boolean;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone(): NotificationSubscriptionWithDisplayNameDto {
        const json = this.toJSON();
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string | undefined;
    isSubscribed: boolean;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetNotificationSettingsOutput {
        const json = this.toJSON();
        let result = new GetNotificationSettingsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name: string | undefined;
    isSubscribed: boolean;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone(): NotificationSubscriptionDto {
        const json = this.toJSON();
        let result = new NotificationSubscriptionDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionDto {
    name: string | undefined;
    isSubscribed: boolean;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateNotificationSettingsInput {
        const json = this.toJSON();
        let result = new UpdateNotificationSettingsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment;
    id: number;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment;
    id: number;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfOrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment;
    id: number;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.name = data["name"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitRoleListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment;
    id: number;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number;
    items: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfOrganizationUnitRoleListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string | undefined;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): CreateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new CreateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string | undefined;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id: number;
    displayName: string | undefined;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): UpdateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UpdateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string | undefined;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }

    clone(): MoveOrganizationUnitInput {
        const json = this.toJSON();
        let result = new MoveOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): UsersToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UsersToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["roleIds"] && data["roleIds"].constructor === Array) {
                this.roleIds = [];
                for (let item of data["roleIds"])
                    this.roleIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.roleIds && this.roleIds.constructor === Array) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): RolesToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new RolesToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }

    clone(): FindOrganizationUnitUsersInput {
        const json = this.toJSON();
        let result = new FindOrganizationUnitUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }

    clone(): FindOrganizationUnitRolesInput {
        const json = this.toJSON();
        let result = new FindOrganizationUnitRolesInput();
        result.init(json);
        return result;
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean;
    additionalData: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.dailyPrice = data["dailyPrice"];
            this.weeklyPrice = data["weeklyPrice"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }

    clone(): EditionSelectDto {
        const json = this.toJSON();
        let result = new EditionSelectDto();
        result.init(json);
        return result;
    }
}

export interface IEditionSelectDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean;
    additionalData: AdditionalData | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition: EditionSelectDto;
    additionalPrice: number;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionSelectDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : new EditionSelectDto();
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }

    clone(): PaymentInfoDto {
        const json = this.toJSON();
        let result = new PaymentInfoDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto;
    additionalPrice: number;
}

export enum EditionPaymentType {
    NewRegistration = 0, 
    BuyNow = 1, 
    Upgrade = 2, 
    Extend = 3, 
}

export enum PaymentPeriodType {
    Daily = 1, 
    Weekly = 7, 
    Monthly = 30, 
    Annual = 365, 
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1, 
    Stripe = 2, 
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId: number;
    editionPaymentType: EditionPaymentType;
    paymentPeriodType: PaymentPeriodType;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled: boolean;
    successUrl: string | undefined;
    errorUrl: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = data["recurringPaymentEnabled"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data; 
    }

    clone(): CreatePaymentDto {
        const json = this.toJSON();
        let result = new CreatePaymentDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePaymentDto {
    editionId: number;
    editionPaymentType: EditionPaymentType;
    paymentPeriodType: PaymentPeriodType;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled: boolean;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.gateway = data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data; 
    }

    clone(): CancelPaymentDto {
        const json = this.toJSON();
        let result = new CancelPaymentDto();
        result.init(json);
        return result;
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number;
    editionId: number;
    dayCount: number;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): SubscriptionPaymentListDto {
        const json = this.toJSON();
        let result = new SubscriptionPaymentListDto();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number;
    editionId: number;
    dayCount: number;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number;
    items: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfSubscriptionPaymentListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType;
    supportsRecurringPayments: boolean;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gatewayType = data["gatewayType"];
            this.supportsRecurringPayments = data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data; 
    }

    clone(): PaymentGatewayModel {
        const json = this.toJSON();
        let result = new PaymentGatewayModel();
        result.init(json);
        return result;
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType;
    supportsRecurringPayments: boolean;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1, 
    Paid = 2, 
    Failed = 3, 
    Cancelled = 4, 
    Completed = 5, 
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
    amount: number;
    editionId: number;
    tenantId: number;
    dayCount: number;
    paymentPeriodType: PaymentPeriodType;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number;
    status: SubscriptionPaymentStatus;
    isRecurring: boolean;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    id: number;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.tenantId = data["tenantId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.status = data["status"];
            this.isRecurring = data["isRecurring"];
            this.externalPaymentId = data["externalPaymentId"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["id"] = this.id;
        return data; 
    }

    clone(): SubscriptionPaymentDto {
        const json = this.toJSON();
        let result = new SubscriptionPaymentDto();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
    amount: number;
    editionId: number;
    tenantId: number;
    dayCount: number;
    paymentPeriodType: PaymentPeriodType;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number;
    status: SubscriptionPaymentStatus;
    isRecurring: boolean;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    id: number;
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.demoUsername = data["demoUsername"];
            this.demoPassword = data["demoPassword"];
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        return data; 
    }

    clone(): PayPalConfigurationDto {
        const json = this.toJSON();
        let result = new PayPalConfigurationDto();
        result.init(json);
        return result;
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }

    clone(): FlatPermissionWithLevelDto {
        const json = this.toJSON();
        let result = new FlatPermissionWithLevelDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfFlatPermissionWithLevelDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class PriorityDto implements IPriorityDto {
    key: string | undefined;
    value: number;
    id: number;

    constructor(data?: IPriorityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PriorityDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["id"] = this.id;
        return data; 
    }

    clone(): PriorityDto {
        const json = this.toJSON();
        let result = new PriorityDto();
        result.init(json);
        return result;
    }
}

export interface IPriorityDto {
    key: string | undefined;
    value: number;
    id: number;
}

export class GetPriorityForViewDto implements IGetPriorityForViewDto {
    priority: PriorityDto;

    constructor(data?: IGetPriorityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.priority = new PriorityDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.priority = data["priority"] ? PriorityDto.fromJS(data["priority"]) : new PriorityDto();
        }
    }

    static fromJS(data: any): GetPriorityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPriorityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priority"] = this.priority ? this.priority.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPriorityForViewDto {
        const json = this.toJSON();
        let result = new GetPriorityForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetPriorityForViewDto {
    priority: PriorityDto;
}

export class PagedResultDtoOfGetPriorityForViewDto implements IPagedResultDtoOfGetPriorityForViewDto {
    totalCount: number;
    items: GetPriorityForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPriorityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetPriorityForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPriorityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPriorityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetPriorityForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetPriorityForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetPriorityForViewDto {
    totalCount: number;
    items: GetPriorityForViewDto[] | undefined;
}

export class CreateOrEditPriorityDto implements ICreateOrEditPriorityDto {
    key: string | undefined;
    value: number;
    id: number | undefined;

    constructor(data?: ICreateOrEditPriorityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditPriorityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditPriorityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditPriorityDto {
        const json = this.toJSON();
        let result = new CreateOrEditPriorityDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditPriorityDto {
    key: string | undefined;
    value: number;
    id: number | undefined;
}

export class GetPriorityForEditOutput implements IGetPriorityForEditOutput {
    priority: CreateOrEditPriorityDto;

    constructor(data?: IGetPriorityForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.priority = new CreateOrEditPriorityDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.priority = data["priority"] ? CreateOrEditPriorityDto.fromJS(data["priority"]) : new CreateOrEditPriorityDto();
        }
    }

    static fromJS(data: any): GetPriorityForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPriorityForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priority"] = this.priority ? this.priority.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPriorityForEditOutput {
        const json = this.toJSON();
        let result = new GetPriorityForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPriorityForEditOutput {
    priority: CreateOrEditPriorityDto;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }

    clone(): CurrentUserProfileEditDto {
        const json = this.toJSON();
        let result = new CurrentUserProfileEditDto();
        result.init(json);
        return result;
    }
}

export interface ICurrentUserProfileEditDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }

    clone(): UpdateGoogleAuthenticatorKeyOutput {
        const json = this.toJSON();
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(json);
        return result;
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class SendVerificationSmsInputDto implements ISendVerificationSmsInputDto {
    phoneNumber: string | undefined;

    constructor(data?: ISendVerificationSmsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendVerificationSmsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationSmsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }

    clone(): SendVerificationSmsInputDto {
        const json = this.toJSON();
        let result = new SendVerificationSmsInputDto();
        result.init(json);
        return result;
    }
}

export interface ISendVerificationSmsInputDto {
    phoneNumber: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }

    clone(): VerifySmsCodeInputDto {
        const json = this.toJSON();
        let result = new VerifySmsCodeInputDto();
        result.init(json);
        return result;
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword: string | undefined;
    newPassword: string | undefined;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordInput {
        const json = this.toJSON();
        let result = new ChangePasswordInput();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordInput {
    currentPassword: string | undefined;
    newPassword: string | undefined;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken: string | undefined;
    x: number;
    y: number;
    width: number;
    height: number;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }

    clone(): UpdateProfilePictureInput {
        const json = this.toJSON();
        let result = new UpdateProfilePictureInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string | undefined;
    x: number;
    y: number;
    width: number;
    height: number;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.setting = new PasswordComplexitySetting();
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : new PasswordComplexitySetting();
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPasswordComplexitySettingOutput {
        const json = this.toJSON();
        let result = new GetPasswordComplexitySettingOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }

    clone(): GetProfilePictureOutput {
        const json = this.toJSON();
        let result = new GetProfilePictureOutput();
        result.init(json);
        return result;
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string | undefined;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string | undefined;
}

export class PromulgatedDto implements IPromulgatedDto {
    name: string | undefined;
    displayName: string | undefined;
    representative: string | undefined;
    leader: string | undefined;
    position: string | undefined;
    id: number;

    constructor(data?: IPromulgatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.representative = data["representative"];
            this.leader = data["leader"];
            this.position = data["position"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PromulgatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PromulgatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["representative"] = this.representative;
        data["leader"] = this.leader;
        data["position"] = this.position;
        data["id"] = this.id;
        return data; 
    }

    clone(): PromulgatedDto {
        const json = this.toJSON();
        let result = new PromulgatedDto();
        result.init(json);
        return result;
    }
}

export interface IPromulgatedDto {
    name: string | undefined;
    displayName: string | undefined;
    representative: string | undefined;
    leader: string | undefined;
    position: string | undefined;
    id: number;
}

export class GetPromulgatedForViewDto implements IGetPromulgatedForViewDto {
    promulgated: PromulgatedDto;

    constructor(data?: IGetPromulgatedForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.promulgated = new PromulgatedDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.promulgated = data["promulgated"] ? PromulgatedDto.fromJS(data["promulgated"]) : new PromulgatedDto();
        }
    }

    static fromJS(data: any): GetPromulgatedForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPromulgatedForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["promulgated"] = this.promulgated ? this.promulgated.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPromulgatedForViewDto {
        const json = this.toJSON();
        let result = new GetPromulgatedForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetPromulgatedForViewDto {
    promulgated: PromulgatedDto;
}

export class PagedResultDtoOfGetPromulgatedForViewDto implements IPagedResultDtoOfGetPromulgatedForViewDto {
    totalCount: number;
    items: GetPromulgatedForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPromulgatedForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetPromulgatedForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPromulgatedForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPromulgatedForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetPromulgatedForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetPromulgatedForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetPromulgatedForViewDto {
    totalCount: number;
    items: GetPromulgatedForViewDto[] | undefined;
}

export class CreateOrEditPromulgatedDto implements ICreateOrEditPromulgatedDto {
    name: string | undefined;
    displayName: string | undefined;
    representative: string | undefined;
    leader: string | undefined;
    position: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditPromulgatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.representative = data["representative"];
            this.leader = data["leader"];
            this.position = data["position"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditPromulgatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditPromulgatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["representative"] = this.representative;
        data["leader"] = this.leader;
        data["position"] = this.position;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditPromulgatedDto {
        const json = this.toJSON();
        let result = new CreateOrEditPromulgatedDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditPromulgatedDto {
    name: string | undefined;
    displayName: string | undefined;
    representative: string | undefined;
    leader: string | undefined;
    position: string | undefined;
    id: number | undefined;
}

export class GetPromulgatedForEditOutput implements IGetPromulgatedForEditOutput {
    promulgated: CreateOrEditPromulgatedDto;

    constructor(data?: IGetPromulgatedForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.promulgated = new CreateOrEditPromulgatedDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.promulgated = data["promulgated"] ? CreateOrEditPromulgatedDto.fromJS(data["promulgated"]) : new CreateOrEditPromulgatedDto();
        }
    }

    static fromJS(data: any): GetPromulgatedForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPromulgatedForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["promulgated"] = this.promulgated ? this.promulgated.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPromulgatedForEditOutput {
        const json = this.toJSON();
        let result = new GetPromulgatedForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPromulgatedForEditOutput {
    promulgated: CreateOrEditPromulgatedDto;
}

export class GetOrganizationUnitForEditOutput implements IGetOrganizationUnitForEditOutput {
    organizationUnit: OrganizationUnitDto;

    constructor(data?: IGetOrganizationUnitForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.organizationUnit = new OrganizationUnitDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnit = data["organizationUnit"] ? OrganizationUnitDto.fromJS(data["organizationUnit"]) : new OrganizationUnitDto();
        }
    }

    static fromJS(data: any): GetOrganizationUnitForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationUnitForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnit"] = this.organizationUnit ? this.organizationUnit.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetOrganizationUnitForEditOutput {
        const json = this.toJSON();
        let result = new GetOrganizationUnitForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetOrganizationUnitForEditOutput {
    organizationUnit: OrganizationUnitDto;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }

    clone(): UserListRoleDto {
        const json = this.toJSON();
        let result = new UserListRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;
}

export class UserListDto implements IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserListDto {
        const json = this.toJSON();
        let result = new UserListDto();
        result.init(json);
        return result;
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class QuanLyNghiPhepDto implements IQuanLyNghiPhepDto {
    tenNhanVien: string | undefined;
    donViCongTacID: number | undefined;
    maNV: string | undefined;
    nghiPhep: boolean;
    congTac: boolean;
    ngayBatDau: moment.Moment;
    ngayKetThuc: moment.Moment;
    lyDo: string | undefined;
    quanLyTrucTiepID: string | undefined;
    truongBoPhanID: string | undefined;
    tepDinhKem: string | undefined;
    tenCTY: string | undefined;
    nguoiDuyetID: number | undefined;
    ngayDuyet: moment.Moment;
    trangThaiID: number | undefined;
    createTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isCheckTime: boolean;
    id: number;

    constructor(data?: IQuanLyNghiPhepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenNhanVien = data["tenNhanVien"];
            this.donViCongTacID = data["donViCongTacID"];
            this.maNV = data["maNV"];
            this.nghiPhep = data["nghiPhep"];
            this.congTac = data["congTac"];
            this.ngayBatDau = data["ngayBatDau"] ? moment(data["ngayBatDau"].toString()) : <any>undefined;
            this.ngayKetThuc = data["ngayKetThuc"] ? moment(data["ngayKetThuc"].toString()) : <any>undefined;
            this.lyDo = data["lyDo"];
            this.quanLyTrucTiepID = data["quanLyTrucTiepID"];
            this.truongBoPhanID = data["truongBoPhanID"];
            this.tepDinhKem = data["tepDinhKem"];
            this.tenCTY = data["tenCTY"];
            this.nguoiDuyetID = data["nguoiDuyetID"];
            this.ngayDuyet = data["ngayDuyet"] ? moment(data["ngayDuyet"].toString()) : <any>undefined;
            this.trangThaiID = data["trangThaiID"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isCheckTime = data["isCheckTime"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuanLyNghiPhepDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuanLyNghiPhepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenNhanVien"] = this.tenNhanVien;
        data["donViCongTacID"] = this.donViCongTacID;
        data["maNV"] = this.maNV;
        data["nghiPhep"] = this.nghiPhep;
        data["congTac"] = this.congTac;
        data["ngayBatDau"] = this.ngayBatDau ? this.ngayBatDau.toISOString() : <any>undefined;
        data["ngayKetThuc"] = this.ngayKetThuc ? this.ngayKetThuc.toISOString() : <any>undefined;
        data["lyDo"] = this.lyDo;
        data["quanLyTrucTiepID"] = this.quanLyTrucTiepID;
        data["truongBoPhanID"] = this.truongBoPhanID;
        data["tepDinhKem"] = this.tepDinhKem;
        data["tenCTY"] = this.tenCTY;
        data["nguoiDuyetID"] = this.nguoiDuyetID;
        data["ngayDuyet"] = this.ngayDuyet ? this.ngayDuyet.toISOString() : <any>undefined;
        data["trangThaiID"] = this.trangThaiID;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isCheckTime"] = this.isCheckTime;
        data["id"] = this.id;
        return data; 
    }

    clone(): QuanLyNghiPhepDto {
        const json = this.toJSON();
        let result = new QuanLyNghiPhepDto();
        result.init(json);
        return result;
    }
}

export interface IQuanLyNghiPhepDto {
    tenNhanVien: string | undefined;
    donViCongTacID: number | undefined;
    maNV: string | undefined;
    nghiPhep: boolean;
    congTac: boolean;
    ngayBatDau: moment.Moment;
    ngayKetThuc: moment.Moment;
    lyDo: string | undefined;
    quanLyTrucTiepID: string | undefined;
    truongBoPhanID: string | undefined;
    tepDinhKem: string | undefined;
    tenCTY: string | undefined;
    nguoiDuyetID: number | undefined;
    ngayDuyet: moment.Moment;
    trangThaiID: number | undefined;
    createTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isCheckTime: boolean;
    id: number;
}

export class GetQuanLyNghiPhepForViewDto implements IGetQuanLyNghiPhepForViewDto {
    quanLyNghiPhep: QuanLyNghiPhepDto;
    donViCongTacValue: string | undefined;
    quanLyTrucTiepValue: string | undefined;
    truongBoPhanValue: string | undefined;
    trangThaiValue: string | undefined;

    constructor(data?: IGetQuanLyNghiPhepForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.quanLyNghiPhep = new QuanLyNghiPhepDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.quanLyNghiPhep = data["quanLyNghiPhep"] ? QuanLyNghiPhepDto.fromJS(data["quanLyNghiPhep"]) : new QuanLyNghiPhepDto();
            this.donViCongTacValue = data["donViCongTacValue"];
            this.quanLyTrucTiepValue = data["quanLyTrucTiepValue"];
            this.truongBoPhanValue = data["truongBoPhanValue"];
            this.trangThaiValue = data["trangThaiValue"];
        }
    }

    static fromJS(data: any): GetQuanLyNghiPhepForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuanLyNghiPhepForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quanLyNghiPhep"] = this.quanLyNghiPhep ? this.quanLyNghiPhep.toJSON() : <any>undefined;
        data["donViCongTacValue"] = this.donViCongTacValue;
        data["quanLyTrucTiepValue"] = this.quanLyTrucTiepValue;
        data["truongBoPhanValue"] = this.truongBoPhanValue;
        data["trangThaiValue"] = this.trangThaiValue;
        return data; 
    }

    clone(): GetQuanLyNghiPhepForViewDto {
        const json = this.toJSON();
        let result = new GetQuanLyNghiPhepForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetQuanLyNghiPhepForViewDto {
    quanLyNghiPhep: QuanLyNghiPhepDto;
    donViCongTacValue: string | undefined;
    quanLyTrucTiepValue: string | undefined;
    truongBoPhanValue: string | undefined;
    trangThaiValue: string | undefined;
}

export class PagedResultDtoOfGetQuanLyNghiPhepForViewDto implements IPagedResultDtoOfGetQuanLyNghiPhepForViewDto {
    totalCount: number;
    items: GetQuanLyNghiPhepForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetQuanLyNghiPhepForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetQuanLyNghiPhepForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetQuanLyNghiPhepForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetQuanLyNghiPhepForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetQuanLyNghiPhepForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetQuanLyNghiPhepForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetQuanLyNghiPhepForViewDto {
    totalCount: number;
    items: GetQuanLyNghiPhepForViewDto[] | undefined;
}

export class CreateOrEditQuanLyNghiPhepDto implements ICreateOrEditQuanLyNghiPhepDto {
    tenNhanVien: string | undefined;
    donViCongTacID: number | undefined;
    maNV: string | undefined;
    nghiPhep: boolean;
    congTac: boolean;
    tangCa: boolean;
    ngayBatDau: moment.Moment;
    ngayKetThuc: moment.Moment;
    lyDo: string | undefined;
    quanLyTrucTiepID: string | undefined;
    truongBoPhanID: string | undefined;
    tepDinhKem: string | undefined;
    tenCTY: string | undefined;
    nguoiDuyetID: number | undefined;
    ngayDuyet: moment.Moment;
    trangThaiID: number | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditQuanLyNghiPhepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenNhanVien = data["tenNhanVien"];
            this.donViCongTacID = data["donViCongTacID"];
            this.maNV = data["maNV"];
            this.nghiPhep = data["nghiPhep"];
            this.congTac = data["congTac"];
            this.tangCa = data["tangCa"];
            this.ngayBatDau = data["ngayBatDau"] ? moment(data["ngayBatDau"].toString()) : <any>undefined;
            this.ngayKetThuc = data["ngayKetThuc"] ? moment(data["ngayKetThuc"].toString()) : <any>undefined;
            this.lyDo = data["lyDo"];
            this.quanLyTrucTiepID = data["quanLyTrucTiepID"];
            this.truongBoPhanID = data["truongBoPhanID"];
            this.tepDinhKem = data["tepDinhKem"];
            this.tenCTY = data["tenCTY"];
            this.nguoiDuyetID = data["nguoiDuyetID"];
            this.ngayDuyet = data["ngayDuyet"] ? moment(data["ngayDuyet"].toString()) : <any>undefined;
            this.trangThaiID = data["trangThaiID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditQuanLyNghiPhepDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditQuanLyNghiPhepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenNhanVien"] = this.tenNhanVien;
        data["donViCongTacID"] = this.donViCongTacID;
        data["maNV"] = this.maNV;
        data["nghiPhep"] = this.nghiPhep;
        data["congTac"] = this.congTac;
        data["tangCa"] = this.tangCa;
        data["ngayBatDau"] = this.ngayBatDau ? this.ngayBatDau.toISOString() : <any>undefined;
        data["ngayKetThuc"] = this.ngayKetThuc ? this.ngayKetThuc.toISOString() : <any>undefined;
        data["lyDo"] = this.lyDo;
        data["quanLyTrucTiepID"] = this.quanLyTrucTiepID;
        data["truongBoPhanID"] = this.truongBoPhanID;
        data["tepDinhKem"] = this.tepDinhKem;
        data["tenCTY"] = this.tenCTY;
        data["nguoiDuyetID"] = this.nguoiDuyetID;
        data["ngayDuyet"] = this.ngayDuyet ? this.ngayDuyet.toISOString() : <any>undefined;
        data["trangThaiID"] = this.trangThaiID;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditQuanLyNghiPhepDto {
        const json = this.toJSON();
        let result = new CreateOrEditQuanLyNghiPhepDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditQuanLyNghiPhepDto {
    tenNhanVien: string | undefined;
    donViCongTacID: number | undefined;
    maNV: string | undefined;
    nghiPhep: boolean;
    congTac: boolean;
    tangCa: boolean;
    ngayBatDau: moment.Moment;
    ngayKetThuc: moment.Moment;
    lyDo: string | undefined;
    quanLyTrucTiepID: string | undefined;
    truongBoPhanID: string | undefined;
    tepDinhKem: string | undefined;
    tenCTY: string | undefined;
    nguoiDuyetID: number | undefined;
    ngayDuyet: moment.Moment;
    trangThaiID: number | undefined;
    id: number | undefined;
}

export class QuanLyTrucTiepPNPDto implements IQuanLyTrucTiepPNPDto {
    phieuNghiPhepID: number;
    qltt: string | undefined;
    ghiChu: string | undefined;
    maHoSo: string | undefined;
    id: number;

    constructor(data?: IQuanLyTrucTiepPNPDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phieuNghiPhepID = data["phieuNghiPhepID"];
            this.qltt = data["qltt"];
            this.ghiChu = data["ghiChu"];
            this.maHoSo = data["maHoSo"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuanLyTrucTiepPNPDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuanLyTrucTiepPNPDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phieuNghiPhepID"] = this.phieuNghiPhepID;
        data["qltt"] = this.qltt;
        data["ghiChu"] = this.ghiChu;
        data["maHoSo"] = this.maHoSo;
        data["id"] = this.id;
        return data; 
    }

    clone(): QuanLyTrucTiepPNPDto {
        const json = this.toJSON();
        let result = new QuanLyTrucTiepPNPDto();
        result.init(json);
        return result;
    }
}

export interface IQuanLyTrucTiepPNPDto {
    phieuNghiPhepID: number;
    qltt: string | undefined;
    ghiChu: string | undefined;
    maHoSo: string | undefined;
    id: number;
}

export class GetQuanLyNghiPhepForEditOutput implements IGetQuanLyNghiPhepForEditOutput {
    quanLyNghiPhep: CreateOrEditQuanLyNghiPhepDto;
    organizationUnitList: ListResultDtoOfOrganizationUnitDto;
    noiDaoTaoList: NoiDaoTaoDto[] | undefined;
    tinhThanhList: TinhThanhDto[] | undefined;
    templateList: TemplateDto[] | undefined;
    congViecList: OrganizationUnitDto[] | undefined;
    lichSuLamViecList: LichSuLamViecDto[] | undefined;
    lichSuUploadList: LichSuUploadDto[] | undefined;
    quanLyTrucTiepList: QuanLyTrucTiepPNPDto[] | undefined;
    configEmail: GetConfigEmailForViewDto;
    viTriCongViec: TruongGiaoDichDto[] | undefined;
    tienDoTuyenDung: TruongGiaoDichDto[] | undefined;
    trangThai: TruongGiaoDichDto[] | undefined;
    kenhTuyenDung: TruongGiaoDichDto[] | undefined;
    congty: TruongGiaoDichDto[] | undefined;
    gioiTinh: TruongGiaoDichDto[] | undefined;
    tinhTrangHonNhan: TruongGiaoDichDto[] | undefined;
    trinhDoDaoTao: TruongGiaoDichDto[] | undefined;
    xepLoaiHocLuc: TruongGiaoDichDto[] | undefined;
    tinhTrangNhanSu: TruongGiaoDichDto[] | undefined;
    noiKhamBenhList: DangKyKCBDto[] | undefined;
    defaultCbbOption: TruongGiaoDichDto[] | undefined;

    constructor(data?: IGetQuanLyNghiPhepForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.quanLyNghiPhep = new CreateOrEditQuanLyNghiPhepDto();
            this.organizationUnitList = new ListResultDtoOfOrganizationUnitDto();
            this.configEmail = new GetConfigEmailForViewDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.quanLyNghiPhep = data["quanLyNghiPhep"] ? CreateOrEditQuanLyNghiPhepDto.fromJS(data["quanLyNghiPhep"]) : new CreateOrEditQuanLyNghiPhepDto();
            this.organizationUnitList = data["organizationUnitList"] ? ListResultDtoOfOrganizationUnitDto.fromJS(data["organizationUnitList"]) : new ListResultDtoOfOrganizationUnitDto();
            if (data["noiDaoTaoList"] && data["noiDaoTaoList"].constructor === Array) {
                this.noiDaoTaoList = [];
                for (let item of data["noiDaoTaoList"])
                    this.noiDaoTaoList.push(NoiDaoTaoDto.fromJS(item));
            }
            if (data["tinhThanhList"] && data["tinhThanhList"].constructor === Array) {
                this.tinhThanhList = [];
                for (let item of data["tinhThanhList"])
                    this.tinhThanhList.push(TinhThanhDto.fromJS(item));
            }
            if (data["templateList"] && data["templateList"].constructor === Array) {
                this.templateList = [];
                for (let item of data["templateList"])
                    this.templateList.push(TemplateDto.fromJS(item));
            }
            if (data["congViecList"] && data["congViecList"].constructor === Array) {
                this.congViecList = [];
                for (let item of data["congViecList"])
                    this.congViecList.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["lichSuLamViecList"] && data["lichSuLamViecList"].constructor === Array) {
                this.lichSuLamViecList = [];
                for (let item of data["lichSuLamViecList"])
                    this.lichSuLamViecList.push(LichSuLamViecDto.fromJS(item));
            }
            if (data["lichSuUploadList"] && data["lichSuUploadList"].constructor === Array) {
                this.lichSuUploadList = [];
                for (let item of data["lichSuUploadList"])
                    this.lichSuUploadList.push(LichSuUploadDto.fromJS(item));
            }
            if (data["quanLyTrucTiepList"] && data["quanLyTrucTiepList"].constructor === Array) {
                this.quanLyTrucTiepList = [];
                for (let item of data["quanLyTrucTiepList"])
                    this.quanLyTrucTiepList.push(QuanLyTrucTiepPNPDto.fromJS(item));
            }
            this.configEmail = data["configEmail"] ? GetConfigEmailForViewDto.fromJS(data["configEmail"]) : new GetConfigEmailForViewDto();
            if (data["viTriCongViec"] && data["viTriCongViec"].constructor === Array) {
                this.viTriCongViec = [];
                for (let item of data["viTriCongViec"])
                    this.viTriCongViec.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["tienDoTuyenDung"] && data["tienDoTuyenDung"].constructor === Array) {
                this.tienDoTuyenDung = [];
                for (let item of data["tienDoTuyenDung"])
                    this.tienDoTuyenDung.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["trangThai"] && data["trangThai"].constructor === Array) {
                this.trangThai = [];
                for (let item of data["trangThai"])
                    this.trangThai.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["kenhTuyenDung"] && data["kenhTuyenDung"].constructor === Array) {
                this.kenhTuyenDung = [];
                for (let item of data["kenhTuyenDung"])
                    this.kenhTuyenDung.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["congty"] && data["congty"].constructor === Array) {
                this.congty = [];
                for (let item of data["congty"])
                    this.congty.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["gioiTinh"] && data["gioiTinh"].constructor === Array) {
                this.gioiTinh = [];
                for (let item of data["gioiTinh"])
                    this.gioiTinh.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["tinhTrangHonNhan"] && data["tinhTrangHonNhan"].constructor === Array) {
                this.tinhTrangHonNhan = [];
                for (let item of data["tinhTrangHonNhan"])
                    this.tinhTrangHonNhan.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["trinhDoDaoTao"] && data["trinhDoDaoTao"].constructor === Array) {
                this.trinhDoDaoTao = [];
                for (let item of data["trinhDoDaoTao"])
                    this.trinhDoDaoTao.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["xepLoaiHocLuc"] && data["xepLoaiHocLuc"].constructor === Array) {
                this.xepLoaiHocLuc = [];
                for (let item of data["xepLoaiHocLuc"])
                    this.xepLoaiHocLuc.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["tinhTrangNhanSu"] && data["tinhTrangNhanSu"].constructor === Array) {
                this.tinhTrangNhanSu = [];
                for (let item of data["tinhTrangNhanSu"])
                    this.tinhTrangNhanSu.push(TruongGiaoDichDto.fromJS(item));
            }
            if (data["noiKhamBenhList"] && data["noiKhamBenhList"].constructor === Array) {
                this.noiKhamBenhList = [];
                for (let item of data["noiKhamBenhList"])
                    this.noiKhamBenhList.push(DangKyKCBDto.fromJS(item));
            }
            if (data["defaultCbbOption"] && data["defaultCbbOption"].constructor === Array) {
                this.defaultCbbOption = [];
                for (let item of data["defaultCbbOption"])
                    this.defaultCbbOption.push(TruongGiaoDichDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetQuanLyNghiPhepForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuanLyNghiPhepForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quanLyNghiPhep"] = this.quanLyNghiPhep ? this.quanLyNghiPhep.toJSON() : <any>undefined;
        data["organizationUnitList"] = this.organizationUnitList ? this.organizationUnitList.toJSON() : <any>undefined;
        if (this.noiDaoTaoList && this.noiDaoTaoList.constructor === Array) {
            data["noiDaoTaoList"] = [];
            for (let item of this.noiDaoTaoList)
                data["noiDaoTaoList"].push(item.toJSON());
        }
        if (this.tinhThanhList && this.tinhThanhList.constructor === Array) {
            data["tinhThanhList"] = [];
            for (let item of this.tinhThanhList)
                data["tinhThanhList"].push(item.toJSON());
        }
        if (this.templateList && this.templateList.constructor === Array) {
            data["templateList"] = [];
            for (let item of this.templateList)
                data["templateList"].push(item.toJSON());
        }
        if (this.congViecList && this.congViecList.constructor === Array) {
            data["congViecList"] = [];
            for (let item of this.congViecList)
                data["congViecList"].push(item.toJSON());
        }
        if (this.lichSuLamViecList && this.lichSuLamViecList.constructor === Array) {
            data["lichSuLamViecList"] = [];
            for (let item of this.lichSuLamViecList)
                data["lichSuLamViecList"].push(item.toJSON());
        }
        if (this.lichSuUploadList && this.lichSuUploadList.constructor === Array) {
            data["lichSuUploadList"] = [];
            for (let item of this.lichSuUploadList)
                data["lichSuUploadList"].push(item.toJSON());
        }
        if (this.quanLyTrucTiepList && this.quanLyTrucTiepList.constructor === Array) {
            data["quanLyTrucTiepList"] = [];
            for (let item of this.quanLyTrucTiepList)
                data["quanLyTrucTiepList"].push(item.toJSON());
        }
        data["configEmail"] = this.configEmail ? this.configEmail.toJSON() : <any>undefined;
        if (this.viTriCongViec && this.viTriCongViec.constructor === Array) {
            data["viTriCongViec"] = [];
            for (let item of this.viTriCongViec)
                data["viTriCongViec"].push(item.toJSON());
        }
        if (this.tienDoTuyenDung && this.tienDoTuyenDung.constructor === Array) {
            data["tienDoTuyenDung"] = [];
            for (let item of this.tienDoTuyenDung)
                data["tienDoTuyenDung"].push(item.toJSON());
        }
        if (this.trangThai && this.trangThai.constructor === Array) {
            data["trangThai"] = [];
            for (let item of this.trangThai)
                data["trangThai"].push(item.toJSON());
        }
        if (this.kenhTuyenDung && this.kenhTuyenDung.constructor === Array) {
            data["kenhTuyenDung"] = [];
            for (let item of this.kenhTuyenDung)
                data["kenhTuyenDung"].push(item.toJSON());
        }
        if (this.congty && this.congty.constructor === Array) {
            data["congty"] = [];
            for (let item of this.congty)
                data["congty"].push(item.toJSON());
        }
        if (this.gioiTinh && this.gioiTinh.constructor === Array) {
            data["gioiTinh"] = [];
            for (let item of this.gioiTinh)
                data["gioiTinh"].push(item.toJSON());
        }
        if (this.tinhTrangHonNhan && this.tinhTrangHonNhan.constructor === Array) {
            data["tinhTrangHonNhan"] = [];
            for (let item of this.tinhTrangHonNhan)
                data["tinhTrangHonNhan"].push(item.toJSON());
        }
        if (this.trinhDoDaoTao && this.trinhDoDaoTao.constructor === Array) {
            data["trinhDoDaoTao"] = [];
            for (let item of this.trinhDoDaoTao)
                data["trinhDoDaoTao"].push(item.toJSON());
        }
        if (this.xepLoaiHocLuc && this.xepLoaiHocLuc.constructor === Array) {
            data["xepLoaiHocLuc"] = [];
            for (let item of this.xepLoaiHocLuc)
                data["xepLoaiHocLuc"].push(item.toJSON());
        }
        if (this.tinhTrangNhanSu && this.tinhTrangNhanSu.constructor === Array) {
            data["tinhTrangNhanSu"] = [];
            for (let item of this.tinhTrangNhanSu)
                data["tinhTrangNhanSu"].push(item.toJSON());
        }
        if (this.noiKhamBenhList && this.noiKhamBenhList.constructor === Array) {
            data["noiKhamBenhList"] = [];
            for (let item of this.noiKhamBenhList)
                data["noiKhamBenhList"].push(item.toJSON());
        }
        if (this.defaultCbbOption && this.defaultCbbOption.constructor === Array) {
            data["defaultCbbOption"] = [];
            for (let item of this.defaultCbbOption)
                data["defaultCbbOption"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetQuanLyNghiPhepForEditOutput {
        const json = this.toJSON();
        let result = new GetQuanLyNghiPhepForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetQuanLyNghiPhepForEditOutput {
    quanLyNghiPhep: CreateOrEditQuanLyNghiPhepDto;
    organizationUnitList: ListResultDtoOfOrganizationUnitDto;
    noiDaoTaoList: NoiDaoTaoDto[] | undefined;
    tinhThanhList: TinhThanhDto[] | undefined;
    templateList: TemplateDto[] | undefined;
    congViecList: OrganizationUnitDto[] | undefined;
    lichSuLamViecList: LichSuLamViecDto[] | undefined;
    lichSuUploadList: LichSuUploadDto[] | undefined;
    quanLyTrucTiepList: QuanLyTrucTiepPNPDto[] | undefined;
    configEmail: GetConfigEmailForViewDto;
    viTriCongViec: TruongGiaoDichDto[] | undefined;
    tienDoTuyenDung: TruongGiaoDichDto[] | undefined;
    trangThai: TruongGiaoDichDto[] | undefined;
    kenhTuyenDung: TruongGiaoDichDto[] | undefined;
    congty: TruongGiaoDichDto[] | undefined;
    gioiTinh: TruongGiaoDichDto[] | undefined;
    tinhTrangHonNhan: TruongGiaoDichDto[] | undefined;
    trinhDoDaoTao: TruongGiaoDichDto[] | undefined;
    xepLoaiHocLuc: TruongGiaoDichDto[] | undefined;
    tinhTrangNhanSu: TruongGiaoDichDto[] | undefined;
    noiKhamBenhList: DangKyKCBDto[] | undefined;
    defaultCbbOption: TruongGiaoDichDto[] | undefined;
}

export class CreateOrEditNghiPhepInput implements ICreateOrEditNghiPhepInput {
    nghiPhep: CreateOrEditQuanLyNghiPhepDto;
    lichSuUpLoad: LichSuUploadNewDto[] | undefined;
    quanLyTrucTiepPNP: QuanLyTrucTiepPNPDto[] | undefined;

    constructor(data?: ICreateOrEditNghiPhepInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.nghiPhep = new CreateOrEditQuanLyNghiPhepDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.nghiPhep = data["nghiPhep"] ? CreateOrEditQuanLyNghiPhepDto.fromJS(data["nghiPhep"]) : new CreateOrEditQuanLyNghiPhepDto();
            if (data["lichSuUpLoad"] && data["lichSuUpLoad"].constructor === Array) {
                this.lichSuUpLoad = [];
                for (let item of data["lichSuUpLoad"])
                    this.lichSuUpLoad.push(LichSuUploadNewDto.fromJS(item));
            }
            if (data["quanLyTrucTiepPNP"] && data["quanLyTrucTiepPNP"].constructor === Array) {
                this.quanLyTrucTiepPNP = [];
                for (let item of data["quanLyTrucTiepPNP"])
                    this.quanLyTrucTiepPNP.push(QuanLyTrucTiepPNPDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrEditNghiPhepInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditNghiPhepInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nghiPhep"] = this.nghiPhep ? this.nghiPhep.toJSON() : <any>undefined;
        if (this.lichSuUpLoad && this.lichSuUpLoad.constructor === Array) {
            data["lichSuUpLoad"] = [];
            for (let item of this.lichSuUpLoad)
                data["lichSuUpLoad"].push(item.toJSON());
        }
        if (this.quanLyTrucTiepPNP && this.quanLyTrucTiepPNP.constructor === Array) {
            data["quanLyTrucTiepPNP"] = [];
            for (let item of this.quanLyTrucTiepPNP)
                data["quanLyTrucTiepPNP"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateOrEditNghiPhepInput {
        const json = this.toJSON();
        let result = new CreateOrEditNghiPhepInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditNghiPhepInput {
    nghiPhep: CreateOrEditQuanLyNghiPhepDto;
    lichSuUpLoad: LichSuUploadNewDto[] | undefined;
    quanLyTrucTiepPNP: QuanLyTrucTiepPNPDto[] | undefined;
}

export class GetQuanLyTrucTiepPNPForViewDto implements IGetQuanLyTrucTiepPNPForViewDto {
    quanLyTrucTiepPNP: QuanLyTrucTiepPNPDto;

    constructor(data?: IGetQuanLyTrucTiepPNPForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.quanLyTrucTiepPNP = new QuanLyTrucTiepPNPDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.quanLyTrucTiepPNP = data["quanLyTrucTiepPNP"] ? QuanLyTrucTiepPNPDto.fromJS(data["quanLyTrucTiepPNP"]) : new QuanLyTrucTiepPNPDto();
        }
    }

    static fromJS(data: any): GetQuanLyTrucTiepPNPForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuanLyTrucTiepPNPForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quanLyTrucTiepPNP"] = this.quanLyTrucTiepPNP ? this.quanLyTrucTiepPNP.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetQuanLyTrucTiepPNPForViewDto {
        const json = this.toJSON();
        let result = new GetQuanLyTrucTiepPNPForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetQuanLyTrucTiepPNPForViewDto {
    quanLyTrucTiepPNP: QuanLyTrucTiepPNPDto;
}

export class PagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto implements IPagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto {
    totalCount: number;
    items: GetQuanLyTrucTiepPNPForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetQuanLyTrucTiepPNPForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetQuanLyTrucTiepPNPForViewDto {
    totalCount: number;
    items: GetQuanLyTrucTiepPNPForViewDto[] | undefined;
}

export class CreateOrEditQuanLyTrucTiepPNPDto implements ICreateOrEditQuanLyTrucTiepPNPDto {
    phieuNghiPhepID: number;
    qltt: string | undefined;
    ghiChu: string | undefined;
    maHoSo: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditQuanLyTrucTiepPNPDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phieuNghiPhepID = data["phieuNghiPhepID"];
            this.qltt = data["qltt"];
            this.ghiChu = data["ghiChu"];
            this.maHoSo = data["maHoSo"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditQuanLyTrucTiepPNPDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditQuanLyTrucTiepPNPDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phieuNghiPhepID"] = this.phieuNghiPhepID;
        data["qltt"] = this.qltt;
        data["ghiChu"] = this.ghiChu;
        data["maHoSo"] = this.maHoSo;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditQuanLyTrucTiepPNPDto {
        const json = this.toJSON();
        let result = new CreateOrEditQuanLyTrucTiepPNPDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditQuanLyTrucTiepPNPDto {
    phieuNghiPhepID: number;
    qltt: string | undefined;
    ghiChu: string | undefined;
    maHoSo: string | undefined;
    id: number | undefined;
}

export class GetQuanLyTrucTiepPNPForEditOutput implements IGetQuanLyTrucTiepPNPForEditOutput {
    quanLyTrucTiepPNP: CreateOrEditQuanLyTrucTiepPNPDto;

    constructor(data?: IGetQuanLyTrucTiepPNPForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.quanLyTrucTiepPNP = new CreateOrEditQuanLyTrucTiepPNPDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.quanLyTrucTiepPNP = data["quanLyTrucTiepPNP"] ? CreateOrEditQuanLyTrucTiepPNPDto.fromJS(data["quanLyTrucTiepPNP"]) : new CreateOrEditQuanLyTrucTiepPNPDto();
        }
    }

    static fromJS(data: any): GetQuanLyTrucTiepPNPForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuanLyTrucTiepPNPForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quanLyTrucTiepPNP"] = this.quanLyTrucTiepPNP ? this.quanLyTrucTiepPNP.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetQuanLyTrucTiepPNPForEditOutput {
        const json = this.toJSON();
        let result = new GetQuanLyTrucTiepPNPForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetQuanLyTrucTiepPNPForEditOutput {
    quanLyTrucTiepPNP: CreateOrEditQuanLyTrucTiepPNPDto;
}

export class CreateOrEditQuyTrinhCongTacDto implements ICreateOrEditQuyTrinhCongTacDto {
    tenCty: string | undefined;
    dateTo: moment.Moment;
    dateFrom: moment.Moment;
    viTriCongViecCode: string | undefined;
    donViCongTacID: number | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiCode: string | undefined;
    ghiChu: string | undefined;
    maHoSo: number | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditQuyTrinhCongTacDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenCty = data["tenCty"];
            this.dateTo = data["dateTo"] ? moment(data["dateTo"].toString()) : <any>undefined;
            this.dateFrom = data["dateFrom"] ? moment(data["dateFrom"].toString()) : <any>undefined;
            this.viTriCongViecCode = data["viTriCongViecCode"];
            this.donViCongTacID = data["donViCongTacID"];
            this.quanLyTrucTiep = data["quanLyTrucTiep"];
            this.trangThaiCode = data["trangThaiCode"];
            this.ghiChu = data["ghiChu"];
            this.maHoSo = data["maHoSo"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditQuyTrinhCongTacDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditQuyTrinhCongTacDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenCty"] = this.tenCty;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["viTriCongViecCode"] = this.viTriCongViecCode;
        data["donViCongTacID"] = this.donViCongTacID;
        data["quanLyTrucTiep"] = this.quanLyTrucTiep;
        data["trangThaiCode"] = this.trangThaiCode;
        data["ghiChu"] = this.ghiChu;
        data["maHoSo"] = this.maHoSo;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditQuyTrinhCongTacDto {
        const json = this.toJSON();
        let result = new CreateOrEditQuyTrinhCongTacDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditQuyTrinhCongTacDto {
    tenCty: string | undefined;
    dateTo: moment.Moment;
    dateFrom: moment.Moment;
    viTriCongViecCode: string | undefined;
    donViCongTacID: number | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiCode: string | undefined;
    ghiChu: string | undefined;
    maHoSo: number | undefined;
    id: number | undefined;
}

export class GetQuyTrinhCongTacForEditOutput implements IGetQuyTrinhCongTacForEditOutput {
    quyTrinhCongTac: CreateOrEditQuyTrinhCongTacDto;

    constructor(data?: IGetQuyTrinhCongTacForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.quyTrinhCongTac = new CreateOrEditQuyTrinhCongTacDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.quyTrinhCongTac = data["quyTrinhCongTac"] ? CreateOrEditQuyTrinhCongTacDto.fromJS(data["quyTrinhCongTac"]) : new CreateOrEditQuyTrinhCongTacDto();
        }
    }

    static fromJS(data: any): GetQuyTrinhCongTacForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuyTrinhCongTacForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quyTrinhCongTac"] = this.quyTrinhCongTac ? this.quyTrinhCongTac.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetQuyTrinhCongTacForEditOutput {
        const json = this.toJSON();
        let result = new GetQuyTrinhCongTacForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetQuyTrinhCongTacForEditOutput {
    quyTrinhCongTac: CreateOrEditQuyTrinhCongTacDto;
}

export class ReceiveUnitDto implements IReceiveUnitDto {
    name: string | undefined;
    position: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IReceiveUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.position = data["position"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ReceiveUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceiveUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["position"] = this.position;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): ReceiveUnitDto {
        const json = this.toJSON();
        let result = new ReceiveUnitDto();
        result.init(json);
        return result;
    }
}

export interface IReceiveUnitDto {
    name: string | undefined;
    position: string | undefined;
    isActive: boolean;
    id: number;
}

export class GetReceiveUnitForViewDto implements IGetReceiveUnitForViewDto {
    receiveUnit: ReceiveUnitDto;

    constructor(data?: IGetReceiveUnitForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.receiveUnit = new ReceiveUnitDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveUnit = data["receiveUnit"] ? ReceiveUnitDto.fromJS(data["receiveUnit"]) : new ReceiveUnitDto();
        }
    }

    static fromJS(data: any): GetReceiveUnitForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReceiveUnitForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveUnit"] = this.receiveUnit ? this.receiveUnit.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetReceiveUnitForViewDto {
        const json = this.toJSON();
        let result = new GetReceiveUnitForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetReceiveUnitForViewDto {
    receiveUnit: ReceiveUnitDto;
}

export class PagedResultDtoOfGetReceiveUnitForViewDto implements IPagedResultDtoOfGetReceiveUnitForViewDto {
    totalCount: number;
    items: GetReceiveUnitForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetReceiveUnitForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetReceiveUnitForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetReceiveUnitForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetReceiveUnitForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetReceiveUnitForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetReceiveUnitForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetReceiveUnitForViewDto {
    totalCount: number;
    items: GetReceiveUnitForViewDto[] | undefined;
}

export class CreateOrEditReceiveUnitDto implements ICreateOrEditReceiveUnitDto {
    name: string | undefined;
    position: string | undefined;
    isActive: boolean;
    id: number | undefined;

    constructor(data?: ICreateOrEditReceiveUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.position = data["position"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditReceiveUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditReceiveUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["position"] = this.position;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditReceiveUnitDto {
        const json = this.toJSON();
        let result = new CreateOrEditReceiveUnitDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditReceiveUnitDto {
    name: string | undefined;
    position: string | undefined;
    isActive: boolean;
    id: number | undefined;
}

export class GetReceiveUnitForEditOutput implements IGetReceiveUnitForEditOutput {
    receiveUnit: CreateOrEditReceiveUnitDto;

    constructor(data?: IGetReceiveUnitForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.receiveUnit = new CreateOrEditReceiveUnitDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveUnit = data["receiveUnit"] ? CreateOrEditReceiveUnitDto.fromJS(data["receiveUnit"]) : new CreateOrEditReceiveUnitDto();
        }
    }

    static fromJS(data: any): GetReceiveUnitForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetReceiveUnitForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveUnit"] = this.receiveUnit ? this.receiveUnit.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetReceiveUnitForEditOutput {
        const json = this.toJSON();
        let result = new GetReceiveUnitForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetReceiveUnitForEditOutput {
    receiveUnit: CreateOrEditReceiveUnitDto;
}

export class RoleClaim implements IRoleClaim {
    tenantId: number | undefined;
    roleId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IRoleClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.roleId = data["roleId"];
            this.claimType = data["claimType"];
            this.claimValue = data["claimValue"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleClaim {
        data = typeof data === 'object' ? data : {};
        let result = new RoleClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["roleId"] = this.roleId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleClaim {
        const json = this.toJSON();
        let result = new RoleClaim();
        result.init(json);
        return result;
    }
}

export interface IRoleClaim {
    tenantId: number | undefined;
    roleId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserOrganizationUnit implements IUserOrganizationUnit {
    tenantId: number | undefined;
    userId: number;
    organizationUnitId: number;
    isDeleted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserOrganizationUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.isDeleted = data["isDeleted"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserOrganizationUnit {
        data = typeof data === 'object' ? data : {};
        let result = new UserOrganizationUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["isDeleted"] = this.isDeleted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserOrganizationUnit {
        const json = this.toJSON();
        let result = new UserOrganizationUnit();
        result.init(json);
        return result;
    }
}

export interface IUserOrganizationUnit {
    tenantId: number | undefined;
    userId: number;
    organizationUnitId: number;
    isDeleted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserToken implements IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.loginProvider = data["loginProvider"];
            this.name = data["name"];
            this.value = data["value"];
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;
}

export class UserLogin implements IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    providerKey: string | undefined;
    id: number;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.loginProvider = data["loginProvider"];
            this.providerKey = data["providerKey"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    providerKey: string | undefined;
    id: number;
}

export class UserRole implements IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.roleId = data["roleId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserClaim implements IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.claimType = data["claimType"];
            this.claimValue = data["claimValue"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string | undefined;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.isGranted = data["isGranted"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string | undefined;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Setting implements ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.value = data["value"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class User implements IUser {
    profilePictureId: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    signInTokenExpireTimeUtc: moment.Moment | undefined;
    signInToken: string | undefined;
    googleAuthenticatorKey: string | undefined;
    organizationUnits: UserOrganizationUnit[] | undefined;
    employeeCode: string | undefined;
    normalizedUserName: string | undefined;
    normalizedEmailAddress: string | undefined;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string | undefined;
    tenantId: number | undefined;
    emailAddress: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    fullName: string | undefined;
    password: string | undefined;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.deleterUser = new User();
            this.creatorUser = new User();
            this.lastModifierUser = new User();
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.signInTokenExpireTimeUtc = data["signInTokenExpireTimeUtc"] ? moment(data["signInTokenExpireTimeUtc"].toString()) : <any>undefined;
            this.signInToken = data["signInToken"];
            this.googleAuthenticatorKey = data["googleAuthenticatorKey"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [];
                for (let item of data["organizationUnits"])
                    this.organizationUnits.push(UserOrganizationUnit.fromJS(item));
            }
            this.employeeCode = data["employeeCode"];
            this.normalizedUserName = data["normalizedUserName"];
            this.normalizedEmailAddress = data["normalizedEmailAddress"];
            this.concurrencyStamp = data["concurrencyStamp"];
            if (data["tokens"] && data["tokens"].constructor === Array) {
                this.tokens = [];
                for (let item of data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = data["deleterUser"] ? User.fromJS(data["deleterUser"]) : new User();
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : new User();
            this.lastModifierUser = data["lastModifierUser"] ? User.fromJS(data["lastModifierUser"]) : new User();
            this.authenticationSource = data["authenticationSource"];
            this.userName = data["userName"];
            this.tenantId = data["tenantId"];
            this.emailAddress = data["emailAddress"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.fullName = data["fullName"];
            this.password = data["password"];
            this.emailConfirmationCode = data["emailConfirmationCode"];
            this.passwordResetCode = data["passwordResetCode"];
            this.lockoutEndDateUtc = data["lockoutEndDateUtc"] ? moment(data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = data["accessFailedCount"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.securityStamp = data["securityStamp"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            if (data["logins"] && data["logins"].constructor === Array) {
                this.logins = [];
                for (let item of data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (data["claims"] && data["claims"].constructor === Array) {
                this.claims = [];
                for (let item of data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (data["settings"] && data["settings"].constructor === Array) {
                this.settings = [];
                for (let item of data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.isActive = data["isActive"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["signInTokenExpireTimeUtc"] = this.signInTokenExpireTimeUtc ? this.signInTokenExpireTimeUtc.toISOString() : <any>undefined;
        data["signInToken"] = this.signInToken;
        data["googleAuthenticatorKey"] = this.googleAuthenticatorKey;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item.toJSON());
        }
        data["employeeCode"] = this.employeeCode;
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (this.tokens && this.tokens.constructor === Array) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (this.logins && this.logins.constructor === Array) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.claims && this.claims.constructor === Array) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.settings && this.settings.constructor === Array) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    profilePictureId: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    signInTokenExpireTimeUtc: moment.Moment | undefined;
    signInToken: string | undefined;
    googleAuthenticatorKey: string | undefined;
    organizationUnits: UserOrganizationUnit[] | undefined;
    employeeCode: string | undefined;
    normalizedUserName: string | undefined;
    normalizedEmailAddress: string | undefined;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string | undefined;
    tenantId: number | undefined;
    emailAddress: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    fullName: string | undefined;
    password: string | undefined;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class RolePermissionSetting implements IRolePermissionSetting {
    roleId: number;
    tenantId: number | undefined;
    name: string | undefined;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IRolePermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.isGranted = data["isGranted"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RolePermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RolePermissionSetting {
        const json = this.toJSON();
        let result = new RolePermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionSetting {
    roleId: number;
    tenantId: number | undefined;
    name: string | undefined;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Role implements IRole {
    normalizedName: string | undefined;
    claims: RoleClaim[] | undefined;
    concurrencyStamp: string | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    permissions: RolePermissionSetting[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.deleterUser = new User();
            this.creatorUser = new User();
            this.lastModifierUser = new User();
        }
    }

    init(data?: any) {
        if (data) {
            this.normalizedName = data["normalizedName"];
            if (data["claims"] && data["claims"].constructor === Array) {
                this.claims = [];
                for (let item of data["claims"])
                    this.claims.push(RoleClaim.fromJS(item));
            }
            this.concurrencyStamp = data["concurrencyStamp"];
            this.deleterUser = data["deleterUser"] ? User.fromJS(data["deleterUser"]) : new User();
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : new User();
            this.lastModifierUser = data["lastModifierUser"] ? User.fromJS(data["lastModifierUser"]) : new User();
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(RolePermissionSetting.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["normalizedName"] = this.normalizedName;
        if (this.claims && this.claims.constructor === Array) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Role {
        const json = this.toJSON();
        let result = new Role();
        result.init(json);
        return result;
    }
}

export interface IRole {
    normalizedName: string | undefined;
    claims: RoleClaim[] | undefined;
    concurrencyStamp: string | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    permissions: RolePermissionSetting[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id: number | undefined;
    displayName: string | undefined;
    isDefault: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string | undefined;
    isDefault: boolean;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): CreateOrUpdateRoleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[] | undefined;
}

export class RoleMapperDto implements IRoleMapperDto {
    roleId: number;
    name: string | undefined;
    labelId: number;
    menuId: number;
    isActive: boolean;
    id: number;

    constructor(data?: IRoleMapperDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.name = data["name"];
            this.labelId = data["labelId"];
            this.menuId = data["menuId"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleMapperDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleMapperDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["name"] = this.name;
        data["labelId"] = this.labelId;
        data["menuId"] = this.menuId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleMapperDto {
        const json = this.toJSON();
        let result = new RoleMapperDto();
        result.init(json);
        return result;
    }
}

export interface IRoleMapperDto {
    roleId: number;
    name: string | undefined;
    labelId: number;
    menuId: number;
    isActive: boolean;
    id: number;
}

export class GetRoleMapperForViewDto implements IGetRoleMapperForViewDto {
    roleMapper: RoleMapperDto;
    labelNameValue: string | undefined;
    roleNameValue: string | undefined;

    constructor(data?: IGetRoleMapperForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roleMapper = new RoleMapperDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.roleMapper = data["roleMapper"] ? RoleMapperDto.fromJS(data["roleMapper"]) : new RoleMapperDto();
            this.labelNameValue = data["labelNameValue"];
            this.roleNameValue = data["roleNameValue"];
        }
    }

    static fromJS(data: any): GetRoleMapperForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleMapperForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleMapper"] = this.roleMapper ? this.roleMapper.toJSON() : <any>undefined;
        data["labelNameValue"] = this.labelNameValue;
        data["roleNameValue"] = this.roleNameValue;
        return data; 
    }

    clone(): GetRoleMapperForViewDto {
        const json = this.toJSON();
        let result = new GetRoleMapperForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetRoleMapperForViewDto {
    roleMapper: RoleMapperDto;
    labelNameValue: string | undefined;
    roleNameValue: string | undefined;
}

export class PagedResultDtoOfGetRoleMapperForViewDto implements IPagedResultDtoOfGetRoleMapperForViewDto {
    totalCount: number;
    items: GetRoleMapperForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRoleMapperForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetRoleMapperForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRoleMapperForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRoleMapperForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetRoleMapperForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetRoleMapperForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetRoleMapperForViewDto {
    totalCount: number;
    items: GetRoleMapperForViewDto[] | undefined;
}

export class CreateOrEditRoleMapperDto implements ICreateOrEditRoleMapperDto {
    roleId: number;
    name: string | undefined;
    labelId: number;
    menuId: number;
    isActive: boolean;
    id: number | undefined;

    constructor(data?: ICreateOrEditRoleMapperDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.name = data["name"];
            this.labelId = data["labelId"];
            this.menuId = data["menuId"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRoleMapperDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRoleMapperDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["name"] = this.name;
        data["labelId"] = this.labelId;
        data["menuId"] = this.menuId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditRoleMapperDto {
        const json = this.toJSON();
        let result = new CreateOrEditRoleMapperDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditRoleMapperDto {
    roleId: number;
    name: string | undefined;
    labelId: number;
    menuId: number;
    isActive: boolean;
    id: number | undefined;
}

export class GetRoleMapperForEditOutput implements IGetRoleMapperForEditOutput {
    roleMapper: CreateOrEditRoleMapperDto;

    constructor(data?: IGetRoleMapperForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roleMapper = new CreateOrEditRoleMapperDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.roleMapper = data["roleMapper"] ? CreateOrEditRoleMapperDto.fromJS(data["roleMapper"]) : new CreateOrEditRoleMapperDto();
        }
    }

    static fromJS(data: any): GetRoleMapperForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleMapperForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleMapper"] = this.roleMapper ? this.roleMapper.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetRoleMapperForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleMapperForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleMapperForEditOutput {
    roleMapper: CreateOrEditRoleMapperDto;
}

export class CreateOrEditListRoleMapper implements ICreateOrEditListRoleMapper {
    roleId: number;
    name: string | undefined;
    labelId: number[] | undefined;
    menuId: number;
    isActive: boolean;
    id: number;

    constructor(data?: ICreateOrEditListRoleMapper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.name = data["name"];
            if (data["labelId"] && data["labelId"].constructor === Array) {
                this.labelId = [];
                for (let item of data["labelId"])
                    this.labelId.push(item);
            }
            this.menuId = data["menuId"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditListRoleMapper {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditListRoleMapper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["name"] = this.name;
        if (this.labelId && this.labelId.constructor === Array) {
            data["labelId"] = [];
            for (let item of this.labelId)
                data["labelId"].push(item);
        }
        data["menuId"] = this.menuId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditListRoleMapper {
        const json = this.toJSON();
        let result = new CreateOrEditListRoleMapper();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditListRoleMapper {
    roleId: number;
    name: string | undefined;
    labelId: number[] | undefined;
    menuId: number;
    isActive: boolean;
    id: number;
}

export class ScheduleDto implements IScheduleDto {
    scheduleTypeID: number;
    dateCreated: moment.Moment;
    dateOccur: moment.Moment;
    fromTime: string | undefined;
    toTime: string | undefined;
    content: string | undefined;
    notes: string | undefined;
    id: number;

    constructor(data?: IScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scheduleTypeID = data["scheduleTypeID"];
            this.dateCreated = data["dateCreated"] ? moment(data["dateCreated"].toString()) : <any>undefined;
            this.dateOccur = data["dateOccur"] ? moment(data["dateOccur"].toString()) : <any>undefined;
            this.fromTime = data["fromTime"];
            this.toTime = data["toTime"];
            this.content = data["content"];
            this.notes = data["notes"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleTypeID"] = this.scheduleTypeID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["dateOccur"] = this.dateOccur ? this.dateOccur.toISOString() : <any>undefined;
        data["fromTime"] = this.fromTime;
        data["toTime"] = this.toTime;
        data["content"] = this.content;
        data["notes"] = this.notes;
        data["id"] = this.id;
        return data; 
    }

    clone(): ScheduleDto {
        const json = this.toJSON();
        let result = new ScheduleDto();
        result.init(json);
        return result;
    }
}

export interface IScheduleDto {
    scheduleTypeID: number;
    dateCreated: moment.Moment;
    dateOccur: moment.Moment;
    fromTime: string | undefined;
    toTime: string | undefined;
    content: string | undefined;
    notes: string | undefined;
    id: number;
}

export class GetScheduleForViewDto implements IGetScheduleForViewDto {
    schedule: ScheduleDto;

    constructor(data?: IGetScheduleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.schedule = new ScheduleDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.schedule = data["schedule"] ? ScheduleDto.fromJS(data["schedule"]) : new ScheduleDto();
        }
    }

    static fromJS(data: any): GetScheduleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetScheduleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetScheduleForViewDto {
        const json = this.toJSON();
        let result = new GetScheduleForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetScheduleForViewDto {
    schedule: ScheduleDto;
}

export class PagedResultDtoOfGetScheduleForViewDto implements IPagedResultDtoOfGetScheduleForViewDto {
    totalCount: number;
    items: GetScheduleForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetScheduleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetScheduleForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetScheduleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetScheduleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetScheduleForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetScheduleForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetScheduleForViewDto {
    totalCount: number;
    items: GetScheduleForViewDto[] | undefined;
}

export class CreateOrEditScheduleDto implements ICreateOrEditScheduleDto {
    scheduleTypeID: number;
    dateCreated: moment.Moment;
    dateOccur: moment.Moment;
    fromTime: string | undefined;
    toTime: string | undefined;
    content: string | undefined;
    notes: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scheduleTypeID = data["scheduleTypeID"];
            this.dateCreated = data["dateCreated"] ? moment(data["dateCreated"].toString()) : <any>undefined;
            this.dateOccur = data["dateOccur"] ? moment(data["dateOccur"].toString()) : <any>undefined;
            this.fromTime = data["fromTime"];
            this.toTime = data["toTime"];
            this.content = data["content"];
            this.notes = data["notes"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleTypeID"] = this.scheduleTypeID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["dateOccur"] = this.dateOccur ? this.dateOccur.toISOString() : <any>undefined;
        data["fromTime"] = this.fromTime;
        data["toTime"] = this.toTime;
        data["content"] = this.content;
        data["notes"] = this.notes;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditScheduleDto {
        const json = this.toJSON();
        let result = new CreateOrEditScheduleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditScheduleDto {
    scheduleTypeID: number;
    dateCreated: moment.Moment;
    dateOccur: moment.Moment;
    fromTime: string | undefined;
    toTime: string | undefined;
    content: string | undefined;
    notes: string | undefined;
    id: number | undefined;
}

export class GetScheduleForEditOutput implements IGetScheduleForEditOutput {
    schedule: CreateOrEditScheduleDto;

    constructor(data?: IGetScheduleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.schedule = new CreateOrEditScheduleDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.schedule = data["schedule"] ? CreateOrEditScheduleDto.fromJS(data["schedule"]) : new CreateOrEditScheduleDto();
        }
    }

    static fromJS(data: any): GetScheduleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetScheduleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetScheduleForEditOutput {
        const json = this.toJSON();
        let result = new GetScheduleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetScheduleForEditOutput {
    schedule: CreateOrEditScheduleDto;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number;
}

export enum SubscriptionPaymentType {
    Manual = 0, 
    RecurringAutomatic = 1, 
    RecurringManual = 2, 
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditionInfoDto {
        const json = this.toJSON();
        let result = new EditionInfoDto();
        result.init(json);
        return result;
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
    subscriptionPaymentType: SubscriptionPaymentType;
    edition: EditionInfoDto;
    creationTime: moment.Moment;
    paymentPeriodType: PaymentPeriodType;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionInfoDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.subscriptionPaymentType = data["subscriptionPaymentType"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : new EditionInfoDto();
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
    subscriptionPaymentType: SubscriptionPaymentType;
    edition: EditionInfoDto;
    creationTime: moment.Moment;
    paymentPeriodType: PaymentPeriodType;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            this.currency = data["currency"];
            this.currencySign = data["currencySign"];
            this.allowTenantsToChangeEmailSettings = data["allowTenantsToChangeEmailSettings"];
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean;
    features: { [key: string] : boolean; } | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType: string | undefined;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        return data; 
    }

    clone(): ThemeLayoutSettingsDto {
        const json = this.toJSON();
        let result = new ThemeLayoutSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean;
    mobileFixedHeader: boolean;
    headerSkin: string | undefined;
    minimizeDesktopHeaderType: string | undefined;
    headerMenuArrows: boolean;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.headerSkin = data["headerSkin"];
            this.minimizeDesktopHeaderType = data["minimizeDesktopHeaderType"];
            this.headerMenuArrows = data["headerMenuArrows"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        data["headerMenuArrows"] = this.headerMenuArrows;
        return data; 
    }

    clone(): ThemeHeaderSettingsDto {
        const json = this.toJSON();
        let result = new ThemeHeaderSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean;
    mobileFixedHeader: boolean;
    headerSkin: string | undefined;
    minimizeDesktopHeaderType: string | undefined;
    headerMenuArrows: boolean;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean;
    subheaderStyle: string | undefined;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedSubHeader = data["fixedSubHeader"];
            this.subheaderStyle = data["subheaderStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        return data; 
    }

    clone(): ThemeSubHeaderSettingsDto {
        const json = this.toJSON();
        let result = new ThemeSubHeaderSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean;
    subheaderStyle: string | undefined;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean;
    allowAsideMinimizing: boolean;
    defaultMinimizedAside: boolean;
    submenuToggle: string | undefined;
    searchActive: boolean;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.submenuToggle = data["submenuToggle"];
            this.searchActive = data["searchActive"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        data["searchActive"] = this.searchActive;
        return data; 
    }

    clone(): ThemeMenuSettingsDto {
        const json = this.toJSON();
        let result = new ThemeMenuSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean;
    allowAsideMinimizing: boolean;
    defaultMinimizedAside: boolean;
    submenuToggle: string | undefined;
    searchActive: boolean;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter: boolean;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }

    clone(): ThemeFooterSettingsDto {
        const json = this.toJSON();
        let result = new ThemeFooterSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto;
    header: ThemeHeaderSettingsDto;
    subHeader: ThemeSubHeaderSettingsDto;
    menu: ThemeMenuSettingsDto;
    footer: ThemeFooterSettingsDto;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.layout = new ThemeLayoutSettingsDto();
            this.header = new ThemeHeaderSettingsDto();
            this.subHeader = new ThemeSubHeaderSettingsDto();
            this.menu = new ThemeMenuSettingsDto();
            this.footer = new ThemeFooterSettingsDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
            this.layout = data["layout"] ? ThemeLayoutSettingsDto.fromJS(data["layout"]) : new ThemeLayoutSettingsDto();
            this.header = data["header"] ? ThemeHeaderSettingsDto.fromJS(data["header"]) : new ThemeHeaderSettingsDto();
            this.subHeader = data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(data["subHeader"]) : new ThemeSubHeaderSettingsDto();
            this.menu = data["menu"] ? ThemeMenuSettingsDto.fromJS(data["menu"]) : new ThemeMenuSettingsDto();
            this.footer = data["footer"] ? ThemeFooterSettingsDto.fromJS(data["footer"]) : new ThemeFooterSettingsDto();
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ThemeSettingsDto {
        const json = this.toJSON();
        let result = new ThemeSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto;
    header: ThemeHeaderSettingsDto;
    subHeader: ThemeSubHeaderSettingsDto;
    menu: ThemeMenuSettingsDto;
    footer: ThemeFooterSettingsDto;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto;
    isLeftMenuUsed: boolean;
    isTopMenuUsed: boolean;
    isTabMenuUsed: boolean;
    allowMenuScroll: boolean;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.baseSettings = new ThemeSettingsDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.baseSettings = data["baseSettings"] ? ThemeSettingsDto.fromJS(data["baseSettings"]) : new ThemeSettingsDto();
            this.isLeftMenuUsed = data["isLeftMenuUsed"];
            this.isTopMenuUsed = data["isTopMenuUsed"];
            this.isTabMenuUsed = data["isTabMenuUsed"];
            this.allowMenuScroll = data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data; 
    }

    clone(): UiCustomizationSettingsDto {
        const json = this.toJSON();
        let result = new UiCustomizationSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto;
    isLeftMenuUsed: boolean;
    isTopMenuUsed: boolean;
    isTabMenuUsed: boolean;
    allowMenuScroll: boolean;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
    theme: UiCustomizationSettingsDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserLoginInfoDto();
            this.tenant = new TenantLoginInfoDto();
            this.application = new ApplicationInfoDto();
            this.theme = new UiCustomizationSettingsDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : new UserLoginInfoDto();
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : new TenantLoginInfoDto();
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : new ApplicationInfoDto();
            this.theme = data["theme"] ? UiCustomizationSettingsDto.fromJS(data["theme"]) : new UiCustomizationSettingsDto();
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
    theme: UiCustomizationSettingsDto;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }

    clone(): UpdateUserSignInTokenOutput {
        const json = this.toJSON();
        let result = new UpdateUserSignInTokenOutput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class SettingConfigDto implements ISettingConfigDto {
    code: string | undefined;
    valueString: string | undefined;
    valueInt: number | undefined;
    valueHtml: string | undefined;
    image: string | undefined;
    id: number;

    constructor(data?: ISettingConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.valueString = data["valueString"];
            this.valueInt = data["valueInt"];
            this.valueHtml = data["valueHtml"];
            this.image = data["image"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SettingConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["valueString"] = this.valueString;
        data["valueInt"] = this.valueInt;
        data["valueHtml"] = this.valueHtml;
        data["image"] = this.image;
        data["id"] = this.id;
        return data; 
    }

    clone(): SettingConfigDto {
        const json = this.toJSON();
        let result = new SettingConfigDto();
        result.init(json);
        return result;
    }
}

export interface ISettingConfigDto {
    code: string | undefined;
    valueString: string | undefined;
    valueInt: number | undefined;
    valueHtml: string | undefined;
    image: string | undefined;
    id: number;
}

export class GetSettingConfigForViewDto implements IGetSettingConfigForViewDto {
    settingConfig: SettingConfigDto;

    constructor(data?: IGetSettingConfigForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.settingConfig = new SettingConfigDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.settingConfig = data["settingConfig"] ? SettingConfigDto.fromJS(data["settingConfig"]) : new SettingConfigDto();
        }
    }

    static fromJS(data: any): GetSettingConfigForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSettingConfigForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settingConfig"] = this.settingConfig ? this.settingConfig.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSettingConfigForViewDto {
        const json = this.toJSON();
        let result = new GetSettingConfigForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetSettingConfigForViewDto {
    settingConfig: SettingConfigDto;
}

export class PagedResultDtoOfGetSettingConfigForViewDto implements IPagedResultDtoOfGetSettingConfigForViewDto {
    totalCount: number;
    items: GetSettingConfigForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSettingConfigForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetSettingConfigForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSettingConfigForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSettingConfigForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetSettingConfigForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetSettingConfigForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetSettingConfigForViewDto {
    totalCount: number;
    items: GetSettingConfigForViewDto[] | undefined;
}

export class CreateOrEditSettingConfigDto implements ICreateOrEditSettingConfigDto {
    code: string | undefined;
    valueString: string | undefined;
    valueInt: number | undefined;
    valueHtml: string | undefined;
    image: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditSettingConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.valueString = data["valueString"];
            this.valueInt = data["valueInt"];
            this.valueHtml = data["valueHtml"];
            this.image = data["image"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSettingConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSettingConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["valueString"] = this.valueString;
        data["valueInt"] = this.valueInt;
        data["valueHtml"] = this.valueHtml;
        data["image"] = this.image;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditSettingConfigDto {
        const json = this.toJSON();
        let result = new CreateOrEditSettingConfigDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditSettingConfigDto {
    code: string | undefined;
    valueString: string | undefined;
    valueInt: number | undefined;
    valueHtml: string | undefined;
    image: string | undefined;
    id: number | undefined;
}

export class GetSettingConfigForEditOutput implements IGetSettingConfigForEditOutput {
    settingConfig: CreateOrEditSettingConfigDto;

    constructor(data?: IGetSettingConfigForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.settingConfig = new CreateOrEditSettingConfigDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.settingConfig = data["settingConfig"] ? CreateOrEditSettingConfigDto.fromJS(data["settingConfig"]) : new CreateOrEditSettingConfigDto();
        }
    }

    static fromJS(data: any): GetSettingConfigForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSettingConfigForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settingConfig"] = this.settingConfig ? this.settingConfig.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSettingConfigForEditOutput {
        const json = this.toJSON();
        let result = new GetSettingConfigForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSettingConfigForEditOutput {
    settingConfig: CreateOrEditSettingConfigDto;
}

export class DataVm implements IDataVm {
    isSucceeded: boolean;
    data: Data2 | undefined;
    message: string | undefined;
    code: string | undefined;

    constructor(data?: IDataVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isSucceeded = data["isSucceeded"];
            this.data = data["data"] ? Data2.fromJS(data["data"]) : <any>undefined;
            this.message = data["message"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): DataVm {
        data = typeof data === 'object' ? data : {};
        let result = new DataVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSucceeded"] = this.isSucceeded;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["code"] = this.code;
        return data; 
    }

    clone(): DataVm {
        const json = this.toJSON();
        let result = new DataVm();
        result.init(json);
        return result;
    }
}

export interface IDataVm {
    isSucceeded: boolean;
    data: Data2 | undefined;
    message: string | undefined;
    code: string | undefined;
}

export class GetSqlConfigDetailForViewDto implements IGetSqlConfigDetailForViewDto {
    sqlConfigDetail: SqlConfigDetailDto;

    constructor(data?: IGetSqlConfigDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sqlConfigDetail = new SqlConfigDetailDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.sqlConfigDetail = data["sqlConfigDetail"] ? SqlConfigDetailDto.fromJS(data["sqlConfigDetail"]) : new SqlConfigDetailDto();
        }
    }

    static fromJS(data: any): GetSqlConfigDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSqlConfigDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sqlConfigDetail"] = this.sqlConfigDetail ? this.sqlConfigDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSqlConfigDetailForViewDto {
        const json = this.toJSON();
        let result = new GetSqlConfigDetailForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetSqlConfigDetailForViewDto {
    sqlConfigDetail: SqlConfigDetailDto;
}

export class PagedResultDtoOfGetSqlConfigDetailForViewDto implements IPagedResultDtoOfGetSqlConfigDetailForViewDto {
    totalCount: number;
    items: GetSqlConfigDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSqlConfigDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetSqlConfigDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSqlConfigDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSqlConfigDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetSqlConfigDetailForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetSqlConfigDetailForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetSqlConfigDetailForViewDto {
    totalCount: number;
    items: GetSqlConfigDetailForViewDto[] | undefined;
}

export class CreateOrEditSqlConfigDetailDto implements ICreateOrEditSqlConfigDetailDto {
    sqlConfigId: number;
    code: string | undefined;
    name: string | undefined;
    format: string | undefined;
    type: string | undefined;
    width: string | undefined;
    colNum: number | undefined;
    groupLevel: number | undefined;
    isDisplay: boolean;
    order: number | undefined;
    textAlign: string | undefined;
    version: number | undefined;
    isSum: boolean;
    isFreePane: boolean;
    isParent: boolean;
    parentCode: string | undefined;
    groupSort: string | undefined;
    cellTemplate: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditSqlConfigDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sqlConfigId = data["sqlConfigId"];
            this.code = data["code"];
            this.name = data["name"];
            this.format = data["format"];
            this.type = data["type"];
            this.width = data["width"];
            this.colNum = data["colNum"];
            this.groupLevel = data["groupLevel"];
            this.isDisplay = data["isDisplay"];
            this.order = data["order"];
            this.textAlign = data["textAlign"];
            this.version = data["version"];
            this.isSum = data["isSum"];
            this.isFreePane = data["isFreePane"];
            this.isParent = data["isParent"];
            this.parentCode = data["parentCode"];
            this.groupSort = data["groupSort"];
            this.cellTemplate = data["cellTemplate"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSqlConfigDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSqlConfigDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sqlConfigId"] = this.sqlConfigId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["format"] = this.format;
        data["type"] = this.type;
        data["width"] = this.width;
        data["colNum"] = this.colNum;
        data["groupLevel"] = this.groupLevel;
        data["isDisplay"] = this.isDisplay;
        data["order"] = this.order;
        data["textAlign"] = this.textAlign;
        data["version"] = this.version;
        data["isSum"] = this.isSum;
        data["isFreePane"] = this.isFreePane;
        data["isParent"] = this.isParent;
        data["parentCode"] = this.parentCode;
        data["groupSort"] = this.groupSort;
        data["cellTemplate"] = this.cellTemplate;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditSqlConfigDetailDto {
        const json = this.toJSON();
        let result = new CreateOrEditSqlConfigDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditSqlConfigDetailDto {
    sqlConfigId: number;
    code: string | undefined;
    name: string | undefined;
    format: string | undefined;
    type: string | undefined;
    width: string | undefined;
    colNum: number | undefined;
    groupLevel: number | undefined;
    isDisplay: boolean;
    order: number | undefined;
    textAlign: string | undefined;
    version: number | undefined;
    isSum: boolean;
    isFreePane: boolean;
    isParent: boolean;
    parentCode: string | undefined;
    groupSort: string | undefined;
    cellTemplate: string | undefined;
    id: number | undefined;
}

export class GetSqlConfigDetailForEditOutput implements IGetSqlConfigDetailForEditOutput {
    sqlConfigDetail: CreateOrEditSqlConfigDetailDto;

    constructor(data?: IGetSqlConfigDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sqlConfigDetail = new CreateOrEditSqlConfigDetailDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.sqlConfigDetail = data["sqlConfigDetail"] ? CreateOrEditSqlConfigDetailDto.fromJS(data["sqlConfigDetail"]) : new CreateOrEditSqlConfigDetailDto();
        }
    }

    static fromJS(data: any): GetSqlConfigDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSqlConfigDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sqlConfigDetail"] = this.sqlConfigDetail ? this.sqlConfigDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSqlConfigDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetSqlConfigDetailForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSqlConfigDetailForEditOutput {
    sqlConfigDetail: CreateOrEditSqlConfigDetailDto;
}

export class GetSqlConfigForViewDto implements IGetSqlConfigForViewDto {
    sqlConfig: SqlConfigDto;

    constructor(data?: IGetSqlConfigForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sqlConfig = new SqlConfigDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.sqlConfig = data["sqlConfig"] ? SqlConfigDto.fromJS(data["sqlConfig"]) : new SqlConfigDto();
        }
    }

    static fromJS(data: any): GetSqlConfigForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSqlConfigForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sqlConfig"] = this.sqlConfig ? this.sqlConfig.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSqlConfigForViewDto {
        const json = this.toJSON();
        let result = new GetSqlConfigForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetSqlConfigForViewDto {
    sqlConfig: SqlConfigDto;
}

export class PagedResultDtoOfGetSqlConfigForViewDto implements IPagedResultDtoOfGetSqlConfigForViewDto {
    totalCount: number;
    items: GetSqlConfigForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSqlConfigForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetSqlConfigForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSqlConfigForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSqlConfigForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetSqlConfigForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetSqlConfigForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetSqlConfigForViewDto {
    totalCount: number;
    items: GetSqlConfigForViewDto[] | undefined;
}

export class CreateOrEditSqlConfigDto implements ICreateOrEditSqlConfigDto {
    code: string | undefined;
    name: string | undefined;
    isRawQuery: boolean;
    sqlContent: string | undefined;
    groupLevel: number | undefined;
    displayType: number | undefined;
    version: number | undefined;
    isDynamicColumn: boolean;
    typeGetColumn: number | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditSqlConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.isRawQuery = data["isRawQuery"];
            this.sqlContent = data["sqlContent"];
            this.groupLevel = data["groupLevel"];
            this.displayType = data["displayType"];
            this.version = data["version"];
            this.isDynamicColumn = data["isDynamicColumn"];
            this.typeGetColumn = data["typeGetColumn"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSqlConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSqlConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["isRawQuery"] = this.isRawQuery;
        data["sqlContent"] = this.sqlContent;
        data["groupLevel"] = this.groupLevel;
        data["displayType"] = this.displayType;
        data["version"] = this.version;
        data["isDynamicColumn"] = this.isDynamicColumn;
        data["typeGetColumn"] = this.typeGetColumn;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditSqlConfigDto {
        const json = this.toJSON();
        let result = new CreateOrEditSqlConfigDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditSqlConfigDto {
    code: string | undefined;
    name: string | undefined;
    isRawQuery: boolean;
    sqlContent: string | undefined;
    groupLevel: number | undefined;
    displayType: number | undefined;
    version: number | undefined;
    isDynamicColumn: boolean;
    typeGetColumn: number | undefined;
    id: number | undefined;
}

export class GetSqlConfigForEditOutput implements IGetSqlConfigForEditOutput {
    sqlConfig: CreateOrEditSqlConfigDto;

    constructor(data?: IGetSqlConfigForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sqlConfig = new CreateOrEditSqlConfigDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.sqlConfig = data["sqlConfig"] ? CreateOrEditSqlConfigDto.fromJS(data["sqlConfig"]) : new CreateOrEditSqlConfigDto();
        }
    }

    static fromJS(data: any): GetSqlConfigForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSqlConfigForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sqlConfig"] = this.sqlConfig ? this.sqlConfig.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSqlConfigForEditOutput {
        const json = this.toJSON();
        let result = new GetSqlConfigForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSqlConfigForEditOutput {
    sqlConfig: CreateOrEditSqlConfigDto;
}

export class SqlStoreParamDto implements ISqlStoreParamDto {
    sqlConfigId: number | undefined;
    code: string | undefined;
    format: string | undefined;
    name: string | undefined;
    isActive: boolean;
    valueString: string | undefined;
    valueInt: number | undefined;
    id: number;

    constructor(data?: ISqlStoreParamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sqlConfigId = data["sqlConfigId"];
            this.code = data["code"];
            this.format = data["format"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.valueString = data["valueString"];
            this.valueInt = data["valueInt"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SqlStoreParamDto {
        data = typeof data === 'object' ? data : {};
        let result = new SqlStoreParamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sqlConfigId"] = this.sqlConfigId;
        data["code"] = this.code;
        data["format"] = this.format;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["valueString"] = this.valueString;
        data["valueInt"] = this.valueInt;
        data["id"] = this.id;
        return data; 
    }

    clone(): SqlStoreParamDto {
        const json = this.toJSON();
        let result = new SqlStoreParamDto();
        result.init(json);
        return result;
    }
}

export interface ISqlStoreParamDto {
    sqlConfigId: number | undefined;
    code: string | undefined;
    format: string | undefined;
    name: string | undefined;
    isActive: boolean;
    valueString: string | undefined;
    valueInt: number | undefined;
    id: number;
}

export class GetSqlStoreParamForViewDto implements IGetSqlStoreParamForViewDto {
    sqlStoreParam: SqlStoreParamDto;

    constructor(data?: IGetSqlStoreParamForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sqlStoreParam = new SqlStoreParamDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.sqlStoreParam = data["sqlStoreParam"] ? SqlStoreParamDto.fromJS(data["sqlStoreParam"]) : new SqlStoreParamDto();
        }
    }

    static fromJS(data: any): GetSqlStoreParamForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSqlStoreParamForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sqlStoreParam"] = this.sqlStoreParam ? this.sqlStoreParam.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSqlStoreParamForViewDto {
        const json = this.toJSON();
        let result = new GetSqlStoreParamForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetSqlStoreParamForViewDto {
    sqlStoreParam: SqlStoreParamDto;
}

export class PagedResultDtoOfGetSqlStoreParamForViewDto implements IPagedResultDtoOfGetSqlStoreParamForViewDto {
    totalCount: number;
    items: GetSqlStoreParamForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSqlStoreParamForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetSqlStoreParamForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSqlStoreParamForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSqlStoreParamForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetSqlStoreParamForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetSqlStoreParamForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetSqlStoreParamForViewDto {
    totalCount: number;
    items: GetSqlStoreParamForViewDto[] | undefined;
}

export class CreateOrEditSqlStoreParamDto implements ICreateOrEditSqlStoreParamDto {
    sqlConfigId: number | undefined;
    code: string | undefined;
    format: string | undefined;
    name: string | undefined;
    isActive: boolean;
    valueString: string | undefined;
    valueInt: number | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditSqlStoreParamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sqlConfigId = data["sqlConfigId"];
            this.code = data["code"];
            this.format = data["format"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.valueString = data["valueString"];
            this.valueInt = data["valueInt"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSqlStoreParamDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSqlStoreParamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sqlConfigId"] = this.sqlConfigId;
        data["code"] = this.code;
        data["format"] = this.format;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["valueString"] = this.valueString;
        data["valueInt"] = this.valueInt;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditSqlStoreParamDto {
        const json = this.toJSON();
        let result = new CreateOrEditSqlStoreParamDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditSqlStoreParamDto {
    sqlConfigId: number | undefined;
    code: string | undefined;
    format: string | undefined;
    name: string | undefined;
    isActive: boolean;
    valueString: string | undefined;
    valueInt: number | undefined;
    id: number | undefined;
}

export class GetSqlStoreParamForEditOutput implements IGetSqlStoreParamForEditOutput {
    sqlStoreParam: CreateOrEditSqlStoreParamDto;

    constructor(data?: IGetSqlStoreParamForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sqlStoreParam = new CreateOrEditSqlStoreParamDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.sqlStoreParam = data["sqlStoreParam"] ? CreateOrEditSqlStoreParamDto.fromJS(data["sqlStoreParam"]) : new CreateOrEditSqlStoreParamDto();
        }
    }

    static fromJS(data: any): GetSqlStoreParamForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSqlStoreParamForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sqlStoreParam"] = this.sqlStoreParam ? this.sqlStoreParam.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSqlStoreParamForEditOutput {
        const json = this.toJSON();
        let result = new GetSqlStoreParamForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSqlStoreParamForEditOutput {
    sqlStoreParam: CreateOrEditSqlStoreParamDto;
}

export class StoreDatasourceDto implements IStoreDatasourceDto {
    nameStore: string | undefined;
    key: string | undefined;
    value: string | undefined;
    dynamicDatasourceId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IStoreDatasourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nameStore = data["nameStore"];
            this.key = data["key"];
            this.value = data["value"];
            this.dynamicDatasourceId = data["dynamicDatasourceId"];
            this.order = data["order"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StoreDatasourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreDatasourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameStore"] = this.nameStore;
        data["key"] = this.key;
        data["value"] = this.value;
        data["dynamicDatasourceId"] = this.dynamicDatasourceId;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): StoreDatasourceDto {
        const json = this.toJSON();
        let result = new StoreDatasourceDto();
        result.init(json);
        return result;
    }
}

export interface IStoreDatasourceDto {
    nameStore: string | undefined;
    key: string | undefined;
    value: string | undefined;
    dynamicDatasourceId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number;
}

export class GetStoreDatasourceForViewDto implements IGetStoreDatasourceForViewDto {
    storeDatasource: StoreDatasourceDto;

    constructor(data?: IGetStoreDatasourceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.storeDatasource = new StoreDatasourceDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.storeDatasource = data["storeDatasource"] ? StoreDatasourceDto.fromJS(data["storeDatasource"]) : new StoreDatasourceDto();
        }
    }

    static fromJS(data: any): GetStoreDatasourceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreDatasourceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeDatasource"] = this.storeDatasource ? this.storeDatasource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetStoreDatasourceForViewDto {
        const json = this.toJSON();
        let result = new GetStoreDatasourceForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetStoreDatasourceForViewDto {
    storeDatasource: StoreDatasourceDto;
}

export class PagedResultDtoOfGetStoreDatasourceForViewDto implements IPagedResultDtoOfGetStoreDatasourceForViewDto {
    totalCount: number;
    items: GetStoreDatasourceForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreDatasourceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetStoreDatasourceForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreDatasourceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreDatasourceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetStoreDatasourceForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetStoreDatasourceForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetStoreDatasourceForViewDto {
    totalCount: number;
    items: GetStoreDatasourceForViewDto[] | undefined;
}

export class CreateOrEditStoreDatasourceDto implements ICreateOrEditStoreDatasourceDto {
    nameStore: string | undefined;
    key: string | undefined;
    value: string | undefined;
    dynamicDatasourceId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number | undefined;

    constructor(data?: ICreateOrEditStoreDatasourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nameStore = data["nameStore"];
            this.key = data["key"];
            this.value = data["value"];
            this.dynamicDatasourceId = data["dynamicDatasourceId"];
            this.order = data["order"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreDatasourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreDatasourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameStore"] = this.nameStore;
        data["key"] = this.key;
        data["value"] = this.value;
        data["dynamicDatasourceId"] = this.dynamicDatasourceId;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditStoreDatasourceDto {
        const json = this.toJSON();
        let result = new CreateOrEditStoreDatasourceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditStoreDatasourceDto {
    nameStore: string | undefined;
    key: string | undefined;
    value: string | undefined;
    dynamicDatasourceId: number | undefined;
    order: number | undefined;
    isActive: boolean;
    id: number | undefined;
}

export class GetStoreDatasourceForEditOutput implements IGetStoreDatasourceForEditOutput {
    storeDatasource: CreateOrEditStoreDatasourceDto;

    constructor(data?: IGetStoreDatasourceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.storeDatasource = new CreateOrEditStoreDatasourceDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.storeDatasource = data["storeDatasource"] ? CreateOrEditStoreDatasourceDto.fromJS(data["storeDatasource"]) : new CreateOrEditStoreDatasourceDto();
        }
    }

    static fromJS(data: any): GetStoreDatasourceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreDatasourceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeDatasource"] = this.storeDatasource ? this.storeDatasource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetStoreDatasourceForEditOutput {
        const json = this.toJSON();
        let result = new GetStoreDatasourceForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetStoreDatasourceForEditOutput {
    storeDatasource: CreateOrEditStoreDatasourceDto;
}

export class StripeConfirmPaymentInput implements IStripeConfirmPaymentInput {
    paymentId: number;
    stripeToken: string | undefined;

    constructor(data?: IStripeConfirmPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeConfirmPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfirmPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }

    clone(): StripeConfirmPaymentInput {
        const json = this.toJSON();
        let result = new StripeConfirmPaymentInput();
        result.init(json);
        return result;
    }
}

export interface IStripeConfirmPaymentInput {
    paymentId: number;
    stripeToken: string | undefined;
}

export class StripeCreateSubscriptionInput implements IStripeCreateSubscriptionInput {
    paymentId: number;
    stripeToken: string | undefined;

    constructor(data?: IStripeCreateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeCreateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }

    clone(): StripeCreateSubscriptionInput {
        const json = this.toJSON();
        let result = new StripeCreateSubscriptionInput();
        result.init(json);
        return result;
    }
}

export interface IStripeCreateSubscriptionInput {
    paymentId: number;
    stripeToken: string | undefined;
}

export class StripeUpdateSubscriptionInput implements IStripeUpdateSubscriptionInput {
    paymentId: number;

    constructor(data?: IStripeUpdateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): StripeUpdateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeUpdateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        return data; 
    }

    clone(): StripeUpdateSubscriptionInput {
        const json = this.toJSON();
        let result = new StripeUpdateSubscriptionInput();
        result.init(json);
        return result;
    }
}

export interface IStripeUpdateSubscriptionInput {
    paymentId: number;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.publishableKey = data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data; 
    }

    clone(): StripeConfigurationDto {
        const json = this.toJSON();
        let result = new StripeConfigurationDto();
        result.init(json);
        return result;
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class SYS_CODEMASTERSDto implements ISYS_CODEMASTERSDto {
    prefix: string | undefined;
    curValue: number | undefined;
    description: string | undefined;
    active: string | undefined;
    id: number;

    constructor(data?: ISYS_CODEMASTERSDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.prefix = data["prefix"];
            this.curValue = data["curValue"];
            this.description = data["description"];
            this.active = data["active"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SYS_CODEMASTERSDto {
        data = typeof data === 'object' ? data : {};
        let result = new SYS_CODEMASTERSDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prefix"] = this.prefix;
        data["curValue"] = this.curValue;
        data["description"] = this.description;
        data["active"] = this.active;
        data["id"] = this.id;
        return data; 
    }

    clone(): SYS_CODEMASTERSDto {
        const json = this.toJSON();
        let result = new SYS_CODEMASTERSDto();
        result.init(json);
        return result;
    }
}

export interface ISYS_CODEMASTERSDto {
    prefix: string | undefined;
    curValue: number | undefined;
    description: string | undefined;
    active: string | undefined;
    id: number;
}

export class GetSYS_CODEMASTERSForViewDto implements IGetSYS_CODEMASTERSForViewDto {
    syS_CODEMASTERS: SYS_CODEMASTERSDto;

    constructor(data?: IGetSYS_CODEMASTERSForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.syS_CODEMASTERS = new SYS_CODEMASTERSDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.syS_CODEMASTERS = data["syS_CODEMASTERS"] ? SYS_CODEMASTERSDto.fromJS(data["syS_CODEMASTERS"]) : new SYS_CODEMASTERSDto();
        }
    }

    static fromJS(data: any): GetSYS_CODEMASTERSForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSYS_CODEMASTERSForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syS_CODEMASTERS"] = this.syS_CODEMASTERS ? this.syS_CODEMASTERS.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSYS_CODEMASTERSForViewDto {
        const json = this.toJSON();
        let result = new GetSYS_CODEMASTERSForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetSYS_CODEMASTERSForViewDto {
    syS_CODEMASTERS: SYS_CODEMASTERSDto;
}

export class PagedResultDtoOfGetSYS_CODEMASTERSForViewDto implements IPagedResultDtoOfGetSYS_CODEMASTERSForViewDto {
    totalCount: number;
    items: GetSYS_CODEMASTERSForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSYS_CODEMASTERSForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetSYS_CODEMASTERSForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSYS_CODEMASTERSForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSYS_CODEMASTERSForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetSYS_CODEMASTERSForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetSYS_CODEMASTERSForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetSYS_CODEMASTERSForViewDto {
    totalCount: number;
    items: GetSYS_CODEMASTERSForViewDto[] | undefined;
}

export class CreateOrEditSYS_CODEMASTERSDto implements ICreateOrEditSYS_CODEMASTERSDto {
    prefix: string | undefined;
    curValue: number | undefined;
    description: string | undefined;
    active: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditSYS_CODEMASTERSDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.prefix = data["prefix"];
            this.curValue = data["curValue"];
            this.description = data["description"];
            this.active = data["active"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSYS_CODEMASTERSDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSYS_CODEMASTERSDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prefix"] = this.prefix;
        data["curValue"] = this.curValue;
        data["description"] = this.description;
        data["active"] = this.active;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditSYS_CODEMASTERSDto {
        const json = this.toJSON();
        let result = new CreateOrEditSYS_CODEMASTERSDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditSYS_CODEMASTERSDto {
    prefix: string | undefined;
    curValue: number | undefined;
    description: string | undefined;
    active: string | undefined;
    id: number | undefined;
}

export class GetSYS_CODEMASTERSForEditOutput implements IGetSYS_CODEMASTERSForEditOutput {
    syS_CODEMASTERS: CreateOrEditSYS_CODEMASTERSDto;

    constructor(data?: IGetSYS_CODEMASTERSForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.syS_CODEMASTERS = new CreateOrEditSYS_CODEMASTERSDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.syS_CODEMASTERS = data["syS_CODEMASTERS"] ? CreateOrEditSYS_CODEMASTERSDto.fromJS(data["syS_CODEMASTERS"]) : new CreateOrEditSYS_CODEMASTERSDto();
        }
    }

    static fromJS(data: any): GetSYS_CODEMASTERSForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSYS_CODEMASTERSForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syS_CODEMASTERS"] = this.syS_CODEMASTERS ? this.syS_CODEMASTERS.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSYS_CODEMASTERSForEditOutput {
        const json = this.toJSON();
        let result = new GetSYS_CODEMASTERSForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSYS_CODEMASTERSForEditOutput {
    syS_CODEMASTERS: CreateOrEditSYS_CODEMASTERSDto;
}

export class SYS_PREFIXDto implements ISYS_PREFIXDto {
    code: string | undefined;
    prefix: string | undefined;
    description: string | undefined;
    id: number;

    constructor(data?: ISYS_PREFIXDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.prefix = data["prefix"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SYS_PREFIXDto {
        data = typeof data === 'object' ? data : {};
        let result = new SYS_PREFIXDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["prefix"] = this.prefix;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): SYS_PREFIXDto {
        const json = this.toJSON();
        let result = new SYS_PREFIXDto();
        result.init(json);
        return result;
    }
}

export interface ISYS_PREFIXDto {
    code: string | undefined;
    prefix: string | undefined;
    description: string | undefined;
    id: number;
}

export class GetSYS_PREFIXForViewDto implements IGetSYS_PREFIXForViewDto {
    syS_PREFIX: SYS_PREFIXDto;

    constructor(data?: IGetSYS_PREFIXForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.syS_PREFIX = new SYS_PREFIXDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.syS_PREFIX = data["syS_PREFIX"] ? SYS_PREFIXDto.fromJS(data["syS_PREFIX"]) : new SYS_PREFIXDto();
        }
    }

    static fromJS(data: any): GetSYS_PREFIXForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSYS_PREFIXForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syS_PREFIX"] = this.syS_PREFIX ? this.syS_PREFIX.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSYS_PREFIXForViewDto {
        const json = this.toJSON();
        let result = new GetSYS_PREFIXForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetSYS_PREFIXForViewDto {
    syS_PREFIX: SYS_PREFIXDto;
}

export class PagedResultDtoOfGetSYS_PREFIXForViewDto implements IPagedResultDtoOfGetSYS_PREFIXForViewDto {
    totalCount: number;
    items: GetSYS_PREFIXForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSYS_PREFIXForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetSYS_PREFIXForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSYS_PREFIXForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSYS_PREFIXForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetSYS_PREFIXForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetSYS_PREFIXForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetSYS_PREFIXForViewDto {
    totalCount: number;
    items: GetSYS_PREFIXForViewDto[] | undefined;
}

export class CreateOrEditSYS_PREFIXDto implements ICreateOrEditSYS_PREFIXDto {
    code: string | undefined;
    prefix: string | undefined;
    description: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditSYS_PREFIXDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.prefix = data["prefix"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSYS_PREFIXDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSYS_PREFIXDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["prefix"] = this.prefix;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditSYS_PREFIXDto {
        const json = this.toJSON();
        let result = new CreateOrEditSYS_PREFIXDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditSYS_PREFIXDto {
    code: string | undefined;
    prefix: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetSYS_PREFIXForEditOutput implements IGetSYS_PREFIXForEditOutput {
    syS_PREFIX: CreateOrEditSYS_PREFIXDto;

    constructor(data?: IGetSYS_PREFIXForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.syS_PREFIX = new CreateOrEditSYS_PREFIXDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.syS_PREFIX = data["syS_PREFIX"] ? CreateOrEditSYS_PREFIXDto.fromJS(data["syS_PREFIX"]) : new CreateOrEditSYS_PREFIXDto();
        }
    }

    static fromJS(data: any): GetSYS_PREFIXForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSYS_PREFIXForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syS_PREFIX"] = this.syS_PREFIX ? this.syS_PREFIX.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSYS_PREFIXForEditOutput {
        const json = this.toJSON();
        let result = new GetSYS_PREFIXForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSYS_PREFIXForEditOutput {
    syS_PREFIX: CreateOrEditSYS_PREFIXDto;
}

export class GetTemplateForViewDto implements IGetTemplateForViewDto {
    template: TemplateDto;

    constructor(data?: IGetTemplateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.template = new TemplateDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.template = data["template"] ? TemplateDto.fromJS(data["template"]) : new TemplateDto();
        }
    }

    static fromJS(data: any): GetTemplateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTemplateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTemplateForViewDto {
        const json = this.toJSON();
        let result = new GetTemplateForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetTemplateForViewDto {
    template: TemplateDto;
}

export class PagedResultDtoOfGetTemplateForViewDto implements IPagedResultDtoOfGetTemplateForViewDto {
    totalCount: number;
    items: GetTemplateForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTemplateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetTemplateForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTemplateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTemplateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetTemplateForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetTemplateForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetTemplateForViewDto {
    totalCount: number;
    items: GetTemplateForViewDto[] | undefined;
}

export class CreateOrEditTemplateDto implements ICreateOrEditTemplateDto {
    maTemplate: string | undefined;
    tenTemplate: string | undefined;
    linkTemplate: string | undefined;
    ghiChu: string | undefined;
    noiDung: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maTemplate = data["maTemplate"];
            this.tenTemplate = data["tenTemplate"];
            this.linkTemplate = data["linkTemplate"];
            this.ghiChu = data["ghiChu"];
            this.noiDung = data["noiDung"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maTemplate"] = this.maTemplate;
        data["tenTemplate"] = this.tenTemplate;
        data["linkTemplate"] = this.linkTemplate;
        data["ghiChu"] = this.ghiChu;
        data["noiDung"] = this.noiDung;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditTemplateDto {
        const json = this.toJSON();
        let result = new CreateOrEditTemplateDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditTemplateDto {
    maTemplate: string | undefined;
    tenTemplate: string | undefined;
    linkTemplate: string | undefined;
    ghiChu: string | undefined;
    noiDung: string | undefined;
    id: number | undefined;
}

export class GetTemplateForEditOutput implements IGetTemplateForEditOutput {
    template: CreateOrEditTemplateDto;

    constructor(data?: IGetTemplateForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.template = new CreateOrEditTemplateDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.template = data["template"] ? CreateOrEditTemplateDto.fromJS(data["template"]) : new CreateOrEditTemplateDto();
        }
    }

    static fromJS(data: any): GetTemplateForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTemplateForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTemplateForEditOutput {
        const json = this.toJSON();
        let result = new GetTemplateForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTemplateForEditOutput {
    template: CreateOrEditTemplateDto;
}

export class TenantListDto implements ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean;
    id: number;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantListDto {
        const json = this.toJSON();
        let result = new TenantListDto();
        result.init(json);
        return result;
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTenantListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[] | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName: string | undefined;
    name: string | undefined;
    adminEmailAddress: string | undefined;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }

    clone(): CreateTenantInput {
        const json = this.toJSON();
        let result = new CreateTenantInput();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantInput {
    tenancyName: string | undefined;
    name: string | undefined;
    adminEmailAddress: string | undefined;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName: string | undefined;
    name: string | undefined;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
    id: number;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantEditDto {
        const json = this.toJSON();
        let result = new TenantEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantEditDto {
    tenancyName: string | undefined;
    name: string | undefined;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetTenantFeaturesEditOutput {
        const json = this.toJSON();
        let result = new GetTenantFeaturesEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[] | undefined;

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateTenantFeaturesInput {
        const json = this.toJSON();
        let result = new UpdateTenantFeaturesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[] | undefined;
}

export class EntityDto implements IEntityDto {
    id: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDto {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    id: number;
}

export class MemberActivity implements IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number;
    closed: number;
    rate: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }

    clone(): MemberActivity {
        const json = this.toJSON();
        let result = new MemberActivity();
        result.init(json);
        return result;
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number;
    closed: number;
    rate: string | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["memberActivities"] && data["memberActivities"].constructor === Array) {
                this.memberActivities = [];
                for (let item of data["memberActivities"])
                    this.memberActivities.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.memberActivities && this.memberActivities.constructor === Array) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetMemberActivityOutput {
        const json = this.toJSON();
        let result = new GetMemberActivityOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export enum SalesSummaryDatePeriod {
    Daily = 1, 
    Weekly = 2, 
    Monthly = 3, 
}

export class SalesSummaryData implements ISalesSummaryData {
    period: string | undefined;
    sales: number;
    profit: number;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }

    clone(): SalesSummaryData {
        const json = this.toJSON();
        let result = new SalesSummaryData();
        result.init(json);
        return result;
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number;
    profit: number;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [];
                for (let item of data["dailySales"])
                    this.dailySales.push(item);
            }
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [];
                for (let item of data["profitShares"])
                    this.profitShares.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }

    clone(): GetDashboardDataOutput {
        const json = this.toJSON();
        let result = new GetDashboardDataOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class GetTopStatsOutput implements IGetTopStatsOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;

    constructor(data?: IGetTopStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
        }
    }

    static fromJS(data: any): GetTopStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTopStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        return data; 
    }

    clone(): GetTopStatsOutput {
        const json = this.toJSON();
        let result = new GetTopStatsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTopStatsOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
}

export class GetProfitShareOutput implements IGetProfitShareOutput {
    profitShares: number[] | undefined;

    constructor(data?: IGetProfitShareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [];
                for (let item of data["profitShares"])
                    this.profitShares.push(item);
            }
        }
    }

    static fromJS(data: any): GetProfitShareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfitShareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }

    clone(): GetProfitShareOutput {
        const json = this.toJSON();
        let result = new GetProfitShareOutput();
        result.init(json);
        return result;
    }
}

export interface IGetProfitShareOutput {
    profitShares: number[] | undefined;
}

export class GetDailySalesOutput implements IGetDailySalesOutput {
    dailySales: number[] | undefined;

    constructor(data?: IGetDailySalesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [];
                for (let item of data["dailySales"])
                    this.dailySales.push(item);
            }
        }
    }

    static fromJS(data: any): GetDailySalesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDailySalesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        return data; 
    }

    clone(): GetDailySalesOutput {
        const json = this.toJSON();
        let result = new GetDailySalesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDailySalesOutput {
    dailySales: number[] | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    salesSummary: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetSalesSummaryOutput {
        const json = this.toJSON();
        let result = new GetSalesSummaryOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSalesSummaryOutput {
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    salesSummary: SalesSummaryData[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName: string | undefined;
    sales: number;
    change: number[] | undefined;
    averagePrice: number;
    totalPrice: number;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.sales = data["sales"];
            if (data["change"] && data["change"].constructor === Array) {
                this.change = [];
                for (let item of data["change"])
                    this.change.push(item);
            }
            this.averagePrice = data["averagePrice"];
            this.totalPrice = data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (this.change && this.change.constructor === Array) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }

    clone(): RegionalStatCountry {
        const json = this.toJSON();
        let result = new RegionalStatCountry();
        result.init(json);
        return result;
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number;
    change: number[] | undefined;
    averagePrice: number;
    totalPrice: number;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["stats"] && data["stats"].constructor === Array) {
                this.stats = [];
                for (let item of data["stats"])
                    this.stats.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.stats && this.stats.constructor === Array) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetRegionalStatsOutput {
        const json = this.toJSON();
        let result = new GetRegionalStatsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }

    clone(): GetGeneralStatsOutput {
        const json = this.toJSON();
        let result = new GetGeneralStatsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
}

export enum SubscriptionStartType {
    Free = 1, 
    Trial = 2, 
    Paid = 3, 
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName: string | undefined;
    name: string | undefined;
    adminEmailAddress: string | undefined;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType;
    editionId: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.editionId = data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data; 
    }

    clone(): RegisterTenantInput {
        const json = this.toJSON();
        let result = new RegisterTenantInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantInput {
    tenancyName: string | undefined;
    name: string | undefined;
    adminEmailAddress: string | undefined;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType;
    editionId: number | undefined;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId: number;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }

    clone(): RegisterTenantOutput {
        const json = this.toJSON();
        let result = new RegisterTenantOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantOutput {
    tenantId: number;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;
}

export class IInputType implements IIInputType {
    name: string | undefined;
    attributes: { [key: string] : Anonymous4; } | undefined;
    validator: IValueValidator;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.validator = new IValueValidator();
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key] ? Anonymous4.fromJS(data["attributes"][key]) : new Anonymous4();
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : new IValueValidator();
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }

    clone(): IInputType {
        const json = this.toJSON();
        let result = new IInputType();
        result.init(json);
        return result;
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string] : Anonymous4; } | undefined;
    validator: IValueValidator;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType;
    textHtmlColor: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.inputType = new IInputType();
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : new IInputType();
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }

    clone(): FlatFeatureSelectDto {
        const json = this.toJSON();
        let result = new FlatFeatureSelectDto();
        result.init(json);
        return result;
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition: EditionSelectDto;
    featureValues: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionSelectDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : new EditionSelectDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EditionWithFeaturesDto {
        const json = this.toJSON();
        let result = new EditionWithFeaturesDto();
        result.init(json);
        return result;
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto;
    featureValues: NameValueDto[] | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"] && data["allFeatures"].constructor === Array) {
                this.allFeatures = [];
                for (let item of data["allFeatures"])
                    this.allFeatures.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (data["editionsWithFeatures"] && data["editionsWithFeatures"].constructor === Array) {
                this.editionsWithFeatures = [];
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures.push(EditionWithFeaturesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures && this.allFeatures.constructor === Array) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (this.editionsWithFeatures && this.editionsWithFeatures.constructor === Array) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EditionsSelectOutput {
        const json = this.toJSON();
        let result = new EditionsSelectOutput();
        result.init(json);
        return result;
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredUserActiveByDefault: boolean;
    isEmailConfirmationRequiredForLogin: boolean;
    useCaptchaOnRegistration: boolean;
    useCaptchaOnLogin: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sessionTimeOutSettings = new SessionTimeOutSettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.useCaptchaOnLogin = data["useCaptchaOnLogin"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
            this.sessionTimeOutSettings = data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(data["sessionTimeOutSettings"]) : new SessionTimeOutSettingsEditDto();
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TenantUserManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredUserActiveByDefault: boolean;
    isEmailConfirmationRequiredForLogin: boolean;
    useCaptchaOnRegistration: boolean;
    useCaptchaOnLogin: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useHostDefaultEmailSettings = data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }

    clone(): TenantEmailSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantEmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled: boolean;
    isEnabled: boolean;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }

    clone(): LdapSettingsEditDto {
        const json = this.toJSON();
        let result = new LdapSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean;
    isEnabled: boolean;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }

    clone(): TenantBillingSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }

    clone(): TenantOtherSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantOtherSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto;
    otherSettings: TenantOtherSettingsEditDto;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.email = new TenantEmailSettingsEditDto();
            this.ldap = new LdapSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
            this.billing = new TenantBillingSettingsEditDto();
            this.otherSettings = new TenantOtherSettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? TenantEmailSettingsEditDto.fromJS(data["email"]) : new TenantEmailSettingsEditDto();
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : new LdapSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : new TenantBillingSettingsEditDto();
            this.otherSettings = data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(data["otherSettings"]) : new TenantOtherSettingsEditDto();
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TenantSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto;
    otherSettings: TenantOtherSettingsEditDto;
}

export class GetDataAndColumnConfig_TextBook implements IGetDataAndColumnConfig_TextBook {
    listTextBook: ListTextBook[] | undefined;
    listColumnConfigTextBook: SqlConfigDetailDto[] | undefined;

    constructor(data?: IGetDataAndColumnConfig_TextBook) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["listTextBook"] && data["listTextBook"].constructor === Array) {
                this.listTextBook = [];
                for (let item of data["listTextBook"])
                    this.listTextBook.push(ListTextBook.fromJS(item));
            }
            if (data["listColumnConfigTextBook"] && data["listColumnConfigTextBook"].constructor === Array) {
                this.listColumnConfigTextBook = [];
                for (let item of data["listColumnConfigTextBook"])
                    this.listColumnConfigTextBook.push(SqlConfigDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDataAndColumnConfig_TextBook {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataAndColumnConfig_TextBook();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listTextBook && this.listTextBook.constructor === Array) {
            data["listTextBook"] = [];
            for (let item of this.listTextBook)
                data["listTextBook"].push(item.toJSON());
        }
        if (this.listColumnConfigTextBook && this.listColumnConfigTextBook.constructor === Array) {
            data["listColumnConfigTextBook"] = [];
            for (let item of this.listColumnConfigTextBook)
                data["listColumnConfigTextBook"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetDataAndColumnConfig_TextBook {
        const json = this.toJSON();
        let result = new GetDataAndColumnConfig_TextBook();
        result.init(json);
        return result;
    }
}

export interface IGetDataAndColumnConfig_TextBook {
    listTextBook: ListTextBook[] | undefined;
    listColumnConfigTextBook: SqlConfigDetailDto[] | undefined;
}

export class TextBookDto implements ITextBookDto {
    soDen: number;
    ngayDen: moment.Moment;
    soHieuGoc: string | undefined;
    coQuanBanHanh: string | undefined;
    trichYeu: string | undefined;
    nguoiChiDao: string | undefined;
    nguoi_DonVi: string | undefined;
    fileDinhKem: string | undefined;
    id: number;

    constructor(data?: ITextBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.soDen = data["soDen"];
            this.ngayDen = data["ngayDen"] ? moment(data["ngayDen"].toString()) : <any>undefined;
            this.soHieuGoc = data["soHieuGoc"];
            this.coQuanBanHanh = data["coQuanBanHanh"];
            this.trichYeu = data["trichYeu"];
            this.nguoiChiDao = data["nguoiChiDao"];
            this.nguoi_DonVi = data["nguoi_DonVi"];
            this.fileDinhKem = data["fileDinhKem"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TextBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["soDen"] = this.soDen;
        data["ngayDen"] = this.ngayDen ? this.ngayDen.toISOString() : <any>undefined;
        data["soHieuGoc"] = this.soHieuGoc;
        data["coQuanBanHanh"] = this.coQuanBanHanh;
        data["trichYeu"] = this.trichYeu;
        data["nguoiChiDao"] = this.nguoiChiDao;
        data["nguoi_DonVi"] = this.nguoi_DonVi;
        data["fileDinhKem"] = this.fileDinhKem;
        data["id"] = this.id;
        return data; 
    }

    clone(): TextBookDto {
        const json = this.toJSON();
        let result = new TextBookDto();
        result.init(json);
        return result;
    }
}

export interface ITextBookDto {
    soDen: number;
    ngayDen: moment.Moment;
    soHieuGoc: string | undefined;
    coQuanBanHanh: string | undefined;
    trichYeu: string | undefined;
    nguoiChiDao: string | undefined;
    nguoi_DonVi: string | undefined;
    fileDinhKem: string | undefined;
    id: number;
}

export class GetTextBookForViewDto implements IGetTextBookForViewDto {
    textBook: TextBookDto;

    constructor(data?: IGetTextBookForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.textBook = new TextBookDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.textBook = data["textBook"] ? TextBookDto.fromJS(data["textBook"]) : new TextBookDto();
        }
    }

    static fromJS(data: any): GetTextBookForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTextBookForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["textBook"] = this.textBook ? this.textBook.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTextBookForViewDto {
        const json = this.toJSON();
        let result = new GetTextBookForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetTextBookForViewDto {
    textBook: TextBookDto;
}

export class PagedResultDtoOfGetTextBookForViewDto implements IPagedResultDtoOfGetTextBookForViewDto {
    totalCount: number;
    items: GetTextBookForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTextBookForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetTextBookForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTextBookForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTextBookForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetTextBookForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetTextBookForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetTextBookForViewDto {
    totalCount: number;
    items: GetTextBookForViewDto[] | undefined;
}

export class CreateOrEditTextBookDto implements ICreateOrEditTextBookDto {
    soDen: number;
    ngayDen: moment.Moment;
    soHieuGoc: string | undefined;
    coQuanBanHanh: string | undefined;
    trichYeu: string | undefined;
    nguoiChiDao: string | undefined;
    nguoi_DonVi: string | undefined;
    fileDinhKem: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditTextBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.soDen = data["soDen"];
            this.ngayDen = data["ngayDen"] ? moment(data["ngayDen"].toString()) : <any>undefined;
            this.soHieuGoc = data["soHieuGoc"];
            this.coQuanBanHanh = data["coQuanBanHanh"];
            this.trichYeu = data["trichYeu"];
            this.nguoiChiDao = data["nguoiChiDao"];
            this.nguoi_DonVi = data["nguoi_DonVi"];
            this.fileDinhKem = data["fileDinhKem"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTextBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTextBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["soDen"] = this.soDen;
        data["ngayDen"] = this.ngayDen ? this.ngayDen.toISOString() : <any>undefined;
        data["soHieuGoc"] = this.soHieuGoc;
        data["coQuanBanHanh"] = this.coQuanBanHanh;
        data["trichYeu"] = this.trichYeu;
        data["nguoiChiDao"] = this.nguoiChiDao;
        data["nguoi_DonVi"] = this.nguoi_DonVi;
        data["fileDinhKem"] = this.fileDinhKem;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditTextBookDto {
        const json = this.toJSON();
        let result = new CreateOrEditTextBookDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditTextBookDto {
    soDen: number;
    ngayDen: moment.Moment;
    soHieuGoc: string | undefined;
    coQuanBanHanh: string | undefined;
    trichYeu: string | undefined;
    nguoiChiDao: string | undefined;
    nguoi_DonVi: string | undefined;
    fileDinhKem: string | undefined;
    id: number | undefined;
}

export class GetTextBookForEditOutput implements IGetTextBookForEditOutput {
    textBook: CreateOrEditTextBookDto;

    constructor(data?: IGetTextBookForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.textBook = new CreateOrEditTextBookDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.textBook = data["textBook"] ? CreateOrEditTextBookDto.fromJS(data["textBook"]) : new CreateOrEditTextBookDto();
        }
    }

    static fromJS(data: any): GetTextBookForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTextBookForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["textBook"] = this.textBook ? this.textBook.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTextBookForEditOutput {
        const json = this.toJSON();
        let result = new GetTextBookForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTextBookForEditOutput {
    textBook: CreateOrEditTextBookDto;
}

export enum SettingScopes {
    Application = 1, 
    Tenant = 2, 
    User = 4, 
    All = 7, 
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfNameValueDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class GetTinhThanhForViewDto implements IGetTinhThanhForViewDto {
    tinhThanh: TinhThanhDto;

    constructor(data?: IGetTinhThanhForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tinhThanh = new TinhThanhDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.tinhThanh = data["tinhThanh"] ? TinhThanhDto.fromJS(data["tinhThanh"]) : new TinhThanhDto();
        }
    }

    static fromJS(data: any): GetTinhThanhForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTinhThanhForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tinhThanh"] = this.tinhThanh ? this.tinhThanh.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTinhThanhForViewDto {
        const json = this.toJSON();
        let result = new GetTinhThanhForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetTinhThanhForViewDto {
    tinhThanh: TinhThanhDto;
}

export class PagedResultDtoOfGetTinhThanhForViewDto implements IPagedResultDtoOfGetTinhThanhForViewDto {
    totalCount: number;
    items: GetTinhThanhForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTinhThanhForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetTinhThanhForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTinhThanhForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTinhThanhForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetTinhThanhForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetTinhThanhForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetTinhThanhForViewDto {
    totalCount: number;
    items: GetTinhThanhForViewDto[] | undefined;
}

export class CreateOrEditTinhThanhDto implements ICreateOrEditTinhThanhDto {
    tenTinhThanh: string | undefined;
    maTinhThanh: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditTinhThanhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenTinhThanh = data["tenTinhThanh"];
            this.maTinhThanh = data["maTinhThanh"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTinhThanhDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTinhThanhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenTinhThanh"] = this.tenTinhThanh;
        data["maTinhThanh"] = this.maTinhThanh;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditTinhThanhDto {
        const json = this.toJSON();
        let result = new CreateOrEditTinhThanhDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditTinhThanhDto {
    tenTinhThanh: string | undefined;
    maTinhThanh: string | undefined;
    id: number | undefined;
}

export class GetTinhThanhForEditOutput implements IGetTinhThanhForEditOutput {
    tinhThanh: CreateOrEditTinhThanhDto;

    constructor(data?: IGetTinhThanhForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tinhThanh = new CreateOrEditTinhThanhDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.tinhThanh = data["tinhThanh"] ? CreateOrEditTinhThanhDto.fromJS(data["tinhThanh"]) : new CreateOrEditTinhThanhDto();
        }
    }

    static fromJS(data: any): GetTinhThanhForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTinhThanhForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tinhThanh"] = this.tinhThanh ? this.tinhThanh.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTinhThanhForEditOutput {
        const json = this.toJSON();
        let result = new GetTinhThanhForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTinhThanhForEditOutput {
    tinhThanh: CreateOrEditTinhThanhDto;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string | undefined;
    password: string | undefined;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    captchaResponse: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string | undefined;
    password: string | undefined;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    captchaResponse: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [];
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            this.refreshToken = data["refreshToken"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken: string | undefined;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        return data; 
    }

    clone(): RefreshTokenResult {
        const json = this.toJSON();
        let result = new RefreshTokenResult();
        result.init(json);
        return result;
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId: number;
    provider: string | undefined;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }

    clone(): SendTwoFactorAuthCodeModel {
        const json = this.toJSON();
        let result = new SendTwoFactorAuthCodeModel();
        result.init(json);
        return result;
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number;
    provider: string | undefined;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }

    clone(): ImpersonatedAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }

    clone(): SwitchedAccountAuthenticateResultModel {
        const json = this.toJSON();
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
            if (data["additionalParams"]) {
                this.additionalParams = {};
                for (let key in data["additionalParams"]) {
                    if (data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams[key] = data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string | undefined;
    providerKey: string | undefined;
    providerAccessCode: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string | undefined;
    providerKey: string | undefined;
    providerAccessCode: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
    returnUrl: string | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
    returnUrl: string | undefined;
}

export class TypeHandeDto implements ITypeHandeDto {
    name: string | undefined;
    id: number;

    constructor(data?: ITypeHandeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TypeHandeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TypeHandeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TypeHandeDto {
        const json = this.toJSON();
        let result = new TypeHandeDto();
        result.init(json);
        return result;
    }
}

export interface ITypeHandeDto {
    name: string | undefined;
    id: number;
}

export class GetTypeHandeForViewDto implements IGetTypeHandeForViewDto {
    typeHande: TypeHandeDto;

    constructor(data?: IGetTypeHandeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.typeHande = new TypeHandeDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.typeHande = data["typeHande"] ? TypeHandeDto.fromJS(data["typeHande"]) : new TypeHandeDto();
        }
    }

    static fromJS(data: any): GetTypeHandeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTypeHandeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeHande"] = this.typeHande ? this.typeHande.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTypeHandeForViewDto {
        const json = this.toJSON();
        let result = new GetTypeHandeForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetTypeHandeForViewDto {
    typeHande: TypeHandeDto;
}

export class PagedResultDtoOfGetTypeHandeForViewDto implements IPagedResultDtoOfGetTypeHandeForViewDto {
    totalCount: number;
    items: GetTypeHandeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTypeHandeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetTypeHandeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTypeHandeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTypeHandeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetTypeHandeForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetTypeHandeForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetTypeHandeForViewDto {
    totalCount: number;
    items: GetTypeHandeForViewDto[] | undefined;
}

export class CreateOrEditTypeHandeDto implements ICreateOrEditTypeHandeDto {
    name: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditTypeHandeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTypeHandeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTypeHandeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditTypeHandeDto {
        const json = this.toJSON();
        let result = new CreateOrEditTypeHandeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditTypeHandeDto {
    name: string | undefined;
    id: number | undefined;
}

export class GetTypeHandeForEditOutput implements IGetTypeHandeForEditOutput {
    typeHande: CreateOrEditTypeHandeDto;

    constructor(data?: IGetTypeHandeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.typeHande = new CreateOrEditTypeHandeDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.typeHande = data["typeHande"] ? CreateOrEditTypeHandeDto.fromJS(data["typeHande"]) : new CreateOrEditTypeHandeDto();
        }
    }

    static fromJS(data: any): GetTypeHandeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTypeHandeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeHande"] = this.typeHande ? this.typeHande.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTypeHandeForEditOutput {
        const json = this.toJSON();
        let result = new GetTypeHandeForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTypeHandeForEditOutput {
    typeHande: CreateOrEditTypeHandeDto;
}

export class GetTruongGiaoDichForViewDto implements IGetTruongGiaoDichForViewDto {
    truongGiaoDich: TruongGiaoDichDto;

    constructor(data?: IGetTruongGiaoDichForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.truongGiaoDich = new TruongGiaoDichDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.truongGiaoDich = data["truongGiaoDich"] ? TruongGiaoDichDto.fromJS(data["truongGiaoDich"]) : new TruongGiaoDichDto();
        }
    }

    static fromJS(data: any): GetTruongGiaoDichForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTruongGiaoDichForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["truongGiaoDich"] = this.truongGiaoDich ? this.truongGiaoDich.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTruongGiaoDichForViewDto {
        const json = this.toJSON();
        let result = new GetTruongGiaoDichForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetTruongGiaoDichForViewDto {
    truongGiaoDich: TruongGiaoDichDto;
}

export class PagedResultDtoOfGetTruongGiaoDichForViewDto implements IPagedResultDtoOfGetTruongGiaoDichForViewDto {
    totalCount: number;
    items: GetTruongGiaoDichForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTruongGiaoDichForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetTruongGiaoDichForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTruongGiaoDichForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTruongGiaoDichForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetTruongGiaoDichForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetTruongGiaoDichForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetTruongGiaoDichForViewDto {
    totalCount: number;
    items: GetTruongGiaoDichForViewDto[] | undefined;
}

export class CreateOrEditTruongGiaoDichDto implements ICreateOrEditTruongGiaoDichDto {
    code: string | undefined;
    cdName: string | undefined;
    value: string | undefined;
    ghiChu: string | undefined;
    setDefault: boolean;
    displayOrder: number | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditTruongGiaoDichDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.cdName = data["cdName"];
            this.value = data["value"];
            this.ghiChu = data["ghiChu"];
            this.setDefault = data["setDefault"];
            this.displayOrder = data["displayOrder"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTruongGiaoDichDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTruongGiaoDichDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["cdName"] = this.cdName;
        data["value"] = this.value;
        data["ghiChu"] = this.ghiChu;
        data["setDefault"] = this.setDefault;
        data["displayOrder"] = this.displayOrder;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditTruongGiaoDichDto {
        const json = this.toJSON();
        let result = new CreateOrEditTruongGiaoDichDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditTruongGiaoDichDto {
    code: string | undefined;
    cdName: string | undefined;
    value: string | undefined;
    ghiChu: string | undefined;
    setDefault: boolean;
    displayOrder: number | undefined;
    id: number | undefined;
}

export class GetTruongGiaoDichForEditOutput implements IGetTruongGiaoDichForEditOutput {
    truongGiaoDich: CreateOrEditTruongGiaoDichDto;

    constructor(data?: IGetTruongGiaoDichForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.truongGiaoDich = new CreateOrEditTruongGiaoDichDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.truongGiaoDich = data["truongGiaoDich"] ? CreateOrEditTruongGiaoDichDto.fromJS(data["truongGiaoDich"]) : new CreateOrEditTruongGiaoDichDto();
        }
    }

    static fromJS(data: any): GetTruongGiaoDichForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTruongGiaoDichForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["truongGiaoDich"] = this.truongGiaoDich ? this.truongGiaoDich.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTruongGiaoDichForEditOutput {
        const json = this.toJSON();
        let result = new GetTruongGiaoDichForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTruongGiaoDichForEditOutput {
    truongGiaoDich: CreateOrEditTruongGiaoDichDto;
}

export class UngVienDto implements IUngVienDto {
    stt: number;
    maUngVien: string | undefined;
    hoVaTen: string | undefined;
    donViCongTacID: number | undefined;
    viTriUngTuyenCode: string | undefined;
    kenhTuyenDungCode: string | undefined;
    gioiTinhCode: string | undefined;
    ngaySinh: moment.Moment | undefined;
    createTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    soCMND: string | undefined;
    ngayCap: moment.Moment | undefined;
    noiCap: string | undefined;
    tinhThanhID: number | undefined;
    tinhTrangHonNhanCode: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    trinhDoVanHoa: string | undefined;
    noiDaoTaoID: number | undefined;
    khoa: string | undefined;
    chuyenNganh: string | undefined;
    xepLoaiCode: string | undefined;
    namTotNghiep: number | undefined;
    trangThaiCode: string | undefined;
    tienDoTuyenDungCode: string | undefined;
    tepDinhKem: string | undefined;
    recorD_STATUS: string | undefined;
    markeR_ID: number | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: number | undefined;
    approvE_DT: moment.Moment | undefined;
    dienThoai: string | undefined;
    email: string | undefined;
    diaChi: string | undefined;
    time1: string | undefined;
    day1: moment.Moment | undefined;
    time2: string | undefined;
    day2: moment.Moment | undefined;
    time3: string | undefined;
    day3: moment.Moment | undefined;
    note: string | undefined;
    tenCTY: string | undefined;
    nvPhuTrach: string | undefined;
    maNguoiPheDuyet: number | undefined;
    ngayPheDuyet: moment.Moment | undefined;
    dungLuong: string | undefined;
    tieuDe: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isCheckTime: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUngVienDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.stt = data["stt"];
            this.maUngVien = data["maUngVien"];
            this.hoVaTen = data["hoVaTen"];
            this.donViCongTacID = data["donViCongTacID"];
            this.viTriUngTuyenCode = data["viTriUngTuyenCode"];
            this.kenhTuyenDungCode = data["kenhTuyenDungCode"];
            this.gioiTinhCode = data["gioiTinhCode"];
            this.ngaySinh = data["ngaySinh"] ? moment(data["ngaySinh"].toString()) : <any>undefined;
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.soCMND = data["soCMND"];
            this.ngayCap = data["ngayCap"] ? moment(data["ngayCap"].toString()) : <any>undefined;
            this.noiCap = data["noiCap"];
            this.tinhThanhID = data["tinhThanhID"];
            this.tinhTrangHonNhanCode = data["tinhTrangHonNhanCode"];
            this.trinhDoDaoTaoCode = data["trinhDoDaoTaoCode"];
            this.trinhDoVanHoa = data["trinhDoVanHoa"];
            this.noiDaoTaoID = data["noiDaoTaoID"];
            this.khoa = data["khoa"];
            this.chuyenNganh = data["chuyenNganh"];
            this.xepLoaiCode = data["xepLoaiCode"];
            this.namTotNghiep = data["namTotNghiep"];
            this.trangThaiCode = data["trangThaiCode"];
            this.tienDoTuyenDungCode = data["tienDoTuyenDungCode"];
            this.tepDinhKem = data["tepDinhKem"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.markeR_ID = data["markeR_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.dienThoai = data["dienThoai"];
            this.email = data["email"];
            this.diaChi = data["diaChi"];
            this.time1 = data["time1"];
            this.day1 = data["day1"] ? moment(data["day1"].toString()) : <any>undefined;
            this.time2 = data["time2"];
            this.day2 = data["day2"] ? moment(data["day2"].toString()) : <any>undefined;
            this.time3 = data["time3"];
            this.day3 = data["day3"] ? moment(data["day3"].toString()) : <any>undefined;
            this.note = data["note"];
            this.tenCTY = data["tenCTY"];
            this.nvPhuTrach = data["nvPhuTrach"];
            this.maNguoiPheDuyet = data["maNguoiPheDuyet"];
            this.ngayPheDuyet = data["ngayPheDuyet"] ? moment(data["ngayPheDuyet"].toString()) : <any>undefined;
            this.dungLuong = data["dungLuong"];
            this.tieuDe = data["tieuDe"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isCheckTime = data["isCheckTime"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UngVienDto {
        data = typeof data === 'object' ? data : {};
        let result = new UngVienDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stt"] = this.stt;
        data["maUngVien"] = this.maUngVien;
        data["hoVaTen"] = this.hoVaTen;
        data["donViCongTacID"] = this.donViCongTacID;
        data["viTriUngTuyenCode"] = this.viTriUngTuyenCode;
        data["kenhTuyenDungCode"] = this.kenhTuyenDungCode;
        data["gioiTinhCode"] = this.gioiTinhCode;
        data["ngaySinh"] = this.ngaySinh ? this.ngaySinh.toISOString() : <any>undefined;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["soCMND"] = this.soCMND;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["noiCap"] = this.noiCap;
        data["tinhThanhID"] = this.tinhThanhID;
        data["tinhTrangHonNhanCode"] = this.tinhTrangHonNhanCode;
        data["trinhDoDaoTaoCode"] = this.trinhDoDaoTaoCode;
        data["trinhDoVanHoa"] = this.trinhDoVanHoa;
        data["noiDaoTaoID"] = this.noiDaoTaoID;
        data["khoa"] = this.khoa;
        data["chuyenNganh"] = this.chuyenNganh;
        data["xepLoaiCode"] = this.xepLoaiCode;
        data["namTotNghiep"] = this.namTotNghiep;
        data["trangThaiCode"] = this.trangThaiCode;
        data["tienDoTuyenDungCode"] = this.tienDoTuyenDungCode;
        data["tepDinhKem"] = this.tepDinhKem;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["markeR_ID"] = this.markeR_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["dienThoai"] = this.dienThoai;
        data["email"] = this.email;
        data["diaChi"] = this.diaChi;
        data["time1"] = this.time1;
        data["day1"] = this.day1 ? this.day1.toISOString() : <any>undefined;
        data["time2"] = this.time2;
        data["day2"] = this.day2 ? this.day2.toISOString() : <any>undefined;
        data["time3"] = this.time3;
        data["day3"] = this.day3 ? this.day3.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["tenCTY"] = this.tenCTY;
        data["nvPhuTrach"] = this.nvPhuTrach;
        data["maNguoiPheDuyet"] = this.maNguoiPheDuyet;
        data["ngayPheDuyet"] = this.ngayPheDuyet ? this.ngayPheDuyet.toISOString() : <any>undefined;
        data["dungLuong"] = this.dungLuong;
        data["tieuDe"] = this.tieuDe;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isCheckTime"] = this.isCheckTime;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UngVienDto {
        const json = this.toJSON();
        let result = new UngVienDto();
        result.init(json);
        return result;
    }
}

export interface IUngVienDto {
    stt: number;
    maUngVien: string | undefined;
    hoVaTen: string | undefined;
    donViCongTacID: number | undefined;
    viTriUngTuyenCode: string | undefined;
    kenhTuyenDungCode: string | undefined;
    gioiTinhCode: string | undefined;
    ngaySinh: moment.Moment | undefined;
    createTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    soCMND: string | undefined;
    ngayCap: moment.Moment | undefined;
    noiCap: string | undefined;
    tinhThanhID: number | undefined;
    tinhTrangHonNhanCode: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    trinhDoVanHoa: string | undefined;
    noiDaoTaoID: number | undefined;
    khoa: string | undefined;
    chuyenNganh: string | undefined;
    xepLoaiCode: string | undefined;
    namTotNghiep: number | undefined;
    trangThaiCode: string | undefined;
    tienDoTuyenDungCode: string | undefined;
    tepDinhKem: string | undefined;
    recorD_STATUS: string | undefined;
    markeR_ID: number | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: number | undefined;
    approvE_DT: moment.Moment | undefined;
    dienThoai: string | undefined;
    email: string | undefined;
    diaChi: string | undefined;
    time1: string | undefined;
    day1: moment.Moment | undefined;
    time2: string | undefined;
    day2: moment.Moment | undefined;
    time3: string | undefined;
    day3: moment.Moment | undefined;
    note: string | undefined;
    tenCTY: string | undefined;
    nvPhuTrach: string | undefined;
    maNguoiPheDuyet: number | undefined;
    ngayPheDuyet: moment.Moment | undefined;
    dungLuong: string | undefined;
    tieuDe: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isCheckTime: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class GetUngVienForViewDto implements IGetUngVienForViewDto {
    ungVien: UngVienDto;
    viTriUngTuyenValue: string | undefined;
    kenhTuyenDungValue: string | undefined;
    gioiTinhValue: string | undefined;
    tinhTrangHonNhanValue: string | undefined;
    trinhDoDaoTaoValue: string | undefined;
    xepLoaiValue: string | undefined;
    trangThaiValue: string | undefined;
    tienDoTuyenDungValue: string | undefined;
    noiDaoTaoValue: string | undefined;
    tinhThanhValue: string | undefined;

    constructor(data?: IGetUngVienForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ungVien = new UngVienDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ungVien = data["ungVien"] ? UngVienDto.fromJS(data["ungVien"]) : new UngVienDto();
            this.viTriUngTuyenValue = data["viTriUngTuyenValue"];
            this.kenhTuyenDungValue = data["kenhTuyenDungValue"];
            this.gioiTinhValue = data["gioiTinhValue"];
            this.tinhTrangHonNhanValue = data["tinhTrangHonNhanValue"];
            this.trinhDoDaoTaoValue = data["trinhDoDaoTaoValue"];
            this.xepLoaiValue = data["xepLoaiValue"];
            this.trangThaiValue = data["trangThaiValue"];
            this.tienDoTuyenDungValue = data["tienDoTuyenDungValue"];
            this.noiDaoTaoValue = data["noiDaoTaoValue"];
            this.tinhThanhValue = data["tinhThanhValue"];
        }
    }

    static fromJS(data: any): GetUngVienForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUngVienForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ungVien"] = this.ungVien ? this.ungVien.toJSON() : <any>undefined;
        data["viTriUngTuyenValue"] = this.viTriUngTuyenValue;
        data["kenhTuyenDungValue"] = this.kenhTuyenDungValue;
        data["gioiTinhValue"] = this.gioiTinhValue;
        data["tinhTrangHonNhanValue"] = this.tinhTrangHonNhanValue;
        data["trinhDoDaoTaoValue"] = this.trinhDoDaoTaoValue;
        data["xepLoaiValue"] = this.xepLoaiValue;
        data["trangThaiValue"] = this.trangThaiValue;
        data["tienDoTuyenDungValue"] = this.tienDoTuyenDungValue;
        data["noiDaoTaoValue"] = this.noiDaoTaoValue;
        data["tinhThanhValue"] = this.tinhThanhValue;
        return data; 
    }

    clone(): GetUngVienForViewDto {
        const json = this.toJSON();
        let result = new GetUngVienForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetUngVienForViewDto {
    ungVien: UngVienDto;
    viTriUngTuyenValue: string | undefined;
    kenhTuyenDungValue: string | undefined;
    gioiTinhValue: string | undefined;
    tinhTrangHonNhanValue: string | undefined;
    trinhDoDaoTaoValue: string | undefined;
    xepLoaiValue: string | undefined;
    trangThaiValue: string | undefined;
    tienDoTuyenDungValue: string | undefined;
    noiDaoTaoValue: string | undefined;
    tinhThanhValue: string | undefined;
}

export class PagedFilterResultDtoOfGetUngVienForViewDto implements IPagedFilterResultDtoOfGetUngVienForViewDto {
    totalCount: number;
    items: GetUngVienForViewDto[] | undefined;

    constructor(data?: IPagedFilterResultDtoOfGetUngVienForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetUngVienForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedFilterResultDtoOfGetUngVienForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedFilterResultDtoOfGetUngVienForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedFilterResultDtoOfGetUngVienForViewDto {
        const json = this.toJSON();
        let result = new PagedFilterResultDtoOfGetUngVienForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedFilterResultDtoOfGetUngVienForViewDto {
    totalCount: number;
    items: GetUngVienForViewDto[] | undefined;
}

export class CreateOrEditUngVienInput implements ICreateOrEditUngVienInput {
    ungVien: CreateOrEditUngVienDto;
    lichSuUpLoad: LichSuUploadNewDto[] | undefined;

    constructor(data?: ICreateOrEditUngVienInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ungVien = new CreateOrEditUngVienDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ungVien = data["ungVien"] ? CreateOrEditUngVienDto.fromJS(data["ungVien"]) : new CreateOrEditUngVienDto();
            if (data["lichSuUpLoad"] && data["lichSuUpLoad"].constructor === Array) {
                this.lichSuUpLoad = [];
                for (let item of data["lichSuUpLoad"])
                    this.lichSuUpLoad.push(LichSuUploadNewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrEditUngVienInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUngVienInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ungVien"] = this.ungVien ? this.ungVien.toJSON() : <any>undefined;
        if (this.lichSuUpLoad && this.lichSuUpLoad.constructor === Array) {
            data["lichSuUpLoad"] = [];
            for (let item of this.lichSuUpLoad)
                data["lichSuUpLoad"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateOrEditUngVienInput {
        const json = this.toJSON();
        let result = new CreateOrEditUngVienInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditUngVienInput {
    ungVien: CreateOrEditUngVienDto;
    lichSuUpLoad: LichSuUploadNewDto[] | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id: number | undefined;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    isTwoFactorEnabled: boolean;
    isLockoutEnabled: boolean;
    employeeCode: string | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.employeeCode = data["employeeCode"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["employeeCode"] = this.employeeCode;
        return data; 
    }

    clone(): UserEditDto {
        const json = this.toJSON();
        let result = new UserEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    isTwoFactorEnabled: boolean;
    isLockoutEnabled: boolean;
    employeeCode: string | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;
    inheritedFromOrganizationUnit: boolean;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
            this.inheritedFromOrganizationUnit = data["inheritedFromOrganizationUnit"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        data["inheritedFromOrganizationUnit"] = this.inheritedFromOrganizationUnit;
        return data; 
    }

    clone(): UserRoleDto {
        const json = this.toJSON();
        let result = new UserRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;
    inheritedFromOrganizationUnit: boolean;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [];
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [];
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }

    clone(): GetUserForEditOutput {
        const json = this.toJSON();
        let result = new GetUserForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetUserPermissionsForEditOutput {
        const json = this.toJSON();
        let result = new GetUserPermissionsForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id: number;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfInt64 {
        const json = this.toJSON();
        let result = new EntityDtoOfInt64();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfInt64 {
    id: number;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): UpdateUserPermissionsInput {
        const json = this.toJSON();
        let result = new UpdateUserPermissionsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[] | undefined;
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[] | undefined;
    sendActivationEmail: boolean;
    setRandomPassword: boolean;
    organizationUnits: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [];
                for (let item of data["organizationUnits"])
                    this.organizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }

    clone(): CreateOrUpdateUserInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateUserInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[] | undefined;
    sendActivationEmail: boolean;
    setRandomPassword: boolean;
    organizationUnits: number[] | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string | undefined;
    password: string | undefined;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }

    clone(): LinkToUserInput {
        const json = this.toJSON();
        let result = new LinkToUserInput();
        result.init(json);
        return result;
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string | undefined;
    password: string | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data; 
    }

    clone(): LinkedUserDto {
        const json = this.toJSON();
        let result = new LinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLinkedUserDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[] | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfLinkedUserDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): UnlinkUserInput {
        const json = this.toJSON();
        let result = new UnlinkUserInput();
        result.init(json);
        return result;
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): UserLoginAttemptDto {
        const json = this.toJSON();
        let result = new UserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfUserLoginAttemptDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class GetUserLoginForEdit implements IGetUserLoginForEdit {
    user: UserEditDto;

    constructor(data?: IGetUserLoginForEdit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
        }
    }

    static fromJS(data: any): GetUserLoginForEdit {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserLoginForEdit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetUserLoginForEdit {
        const json = this.toJSON();
        let result = new GetUserLoginForEdit();
        result.init(json);
        return result;
    }
}

export interface IGetUserLoginForEdit {
    user: UserEditDto;
}

export class VanbanDto implements IVanbanDto {
    tenCongViec: string | undefined;
    ngayGiaoViec: moment.Moment;
    hanKetThuc: moment.Moment;
    nguoiXuLy: string | undefined;
    tienDoChung: number;
    tinhTrang: string | undefined;
    noiDung: string | undefined;
    id: number;

    constructor(data?: IVanbanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenCongViec = data["tenCongViec"];
            this.ngayGiaoViec = data["ngayGiaoViec"] ? moment(data["ngayGiaoViec"].toString()) : <any>undefined;
            this.hanKetThuc = data["hanKetThuc"] ? moment(data["hanKetThuc"].toString()) : <any>undefined;
            this.nguoiXuLy = data["nguoiXuLy"];
            this.tienDoChung = data["tienDoChung"];
            this.tinhTrang = data["tinhTrang"];
            this.noiDung = data["noiDung"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): VanbanDto {
        data = typeof data === 'object' ? data : {};
        let result = new VanbanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenCongViec"] = this.tenCongViec;
        data["ngayGiaoViec"] = this.ngayGiaoViec ? this.ngayGiaoViec.toISOString() : <any>undefined;
        data["hanKetThuc"] = this.hanKetThuc ? this.hanKetThuc.toISOString() : <any>undefined;
        data["nguoiXuLy"] = this.nguoiXuLy;
        data["tienDoChung"] = this.tienDoChung;
        data["tinhTrang"] = this.tinhTrang;
        data["noiDung"] = this.noiDung;
        data["id"] = this.id;
        return data; 
    }

    clone(): VanbanDto {
        const json = this.toJSON();
        let result = new VanbanDto();
        result.init(json);
        return result;
    }
}

export interface IVanbanDto {
    tenCongViec: string | undefined;
    ngayGiaoViec: moment.Moment;
    hanKetThuc: moment.Moment;
    nguoiXuLy: string | undefined;
    tienDoChung: number;
    tinhTrang: string | undefined;
    noiDung: string | undefined;
    id: number;
}

export class GetVanbanForViewDto implements IGetVanbanForViewDto {
    vanban: VanbanDto;

    constructor(data?: IGetVanbanForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.vanban = new VanbanDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.vanban = data["vanban"] ? VanbanDto.fromJS(data["vanban"]) : new VanbanDto();
        }
    }

    static fromJS(data: any): GetVanbanForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetVanbanForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vanban"] = this.vanban ? this.vanban.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetVanbanForViewDto {
        const json = this.toJSON();
        let result = new GetVanbanForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetVanbanForViewDto {
    vanban: VanbanDto;
}

export class PagedResultDtoOfGetVanbanForViewDto implements IPagedResultDtoOfGetVanbanForViewDto {
    totalCount: number;
    items: GetVanbanForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetVanbanForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetVanbanForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetVanbanForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetVanbanForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetVanbanForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetVanbanForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetVanbanForViewDto {
    totalCount: number;
    items: GetVanbanForViewDto[] | undefined;
}

export class CreateOrEditVanbanDto implements ICreateOrEditVanbanDto {
    tenCongViec: string | undefined;
    ngayGiaoViec: moment.Moment;
    hanKetThuc: moment.Moment;
    nguoiXuLy: string | undefined;
    tienDoChung: number;
    tinhTrang: string | undefined;
    noiDung: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditVanbanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenCongViec = data["tenCongViec"];
            this.ngayGiaoViec = data["ngayGiaoViec"] ? moment(data["ngayGiaoViec"].toString()) : <any>undefined;
            this.hanKetThuc = data["hanKetThuc"] ? moment(data["hanKetThuc"].toString()) : <any>undefined;
            this.nguoiXuLy = data["nguoiXuLy"];
            this.tienDoChung = data["tienDoChung"];
            this.tinhTrang = data["tinhTrang"];
            this.noiDung = data["noiDung"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditVanbanDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditVanbanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenCongViec"] = this.tenCongViec;
        data["ngayGiaoViec"] = this.ngayGiaoViec ? this.ngayGiaoViec.toISOString() : <any>undefined;
        data["hanKetThuc"] = this.hanKetThuc ? this.hanKetThuc.toISOString() : <any>undefined;
        data["nguoiXuLy"] = this.nguoiXuLy;
        data["tienDoChung"] = this.tienDoChung;
        data["tinhTrang"] = this.tinhTrang;
        data["noiDung"] = this.noiDung;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditVanbanDto {
        const json = this.toJSON();
        let result = new CreateOrEditVanbanDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditVanbanDto {
    tenCongViec: string | undefined;
    ngayGiaoViec: moment.Moment;
    hanKetThuc: moment.Moment;
    nguoiXuLy: string | undefined;
    tienDoChung: number;
    tinhTrang: string | undefined;
    noiDung: string | undefined;
    id: number | undefined;
}

export class GetVanbanForEditOutput implements IGetVanbanForEditOutput {
    vanban: CreateOrEditVanbanDto;

    constructor(data?: IGetVanbanForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.vanban = new CreateOrEditVanbanDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.vanban = data["vanban"] ? CreateOrEditVanbanDto.fromJS(data["vanban"]) : new CreateOrEditVanbanDto();
        }
    }

    static fromJS(data: any): GetVanbanForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVanbanForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vanban"] = this.vanban ? this.vanban.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetVanbanForEditOutput {
        const json = this.toJSON();
        let result = new GetVanbanForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetVanbanForEditOutput {
    vanban: CreateOrEditVanbanDto;
}

export class VanbanListDto implements IVanbanListDto {
    tenCongViec: string | undefined;
    ngayGiaoViec: moment.Moment;
    hanKetThuc: moment.Moment;
    nguoiXuLy: string | undefined;
    tienDoChung: number;
    tinhTrang: string | undefined;
    noiDung: string | undefined;

    constructor(data?: IVanbanListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenCongViec = data["tenCongViec"];
            this.ngayGiaoViec = data["ngayGiaoViec"] ? moment(data["ngayGiaoViec"].toString()) : <any>undefined;
            this.hanKetThuc = data["hanKetThuc"] ? moment(data["hanKetThuc"].toString()) : <any>undefined;
            this.nguoiXuLy = data["nguoiXuLy"];
            this.tienDoChung = data["tienDoChung"];
            this.tinhTrang = data["tinhTrang"];
            this.noiDung = data["noiDung"];
        }
    }

    static fromJS(data: any): VanbanListDto {
        data = typeof data === 'object' ? data : {};
        let result = new VanbanListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenCongViec"] = this.tenCongViec;
        data["ngayGiaoViec"] = this.ngayGiaoViec ? this.ngayGiaoViec.toISOString() : <any>undefined;
        data["hanKetThuc"] = this.hanKetThuc ? this.hanKetThuc.toISOString() : <any>undefined;
        data["nguoiXuLy"] = this.nguoiXuLy;
        data["tienDoChung"] = this.tienDoChung;
        data["tinhTrang"] = this.tinhTrang;
        data["noiDung"] = this.noiDung;
        return data; 
    }

    clone(): VanbanListDto {
        const json = this.toJSON();
        let result = new VanbanListDto();
        result.init(json);
        return result;
    }
}

export interface IVanbanListDto {
    tenCongViec: string | undefined;
    ngayGiaoViec: moment.Moment;
    hanKetThuc: moment.Moment;
    nguoiXuLy: string | undefined;
    tienDoChung: number;
    tinhTrang: string | undefined;
    noiDung: string | undefined;
}

export class ViTriCongViecDto implements IViTriCongViecDto {
    tenCty: string | undefined;
    hopDongHienTai: string | undefined;
    soHD: string | undefined;
    donViCongTacName: string | undefined;
    choNgoi: string | undefined;
    noiDaoTaoID: number;
    loaiHopDongID: number;
    maSoNoiKCB: string | undefined;
    noiDangKyKCBID: number;
    ngayHetHanBHYT: moment.Moment;
    soTheBHYT: string | undefined;
    maTinhCap: string | undefined;
    maSoBHXH: string | undefined;
    soSoBHXH: string | undefined;
    tyLeDongBH: number;
    ngayThamGiaBH: moment.Moment;
    thamGiaCongDoan: boolean;
    nganHangCode: string | undefined;
    tkNganHang: string | undefined;
    donViSoCongChuanCode: string | undefined;
    soCongChuan: string | undefined;
    luongDongBH: string | undefined;
    luongCoBan: string | undefined;
    bacLuongCode: string | undefined;
    soNgayPhep: number;
    ngayChinhThuc: moment.Moment;
    ngayThuViec: moment.Moment;
    ngayTapSu: moment.Moment;
    soSoQLLaoDong: string | undefined;
    diaDiemLamViecCode: string | undefined;
    quanLyGianTiep: string | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiLamViecCode: string | undefined;
    bac: string | undefined;
    cap: string | undefined;
    chucDanh: string | undefined;
    maChamCong: string | undefined;
    diaChiLHKC: string | undefined;
    emailLHKC: string | undefined;
    dtDiDongLHKC: string | undefined;
    dtNhaRiengLHKC: string | undefined;
    quanHeLHKC: string | undefined;
    hoVaTenLHKC: string | undefined;
    diaChiHN: string | undefined;
    tinhThanhIDHN: number | undefined;
    quocGiaHN: string | undefined;
    laChuHo: boolean;
    maSoHoGiaDinh: string | undefined;
    soSoHoKhau: string | undefined;
    diaChiHKTT: string | undefined;
    tinhThanhIDHKTT: number | undefined;
    quocGiaHKTT: string | undefined;
    facebook: string | undefined;
    skype: string | undefined;
    noiSinh: string | undefined;
    tinhThanhID: number | undefined;
    nguyenQuan: string | undefined;
    emailKhac: string | undefined;
    emailCoQuan: string | undefined;
    emailCaNhan: string | undefined;
    dtKhac: string | undefined;
    dtNhaRieng: string | undefined;
    dtCoQuan: string | undefined;
    dtDiDong: string | undefined;
    tepDinhKem: string | undefined;
    tinhTrangHonNhanCode: string | undefined;
    xepLoaiCode: string | undefined;
    namTotNghiep: number;
    chuyenNganh: string | undefined;
    khoa: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    trinhDoVanHoa: string | undefined;
    ngayHetHan: moment.Moment;
    noiCap: string | undefined;
    ngayCap: moment.Moment;
    soCMND: string | undefined;
    quocTich: string | undefined;
    tonGiao: string | undefined;
    danToc: string | undefined;
    viTriCongViecCode: string | undefined;
    donViCongTacID: number | undefined;
    mstCaNhan: string | undefined;
    ngaySinh: moment.Moment;
    gioiTinhCode: string | undefined;
    anhDaiDien: string | undefined;
    hoVaTen: string | undefined;
    maNhanVien: string | undefined;
    chiNhanh: string | undefined;
    dvt: string | undefined;
    ngayKyHDKTH: moment.Moment;
    ngayKyHD36TH: moment.Moment;
    ngayKyHD12TH: moment.Moment;
    ngayKyHDTV: moment.Moment;
    ngayKYHDCTV: moment.Moment;
    ngayKyHDKV: moment.Moment;
    ngayKYHDTT: moment.Moment;
    ngayKyHD: moment.Moment;
    id: number;

    constructor(data?: IViTriCongViecDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenCty = data["tenCty"];
            this.hopDongHienTai = data["hopDongHienTai"];
            this.soHD = data["soHD"];
            this.donViCongTacName = data["donViCongTacName"];
            this.choNgoi = data["choNgoi"];
            this.noiDaoTaoID = data["noiDaoTaoID"];
            this.loaiHopDongID = data["loaiHopDongID"];
            this.maSoNoiKCB = data["maSoNoiKCB"];
            this.noiDangKyKCBID = data["noiDangKyKCBID"];
            this.ngayHetHanBHYT = data["ngayHetHanBHYT"] ? moment(data["ngayHetHanBHYT"].toString()) : <any>undefined;
            this.soTheBHYT = data["soTheBHYT"];
            this.maTinhCap = data["maTinhCap"];
            this.maSoBHXH = data["maSoBHXH"];
            this.soSoBHXH = data["soSoBHXH"];
            this.tyLeDongBH = data["tyLeDongBH"];
            this.ngayThamGiaBH = data["ngayThamGiaBH"] ? moment(data["ngayThamGiaBH"].toString()) : <any>undefined;
            this.thamGiaCongDoan = data["thamGiaCongDoan"];
            this.nganHangCode = data["nganHangCode"];
            this.tkNganHang = data["tkNganHang"];
            this.donViSoCongChuanCode = data["donViSoCongChuanCode"];
            this.soCongChuan = data["soCongChuan"];
            this.luongDongBH = data["luongDongBH"];
            this.luongCoBan = data["luongCoBan"];
            this.bacLuongCode = data["bacLuongCode"];
            this.soNgayPhep = data["soNgayPhep"];
            this.ngayChinhThuc = data["ngayChinhThuc"] ? moment(data["ngayChinhThuc"].toString()) : <any>undefined;
            this.ngayThuViec = data["ngayThuViec"] ? moment(data["ngayThuViec"].toString()) : <any>undefined;
            this.ngayTapSu = data["ngayTapSu"] ? moment(data["ngayTapSu"].toString()) : <any>undefined;
            this.soSoQLLaoDong = data["soSoQLLaoDong"];
            this.diaDiemLamViecCode = data["diaDiemLamViecCode"];
            this.quanLyGianTiep = data["quanLyGianTiep"];
            this.quanLyTrucTiep = data["quanLyTrucTiep"];
            this.trangThaiLamViecCode = data["trangThaiLamViecCode"];
            this.bac = data["bac"];
            this.cap = data["cap"];
            this.chucDanh = data["chucDanh"];
            this.maChamCong = data["maChamCong"];
            this.diaChiLHKC = data["diaChiLHKC"];
            this.emailLHKC = data["emailLHKC"];
            this.dtDiDongLHKC = data["dtDiDongLHKC"];
            this.dtNhaRiengLHKC = data["dtNhaRiengLHKC"];
            this.quanHeLHKC = data["quanHeLHKC"];
            this.hoVaTenLHKC = data["hoVaTenLHKC"];
            this.diaChiHN = data["diaChiHN"];
            this.tinhThanhIDHN = data["tinhThanhIDHN"];
            this.quocGiaHN = data["quocGiaHN"];
            this.laChuHo = data["laChuHo"];
            this.maSoHoGiaDinh = data["maSoHoGiaDinh"];
            this.soSoHoKhau = data["soSoHoKhau"];
            this.diaChiHKTT = data["diaChiHKTT"];
            this.tinhThanhIDHKTT = data["tinhThanhIDHKTT"];
            this.quocGiaHKTT = data["quocGiaHKTT"];
            this.facebook = data["facebook"];
            this.skype = data["skype"];
            this.noiSinh = data["noiSinh"];
            this.tinhThanhID = data["tinhThanhID"];
            this.nguyenQuan = data["nguyenQuan"];
            this.emailKhac = data["emailKhac"];
            this.emailCoQuan = data["emailCoQuan"];
            this.emailCaNhan = data["emailCaNhan"];
            this.dtKhac = data["dtKhac"];
            this.dtNhaRieng = data["dtNhaRieng"];
            this.dtCoQuan = data["dtCoQuan"];
            this.dtDiDong = data["dtDiDong"];
            this.tepDinhKem = data["tepDinhKem"];
            this.tinhTrangHonNhanCode = data["tinhTrangHonNhanCode"];
            this.xepLoaiCode = data["xepLoaiCode"];
            this.namTotNghiep = data["namTotNghiep"];
            this.chuyenNganh = data["chuyenNganh"];
            this.khoa = data["khoa"];
            this.trinhDoDaoTaoCode = data["trinhDoDaoTaoCode"];
            this.trinhDoVanHoa = data["trinhDoVanHoa"];
            this.ngayHetHan = data["ngayHetHan"] ? moment(data["ngayHetHan"].toString()) : <any>undefined;
            this.noiCap = data["noiCap"];
            this.ngayCap = data["ngayCap"] ? moment(data["ngayCap"].toString()) : <any>undefined;
            this.soCMND = data["soCMND"];
            this.quocTich = data["quocTich"];
            this.tonGiao = data["tonGiao"];
            this.danToc = data["danToc"];
            this.viTriCongViecCode = data["viTriCongViecCode"];
            this.donViCongTacID = data["donViCongTacID"];
            this.mstCaNhan = data["mstCaNhan"];
            this.ngaySinh = data["ngaySinh"] ? moment(data["ngaySinh"].toString()) : <any>undefined;
            this.gioiTinhCode = data["gioiTinhCode"];
            this.anhDaiDien = data["anhDaiDien"];
            this.hoVaTen = data["hoVaTen"];
            this.maNhanVien = data["maNhanVien"];
            this.chiNhanh = data["chiNhanh"];
            this.dvt = data["dvt"];
            this.ngayKyHDKTH = data["ngayKyHDKTH"] ? moment(data["ngayKyHDKTH"].toString()) : <any>undefined;
            this.ngayKyHD36TH = data["ngayKyHD36TH"] ? moment(data["ngayKyHD36TH"].toString()) : <any>undefined;
            this.ngayKyHD12TH = data["ngayKyHD12TH"] ? moment(data["ngayKyHD12TH"].toString()) : <any>undefined;
            this.ngayKyHDTV = data["ngayKyHDTV"] ? moment(data["ngayKyHDTV"].toString()) : <any>undefined;
            this.ngayKYHDCTV = data["ngayKYHDCTV"] ? moment(data["ngayKYHDCTV"].toString()) : <any>undefined;
            this.ngayKyHDKV = data["ngayKyHDKV"] ? moment(data["ngayKyHDKV"].toString()) : <any>undefined;
            this.ngayKYHDTT = data["ngayKYHDTT"] ? moment(data["ngayKYHDTT"].toString()) : <any>undefined;
            this.ngayKyHD = data["ngayKyHD"] ? moment(data["ngayKyHD"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ViTriCongViecDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViTriCongViecDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenCty"] = this.tenCty;
        data["hopDongHienTai"] = this.hopDongHienTai;
        data["soHD"] = this.soHD;
        data["donViCongTacName"] = this.donViCongTacName;
        data["choNgoi"] = this.choNgoi;
        data["noiDaoTaoID"] = this.noiDaoTaoID;
        data["loaiHopDongID"] = this.loaiHopDongID;
        data["maSoNoiKCB"] = this.maSoNoiKCB;
        data["noiDangKyKCBID"] = this.noiDangKyKCBID;
        data["ngayHetHanBHYT"] = this.ngayHetHanBHYT ? this.ngayHetHanBHYT.toISOString() : <any>undefined;
        data["soTheBHYT"] = this.soTheBHYT;
        data["maTinhCap"] = this.maTinhCap;
        data["maSoBHXH"] = this.maSoBHXH;
        data["soSoBHXH"] = this.soSoBHXH;
        data["tyLeDongBH"] = this.tyLeDongBH;
        data["ngayThamGiaBH"] = this.ngayThamGiaBH ? this.ngayThamGiaBH.toISOString() : <any>undefined;
        data["thamGiaCongDoan"] = this.thamGiaCongDoan;
        data["nganHangCode"] = this.nganHangCode;
        data["tkNganHang"] = this.tkNganHang;
        data["donViSoCongChuanCode"] = this.donViSoCongChuanCode;
        data["soCongChuan"] = this.soCongChuan;
        data["luongDongBH"] = this.luongDongBH;
        data["luongCoBan"] = this.luongCoBan;
        data["bacLuongCode"] = this.bacLuongCode;
        data["soNgayPhep"] = this.soNgayPhep;
        data["ngayChinhThuc"] = this.ngayChinhThuc ? this.ngayChinhThuc.toISOString() : <any>undefined;
        data["ngayThuViec"] = this.ngayThuViec ? this.ngayThuViec.toISOString() : <any>undefined;
        data["ngayTapSu"] = this.ngayTapSu ? this.ngayTapSu.toISOString() : <any>undefined;
        data["soSoQLLaoDong"] = this.soSoQLLaoDong;
        data["diaDiemLamViecCode"] = this.diaDiemLamViecCode;
        data["quanLyGianTiep"] = this.quanLyGianTiep;
        data["quanLyTrucTiep"] = this.quanLyTrucTiep;
        data["trangThaiLamViecCode"] = this.trangThaiLamViecCode;
        data["bac"] = this.bac;
        data["cap"] = this.cap;
        data["chucDanh"] = this.chucDanh;
        data["maChamCong"] = this.maChamCong;
        data["diaChiLHKC"] = this.diaChiLHKC;
        data["emailLHKC"] = this.emailLHKC;
        data["dtDiDongLHKC"] = this.dtDiDongLHKC;
        data["dtNhaRiengLHKC"] = this.dtNhaRiengLHKC;
        data["quanHeLHKC"] = this.quanHeLHKC;
        data["hoVaTenLHKC"] = this.hoVaTenLHKC;
        data["diaChiHN"] = this.diaChiHN;
        data["tinhThanhIDHN"] = this.tinhThanhIDHN;
        data["quocGiaHN"] = this.quocGiaHN;
        data["laChuHo"] = this.laChuHo;
        data["maSoHoGiaDinh"] = this.maSoHoGiaDinh;
        data["soSoHoKhau"] = this.soSoHoKhau;
        data["diaChiHKTT"] = this.diaChiHKTT;
        data["tinhThanhIDHKTT"] = this.tinhThanhIDHKTT;
        data["quocGiaHKTT"] = this.quocGiaHKTT;
        data["facebook"] = this.facebook;
        data["skype"] = this.skype;
        data["noiSinh"] = this.noiSinh;
        data["tinhThanhID"] = this.tinhThanhID;
        data["nguyenQuan"] = this.nguyenQuan;
        data["emailKhac"] = this.emailKhac;
        data["emailCoQuan"] = this.emailCoQuan;
        data["emailCaNhan"] = this.emailCaNhan;
        data["dtKhac"] = this.dtKhac;
        data["dtNhaRieng"] = this.dtNhaRieng;
        data["dtCoQuan"] = this.dtCoQuan;
        data["dtDiDong"] = this.dtDiDong;
        data["tepDinhKem"] = this.tepDinhKem;
        data["tinhTrangHonNhanCode"] = this.tinhTrangHonNhanCode;
        data["xepLoaiCode"] = this.xepLoaiCode;
        data["namTotNghiep"] = this.namTotNghiep;
        data["chuyenNganh"] = this.chuyenNganh;
        data["khoa"] = this.khoa;
        data["trinhDoDaoTaoCode"] = this.trinhDoDaoTaoCode;
        data["trinhDoVanHoa"] = this.trinhDoVanHoa;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        data["noiCap"] = this.noiCap;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["soCMND"] = this.soCMND;
        data["quocTich"] = this.quocTich;
        data["tonGiao"] = this.tonGiao;
        data["danToc"] = this.danToc;
        data["viTriCongViecCode"] = this.viTriCongViecCode;
        data["donViCongTacID"] = this.donViCongTacID;
        data["mstCaNhan"] = this.mstCaNhan;
        data["ngaySinh"] = this.ngaySinh ? this.ngaySinh.toISOString() : <any>undefined;
        data["gioiTinhCode"] = this.gioiTinhCode;
        data["anhDaiDien"] = this.anhDaiDien;
        data["hoVaTen"] = this.hoVaTen;
        data["maNhanVien"] = this.maNhanVien;
        data["chiNhanh"] = this.chiNhanh;
        data["dvt"] = this.dvt;
        data["ngayKyHDKTH"] = this.ngayKyHDKTH ? this.ngayKyHDKTH.toISOString() : <any>undefined;
        data["ngayKyHD36TH"] = this.ngayKyHD36TH ? this.ngayKyHD36TH.toISOString() : <any>undefined;
        data["ngayKyHD12TH"] = this.ngayKyHD12TH ? this.ngayKyHD12TH.toISOString() : <any>undefined;
        data["ngayKyHDTV"] = this.ngayKyHDTV ? this.ngayKyHDTV.toISOString() : <any>undefined;
        data["ngayKYHDCTV"] = this.ngayKYHDCTV ? this.ngayKYHDCTV.toISOString() : <any>undefined;
        data["ngayKyHDKV"] = this.ngayKyHDKV ? this.ngayKyHDKV.toISOString() : <any>undefined;
        data["ngayKYHDTT"] = this.ngayKYHDTT ? this.ngayKYHDTT.toISOString() : <any>undefined;
        data["ngayKyHD"] = this.ngayKyHD ? this.ngayKyHD.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): ViTriCongViecDto {
        const json = this.toJSON();
        let result = new ViTriCongViecDto();
        result.init(json);
        return result;
    }
}

export interface IViTriCongViecDto {
    tenCty: string | undefined;
    hopDongHienTai: string | undefined;
    soHD: string | undefined;
    donViCongTacName: string | undefined;
    choNgoi: string | undefined;
    noiDaoTaoID: number;
    loaiHopDongID: number;
    maSoNoiKCB: string | undefined;
    noiDangKyKCBID: number;
    ngayHetHanBHYT: moment.Moment;
    soTheBHYT: string | undefined;
    maTinhCap: string | undefined;
    maSoBHXH: string | undefined;
    soSoBHXH: string | undefined;
    tyLeDongBH: number;
    ngayThamGiaBH: moment.Moment;
    thamGiaCongDoan: boolean;
    nganHangCode: string | undefined;
    tkNganHang: string | undefined;
    donViSoCongChuanCode: string | undefined;
    soCongChuan: string | undefined;
    luongDongBH: string | undefined;
    luongCoBan: string | undefined;
    bacLuongCode: string | undefined;
    soNgayPhep: number;
    ngayChinhThuc: moment.Moment;
    ngayThuViec: moment.Moment;
    ngayTapSu: moment.Moment;
    soSoQLLaoDong: string | undefined;
    diaDiemLamViecCode: string | undefined;
    quanLyGianTiep: string | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiLamViecCode: string | undefined;
    bac: string | undefined;
    cap: string | undefined;
    chucDanh: string | undefined;
    maChamCong: string | undefined;
    diaChiLHKC: string | undefined;
    emailLHKC: string | undefined;
    dtDiDongLHKC: string | undefined;
    dtNhaRiengLHKC: string | undefined;
    quanHeLHKC: string | undefined;
    hoVaTenLHKC: string | undefined;
    diaChiHN: string | undefined;
    tinhThanhIDHN: number | undefined;
    quocGiaHN: string | undefined;
    laChuHo: boolean;
    maSoHoGiaDinh: string | undefined;
    soSoHoKhau: string | undefined;
    diaChiHKTT: string | undefined;
    tinhThanhIDHKTT: number | undefined;
    quocGiaHKTT: string | undefined;
    facebook: string | undefined;
    skype: string | undefined;
    noiSinh: string | undefined;
    tinhThanhID: number | undefined;
    nguyenQuan: string | undefined;
    emailKhac: string | undefined;
    emailCoQuan: string | undefined;
    emailCaNhan: string | undefined;
    dtKhac: string | undefined;
    dtNhaRieng: string | undefined;
    dtCoQuan: string | undefined;
    dtDiDong: string | undefined;
    tepDinhKem: string | undefined;
    tinhTrangHonNhanCode: string | undefined;
    xepLoaiCode: string | undefined;
    namTotNghiep: number;
    chuyenNganh: string | undefined;
    khoa: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    trinhDoVanHoa: string | undefined;
    ngayHetHan: moment.Moment;
    noiCap: string | undefined;
    ngayCap: moment.Moment;
    soCMND: string | undefined;
    quocTich: string | undefined;
    tonGiao: string | undefined;
    danToc: string | undefined;
    viTriCongViecCode: string | undefined;
    donViCongTacID: number | undefined;
    mstCaNhan: string | undefined;
    ngaySinh: moment.Moment;
    gioiTinhCode: string | undefined;
    anhDaiDien: string | undefined;
    hoVaTen: string | undefined;
    maNhanVien: string | undefined;
    chiNhanh: string | undefined;
    dvt: string | undefined;
    ngayKyHDKTH: moment.Moment;
    ngayKyHD36TH: moment.Moment;
    ngayKyHD12TH: moment.Moment;
    ngayKyHDTV: moment.Moment;
    ngayKYHDCTV: moment.Moment;
    ngayKyHDKV: moment.Moment;
    ngayKYHDTT: moment.Moment;
    ngayKyHD: moment.Moment;
    id: number;
}

export class GetViTriCongViecForViewDto implements IGetViTriCongViecForViewDto {
    viTriCongViec: ViTriCongViecDto;

    constructor(data?: IGetViTriCongViecForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.viTriCongViec = new ViTriCongViecDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.viTriCongViec = data["viTriCongViec"] ? ViTriCongViecDto.fromJS(data["viTriCongViec"]) : new ViTriCongViecDto();
        }
    }

    static fromJS(data: any): GetViTriCongViecForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetViTriCongViecForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viTriCongViec"] = this.viTriCongViec ? this.viTriCongViec.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetViTriCongViecForViewDto {
        const json = this.toJSON();
        let result = new GetViTriCongViecForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetViTriCongViecForViewDto {
    viTriCongViec: ViTriCongViecDto;
}

export class PagedResultDtoOfGetViTriCongViecForViewDto implements IPagedResultDtoOfGetViTriCongViecForViewDto {
    totalCount: number;
    items: GetViTriCongViecForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetViTriCongViecForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetViTriCongViecForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetViTriCongViecForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetViTriCongViecForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetViTriCongViecForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetViTriCongViecForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetViTriCongViecForViewDto {
    totalCount: number;
    items: GetViTriCongViecForViewDto[] | undefined;
}

export class CreateOrEditViTriCongViecDto implements ICreateOrEditViTriCongViecDto {
    tenCty: string | undefined;
    hopDongHienTai: string | undefined;
    soHD: string | undefined;
    donViCongTacName: string | undefined;
    choNgoi: string | undefined;
    noiDaoTaoID: number;
    loaiHopDongID: number;
    maSoNoiKCB: string | undefined;
    noiDangKyKCBID: number;
    ngayHetHanBHYT: moment.Moment;
    soTheBHYT: string | undefined;
    maTinhCap: string | undefined;
    maSoBHXH: string | undefined;
    soSoBHXH: string | undefined;
    tyLeDongBH: number;
    ngayThamGiaBH: moment.Moment;
    thamGiaCongDoan: boolean;
    nganHangCode: string | undefined;
    tkNganHang: string | undefined;
    donViSoCongChuanCode: string | undefined;
    soCongChuan: string | undefined;
    luongDongBH: string | undefined;
    luongCoBan: string | undefined;
    bacLuongCode: string | undefined;
    soNgayPhep: number;
    ngayChinhThuc: moment.Moment;
    ngayThuViec: moment.Moment;
    ngayTapSu: moment.Moment;
    soSoQLLaoDong: string | undefined;
    diaDiemLamViecCode: string | undefined;
    quanLyGianTiep: string | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiLamViecCode: string | undefined;
    bac: string | undefined;
    cap: string | undefined;
    chucDanh: string | undefined;
    maChamCong: string | undefined;
    diaChiLHKC: string | undefined;
    emailLHKC: string | undefined;
    dtDiDongLHKC: string | undefined;
    dtNhaRiengLHKC: string | undefined;
    quanHeLHKC: string | undefined;
    hoVaTenLHKC: string | undefined;
    diaChiHN: string | undefined;
    tinhThanhIDHN: number | undefined;
    quocGiaHN: string | undefined;
    laChuHo: boolean;
    maSoHoGiaDinh: string | undefined;
    soSoHoKhau: string | undefined;
    diaChiHKTT: string | undefined;
    tinhThanhIDHKTT: number | undefined;
    quocGiaHKTT: string | undefined;
    facebook: string | undefined;
    skype: string | undefined;
    noiSinh: string | undefined;
    tinhThanhID: number | undefined;
    nguyenQuan: string | undefined;
    emailKhac: string | undefined;
    emailCoQuan: string | undefined;
    emailCaNhan: string | undefined;
    dtKhac: string | undefined;
    dtNhaRieng: string | undefined;
    dtCoQuan: string | undefined;
    dtDiDong: string | undefined;
    tepDinhKem: string | undefined;
    tinhTrangHonNhanCode: string | undefined;
    xepLoaiCode: string | undefined;
    namTotNghiep: number;
    chuyenNganh: string | undefined;
    khoa: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    trinhDoVanHoa: string | undefined;
    ngayHetHan: moment.Moment;
    noiCap: string | undefined;
    ngayCap: moment.Moment;
    soCMND: string | undefined;
    quocTich: string | undefined;
    tonGiao: string | undefined;
    danToc: string | undefined;
    viTriCongViecCode: string | undefined;
    donViCongTacID: number | undefined;
    mstCaNhan: string | undefined;
    ngaySinh: moment.Moment;
    gioiTinhCode: string | undefined;
    anhDaiDien: string | undefined;
    hoVaTen: string | undefined;
    maNhanVien: string | undefined;
    chiNhanh: string | undefined;
    dvt: string | undefined;
    ngayKyHDKTH: moment.Moment;
    ngayKyHD36TH: moment.Moment;
    ngayKyHD12TH: moment.Moment;
    ngayKyHDTV: moment.Moment;
    ngayKYHDCTV: moment.Moment;
    ngayKyHDKV: moment.Moment;
    ngayKYHDTT: moment.Moment;
    ngayKyHD: moment.Moment;
    id: number | undefined;

    constructor(data?: ICreateOrEditViTriCongViecDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenCty = data["tenCty"];
            this.hopDongHienTai = data["hopDongHienTai"];
            this.soHD = data["soHD"];
            this.donViCongTacName = data["donViCongTacName"];
            this.choNgoi = data["choNgoi"];
            this.noiDaoTaoID = data["noiDaoTaoID"];
            this.loaiHopDongID = data["loaiHopDongID"];
            this.maSoNoiKCB = data["maSoNoiKCB"];
            this.noiDangKyKCBID = data["noiDangKyKCBID"];
            this.ngayHetHanBHYT = data["ngayHetHanBHYT"] ? moment(data["ngayHetHanBHYT"].toString()) : <any>undefined;
            this.soTheBHYT = data["soTheBHYT"];
            this.maTinhCap = data["maTinhCap"];
            this.maSoBHXH = data["maSoBHXH"];
            this.soSoBHXH = data["soSoBHXH"];
            this.tyLeDongBH = data["tyLeDongBH"];
            this.ngayThamGiaBH = data["ngayThamGiaBH"] ? moment(data["ngayThamGiaBH"].toString()) : <any>undefined;
            this.thamGiaCongDoan = data["thamGiaCongDoan"];
            this.nganHangCode = data["nganHangCode"];
            this.tkNganHang = data["tkNganHang"];
            this.donViSoCongChuanCode = data["donViSoCongChuanCode"];
            this.soCongChuan = data["soCongChuan"];
            this.luongDongBH = data["luongDongBH"];
            this.luongCoBan = data["luongCoBan"];
            this.bacLuongCode = data["bacLuongCode"];
            this.soNgayPhep = data["soNgayPhep"];
            this.ngayChinhThuc = data["ngayChinhThuc"] ? moment(data["ngayChinhThuc"].toString()) : <any>undefined;
            this.ngayThuViec = data["ngayThuViec"] ? moment(data["ngayThuViec"].toString()) : <any>undefined;
            this.ngayTapSu = data["ngayTapSu"] ? moment(data["ngayTapSu"].toString()) : <any>undefined;
            this.soSoQLLaoDong = data["soSoQLLaoDong"];
            this.diaDiemLamViecCode = data["diaDiemLamViecCode"];
            this.quanLyGianTiep = data["quanLyGianTiep"];
            this.quanLyTrucTiep = data["quanLyTrucTiep"];
            this.trangThaiLamViecCode = data["trangThaiLamViecCode"];
            this.bac = data["bac"];
            this.cap = data["cap"];
            this.chucDanh = data["chucDanh"];
            this.maChamCong = data["maChamCong"];
            this.diaChiLHKC = data["diaChiLHKC"];
            this.emailLHKC = data["emailLHKC"];
            this.dtDiDongLHKC = data["dtDiDongLHKC"];
            this.dtNhaRiengLHKC = data["dtNhaRiengLHKC"];
            this.quanHeLHKC = data["quanHeLHKC"];
            this.hoVaTenLHKC = data["hoVaTenLHKC"];
            this.diaChiHN = data["diaChiHN"];
            this.tinhThanhIDHN = data["tinhThanhIDHN"];
            this.quocGiaHN = data["quocGiaHN"];
            this.laChuHo = data["laChuHo"];
            this.maSoHoGiaDinh = data["maSoHoGiaDinh"];
            this.soSoHoKhau = data["soSoHoKhau"];
            this.diaChiHKTT = data["diaChiHKTT"];
            this.tinhThanhIDHKTT = data["tinhThanhIDHKTT"];
            this.quocGiaHKTT = data["quocGiaHKTT"];
            this.facebook = data["facebook"];
            this.skype = data["skype"];
            this.noiSinh = data["noiSinh"];
            this.tinhThanhID = data["tinhThanhID"];
            this.nguyenQuan = data["nguyenQuan"];
            this.emailKhac = data["emailKhac"];
            this.emailCoQuan = data["emailCoQuan"];
            this.emailCaNhan = data["emailCaNhan"];
            this.dtKhac = data["dtKhac"];
            this.dtNhaRieng = data["dtNhaRieng"];
            this.dtCoQuan = data["dtCoQuan"];
            this.dtDiDong = data["dtDiDong"];
            this.tepDinhKem = data["tepDinhKem"];
            this.tinhTrangHonNhanCode = data["tinhTrangHonNhanCode"];
            this.xepLoaiCode = data["xepLoaiCode"];
            this.namTotNghiep = data["namTotNghiep"];
            this.chuyenNganh = data["chuyenNganh"];
            this.khoa = data["khoa"];
            this.trinhDoDaoTaoCode = data["trinhDoDaoTaoCode"];
            this.trinhDoVanHoa = data["trinhDoVanHoa"];
            this.ngayHetHan = data["ngayHetHan"] ? moment(data["ngayHetHan"].toString()) : <any>undefined;
            this.noiCap = data["noiCap"];
            this.ngayCap = data["ngayCap"] ? moment(data["ngayCap"].toString()) : <any>undefined;
            this.soCMND = data["soCMND"];
            this.quocTich = data["quocTich"];
            this.tonGiao = data["tonGiao"];
            this.danToc = data["danToc"];
            this.viTriCongViecCode = data["viTriCongViecCode"];
            this.donViCongTacID = data["donViCongTacID"];
            this.mstCaNhan = data["mstCaNhan"];
            this.ngaySinh = data["ngaySinh"] ? moment(data["ngaySinh"].toString()) : <any>undefined;
            this.gioiTinhCode = data["gioiTinhCode"];
            this.anhDaiDien = data["anhDaiDien"];
            this.hoVaTen = data["hoVaTen"];
            this.maNhanVien = data["maNhanVien"];
            this.chiNhanh = data["chiNhanh"];
            this.dvt = data["dvt"];
            this.ngayKyHDKTH = data["ngayKyHDKTH"] ? moment(data["ngayKyHDKTH"].toString()) : <any>undefined;
            this.ngayKyHD36TH = data["ngayKyHD36TH"] ? moment(data["ngayKyHD36TH"].toString()) : <any>undefined;
            this.ngayKyHD12TH = data["ngayKyHD12TH"] ? moment(data["ngayKyHD12TH"].toString()) : <any>undefined;
            this.ngayKyHDTV = data["ngayKyHDTV"] ? moment(data["ngayKyHDTV"].toString()) : <any>undefined;
            this.ngayKYHDCTV = data["ngayKYHDCTV"] ? moment(data["ngayKYHDCTV"].toString()) : <any>undefined;
            this.ngayKyHDKV = data["ngayKyHDKV"] ? moment(data["ngayKyHDKV"].toString()) : <any>undefined;
            this.ngayKYHDTT = data["ngayKYHDTT"] ? moment(data["ngayKYHDTT"].toString()) : <any>undefined;
            this.ngayKyHD = data["ngayKyHD"] ? moment(data["ngayKyHD"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditViTriCongViecDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditViTriCongViecDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenCty"] = this.tenCty;
        data["hopDongHienTai"] = this.hopDongHienTai;
        data["soHD"] = this.soHD;
        data["donViCongTacName"] = this.donViCongTacName;
        data["choNgoi"] = this.choNgoi;
        data["noiDaoTaoID"] = this.noiDaoTaoID;
        data["loaiHopDongID"] = this.loaiHopDongID;
        data["maSoNoiKCB"] = this.maSoNoiKCB;
        data["noiDangKyKCBID"] = this.noiDangKyKCBID;
        data["ngayHetHanBHYT"] = this.ngayHetHanBHYT ? this.ngayHetHanBHYT.toISOString() : <any>undefined;
        data["soTheBHYT"] = this.soTheBHYT;
        data["maTinhCap"] = this.maTinhCap;
        data["maSoBHXH"] = this.maSoBHXH;
        data["soSoBHXH"] = this.soSoBHXH;
        data["tyLeDongBH"] = this.tyLeDongBH;
        data["ngayThamGiaBH"] = this.ngayThamGiaBH ? this.ngayThamGiaBH.toISOString() : <any>undefined;
        data["thamGiaCongDoan"] = this.thamGiaCongDoan;
        data["nganHangCode"] = this.nganHangCode;
        data["tkNganHang"] = this.tkNganHang;
        data["donViSoCongChuanCode"] = this.donViSoCongChuanCode;
        data["soCongChuan"] = this.soCongChuan;
        data["luongDongBH"] = this.luongDongBH;
        data["luongCoBan"] = this.luongCoBan;
        data["bacLuongCode"] = this.bacLuongCode;
        data["soNgayPhep"] = this.soNgayPhep;
        data["ngayChinhThuc"] = this.ngayChinhThuc ? this.ngayChinhThuc.toISOString() : <any>undefined;
        data["ngayThuViec"] = this.ngayThuViec ? this.ngayThuViec.toISOString() : <any>undefined;
        data["ngayTapSu"] = this.ngayTapSu ? this.ngayTapSu.toISOString() : <any>undefined;
        data["soSoQLLaoDong"] = this.soSoQLLaoDong;
        data["diaDiemLamViecCode"] = this.diaDiemLamViecCode;
        data["quanLyGianTiep"] = this.quanLyGianTiep;
        data["quanLyTrucTiep"] = this.quanLyTrucTiep;
        data["trangThaiLamViecCode"] = this.trangThaiLamViecCode;
        data["bac"] = this.bac;
        data["cap"] = this.cap;
        data["chucDanh"] = this.chucDanh;
        data["maChamCong"] = this.maChamCong;
        data["diaChiLHKC"] = this.diaChiLHKC;
        data["emailLHKC"] = this.emailLHKC;
        data["dtDiDongLHKC"] = this.dtDiDongLHKC;
        data["dtNhaRiengLHKC"] = this.dtNhaRiengLHKC;
        data["quanHeLHKC"] = this.quanHeLHKC;
        data["hoVaTenLHKC"] = this.hoVaTenLHKC;
        data["diaChiHN"] = this.diaChiHN;
        data["tinhThanhIDHN"] = this.tinhThanhIDHN;
        data["quocGiaHN"] = this.quocGiaHN;
        data["laChuHo"] = this.laChuHo;
        data["maSoHoGiaDinh"] = this.maSoHoGiaDinh;
        data["soSoHoKhau"] = this.soSoHoKhau;
        data["diaChiHKTT"] = this.diaChiHKTT;
        data["tinhThanhIDHKTT"] = this.tinhThanhIDHKTT;
        data["quocGiaHKTT"] = this.quocGiaHKTT;
        data["facebook"] = this.facebook;
        data["skype"] = this.skype;
        data["noiSinh"] = this.noiSinh;
        data["tinhThanhID"] = this.tinhThanhID;
        data["nguyenQuan"] = this.nguyenQuan;
        data["emailKhac"] = this.emailKhac;
        data["emailCoQuan"] = this.emailCoQuan;
        data["emailCaNhan"] = this.emailCaNhan;
        data["dtKhac"] = this.dtKhac;
        data["dtNhaRieng"] = this.dtNhaRieng;
        data["dtCoQuan"] = this.dtCoQuan;
        data["dtDiDong"] = this.dtDiDong;
        data["tepDinhKem"] = this.tepDinhKem;
        data["tinhTrangHonNhanCode"] = this.tinhTrangHonNhanCode;
        data["xepLoaiCode"] = this.xepLoaiCode;
        data["namTotNghiep"] = this.namTotNghiep;
        data["chuyenNganh"] = this.chuyenNganh;
        data["khoa"] = this.khoa;
        data["trinhDoDaoTaoCode"] = this.trinhDoDaoTaoCode;
        data["trinhDoVanHoa"] = this.trinhDoVanHoa;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        data["noiCap"] = this.noiCap;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["soCMND"] = this.soCMND;
        data["quocTich"] = this.quocTich;
        data["tonGiao"] = this.tonGiao;
        data["danToc"] = this.danToc;
        data["viTriCongViecCode"] = this.viTriCongViecCode;
        data["donViCongTacID"] = this.donViCongTacID;
        data["mstCaNhan"] = this.mstCaNhan;
        data["ngaySinh"] = this.ngaySinh ? this.ngaySinh.toISOString() : <any>undefined;
        data["gioiTinhCode"] = this.gioiTinhCode;
        data["anhDaiDien"] = this.anhDaiDien;
        data["hoVaTen"] = this.hoVaTen;
        data["maNhanVien"] = this.maNhanVien;
        data["chiNhanh"] = this.chiNhanh;
        data["dvt"] = this.dvt;
        data["ngayKyHDKTH"] = this.ngayKyHDKTH ? this.ngayKyHDKTH.toISOString() : <any>undefined;
        data["ngayKyHD36TH"] = this.ngayKyHD36TH ? this.ngayKyHD36TH.toISOString() : <any>undefined;
        data["ngayKyHD12TH"] = this.ngayKyHD12TH ? this.ngayKyHD12TH.toISOString() : <any>undefined;
        data["ngayKyHDTV"] = this.ngayKyHDTV ? this.ngayKyHDTV.toISOString() : <any>undefined;
        data["ngayKYHDCTV"] = this.ngayKYHDCTV ? this.ngayKYHDCTV.toISOString() : <any>undefined;
        data["ngayKyHDKV"] = this.ngayKyHDKV ? this.ngayKyHDKV.toISOString() : <any>undefined;
        data["ngayKYHDTT"] = this.ngayKYHDTT ? this.ngayKYHDTT.toISOString() : <any>undefined;
        data["ngayKyHD"] = this.ngayKyHD ? this.ngayKyHD.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditViTriCongViecDto {
        const json = this.toJSON();
        let result = new CreateOrEditViTriCongViecDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditViTriCongViecDto {
    tenCty: string | undefined;
    hopDongHienTai: string | undefined;
    soHD: string | undefined;
    donViCongTacName: string | undefined;
    choNgoi: string | undefined;
    noiDaoTaoID: number;
    loaiHopDongID: number;
    maSoNoiKCB: string | undefined;
    noiDangKyKCBID: number;
    ngayHetHanBHYT: moment.Moment;
    soTheBHYT: string | undefined;
    maTinhCap: string | undefined;
    maSoBHXH: string | undefined;
    soSoBHXH: string | undefined;
    tyLeDongBH: number;
    ngayThamGiaBH: moment.Moment;
    thamGiaCongDoan: boolean;
    nganHangCode: string | undefined;
    tkNganHang: string | undefined;
    donViSoCongChuanCode: string | undefined;
    soCongChuan: string | undefined;
    luongDongBH: string | undefined;
    luongCoBan: string | undefined;
    bacLuongCode: string | undefined;
    soNgayPhep: number;
    ngayChinhThuc: moment.Moment;
    ngayThuViec: moment.Moment;
    ngayTapSu: moment.Moment;
    soSoQLLaoDong: string | undefined;
    diaDiemLamViecCode: string | undefined;
    quanLyGianTiep: string | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiLamViecCode: string | undefined;
    bac: string | undefined;
    cap: string | undefined;
    chucDanh: string | undefined;
    maChamCong: string | undefined;
    diaChiLHKC: string | undefined;
    emailLHKC: string | undefined;
    dtDiDongLHKC: string | undefined;
    dtNhaRiengLHKC: string | undefined;
    quanHeLHKC: string | undefined;
    hoVaTenLHKC: string | undefined;
    diaChiHN: string | undefined;
    tinhThanhIDHN: number | undefined;
    quocGiaHN: string | undefined;
    laChuHo: boolean;
    maSoHoGiaDinh: string | undefined;
    soSoHoKhau: string | undefined;
    diaChiHKTT: string | undefined;
    tinhThanhIDHKTT: number | undefined;
    quocGiaHKTT: string | undefined;
    facebook: string | undefined;
    skype: string | undefined;
    noiSinh: string | undefined;
    tinhThanhID: number | undefined;
    nguyenQuan: string | undefined;
    emailKhac: string | undefined;
    emailCoQuan: string | undefined;
    emailCaNhan: string | undefined;
    dtKhac: string | undefined;
    dtNhaRieng: string | undefined;
    dtCoQuan: string | undefined;
    dtDiDong: string | undefined;
    tepDinhKem: string | undefined;
    tinhTrangHonNhanCode: string | undefined;
    xepLoaiCode: string | undefined;
    namTotNghiep: number;
    chuyenNganh: string | undefined;
    khoa: string | undefined;
    trinhDoDaoTaoCode: string | undefined;
    trinhDoVanHoa: string | undefined;
    ngayHetHan: moment.Moment;
    noiCap: string | undefined;
    ngayCap: moment.Moment;
    soCMND: string | undefined;
    quocTich: string | undefined;
    tonGiao: string | undefined;
    danToc: string | undefined;
    viTriCongViecCode: string | undefined;
    donViCongTacID: number | undefined;
    mstCaNhan: string | undefined;
    ngaySinh: moment.Moment;
    gioiTinhCode: string | undefined;
    anhDaiDien: string | undefined;
    hoVaTen: string | undefined;
    maNhanVien: string | undefined;
    chiNhanh: string | undefined;
    dvt: string | undefined;
    ngayKyHDKTH: moment.Moment;
    ngayKyHD36TH: moment.Moment;
    ngayKyHD12TH: moment.Moment;
    ngayKyHDTV: moment.Moment;
    ngayKYHDCTV: moment.Moment;
    ngayKyHDKV: moment.Moment;
    ngayKYHDTT: moment.Moment;
    ngayKyHD: moment.Moment;
    id: number | undefined;
}

export class GetViTriCongViecForEditOutput implements IGetViTriCongViecForEditOutput {
    viTriCongViec: CreateOrEditViTriCongViecDto;

    constructor(data?: IGetViTriCongViecForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.viTriCongViec = new CreateOrEditViTriCongViecDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.viTriCongViec = data["viTriCongViec"] ? CreateOrEditViTriCongViecDto.fromJS(data["viTriCongViec"]) : new CreateOrEditViTriCongViecDto();
        }
    }

    static fromJS(data: any): GetViTriCongViecForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetViTriCongViecForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viTriCongViec"] = this.viTriCongViec ? this.viTriCongViec.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetViTriCongViecForEditOutput {
        const json = this.toJSON();
        let result = new GetViTriCongViecForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetViTriCongViecForEditOutput {
    viTriCongViec: CreateOrEditViTriCongViecDto;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [];
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }

    clone(): GetLatestWebLogsOutput {
        const json = this.toJSON();
        let result = new GetLatestWebLogsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class WordProcessingDto implements IWordProcessingDto {
    receivePlace: string | undefined;
    name: string | undefined;
    content: string | undefined;
    status: string | undefined;
    comment: string | undefined;
    keyWordId: number;
    id: number;

    constructor(data?: IWordProcessingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receivePlace = data["receivePlace"];
            this.name = data["name"];
            this.content = data["content"];
            this.status = data["status"];
            this.comment = data["comment"];
            this.keyWordId = data["keyWordId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WordProcessingDto {
        data = typeof data === 'object' ? data : {};
        let result = new WordProcessingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receivePlace"] = this.receivePlace;
        data["name"] = this.name;
        data["content"] = this.content;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["keyWordId"] = this.keyWordId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WordProcessingDto {
        const json = this.toJSON();
        let result = new WordProcessingDto();
        result.init(json);
        return result;
    }
}

export interface IWordProcessingDto {
    receivePlace: string | undefined;
    name: string | undefined;
    content: string | undefined;
    status: string | undefined;
    comment: string | undefined;
    keyWordId: number;
    id: number;
}

export class GetWordProcessingForViewDto implements IGetWordProcessingForViewDto {
    wordProcessing: WordProcessingDto;

    constructor(data?: IGetWordProcessingForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.wordProcessing = new WordProcessingDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.wordProcessing = data["wordProcessing"] ? WordProcessingDto.fromJS(data["wordProcessing"]) : new WordProcessingDto();
        }
    }

    static fromJS(data: any): GetWordProcessingForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWordProcessingForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wordProcessing"] = this.wordProcessing ? this.wordProcessing.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetWordProcessingForViewDto {
        const json = this.toJSON();
        let result = new GetWordProcessingForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetWordProcessingForViewDto {
    wordProcessing: WordProcessingDto;
}

export class PagedResultDtoOfGetWordProcessingForViewDto implements IPagedResultDtoOfGetWordProcessingForViewDto {
    totalCount: number;
    items: GetWordProcessingForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWordProcessingForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetWordProcessingForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWordProcessingForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWordProcessingForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetWordProcessingForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetWordProcessingForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetWordProcessingForViewDto {
    totalCount: number;
    items: GetWordProcessingForViewDto[] | undefined;
}

export class CreateOrEditWordProcessingDto implements ICreateOrEditWordProcessingDto {
    receivePlace: string | undefined;
    name: string | undefined;
    content: string | undefined;
    status: string | undefined;
    comment: string | undefined;
    keyWordId: number;
    id: number | undefined;

    constructor(data?: ICreateOrEditWordProcessingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receivePlace = data["receivePlace"];
            this.name = data["name"];
            this.content = data["content"];
            this.status = data["status"];
            this.comment = data["comment"];
            this.keyWordId = data["keyWordId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWordProcessingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWordProcessingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receivePlace"] = this.receivePlace;
        data["name"] = this.name;
        data["content"] = this.content;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["keyWordId"] = this.keyWordId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditWordProcessingDto {
        const json = this.toJSON();
        let result = new CreateOrEditWordProcessingDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditWordProcessingDto {
    receivePlace: string | undefined;
    name: string | undefined;
    content: string | undefined;
    status: string | undefined;
    comment: string | undefined;
    keyWordId: number;
    id: number | undefined;
}

export class GetWordProcessingForEditOutput implements IGetWordProcessingForEditOutput {
    wordProcessing: CreateOrEditWordProcessingDto;

    constructor(data?: IGetWordProcessingForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.wordProcessing = new CreateOrEditWordProcessingDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.wordProcessing = data["wordProcessing"] ? CreateOrEditWordProcessingDto.fromJS(data["wordProcessing"]) : new CreateOrEditWordProcessingDto();
        }
    }

    static fromJS(data: any): GetWordProcessingForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWordProcessingForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wordProcessing"] = this.wordProcessing ? this.wordProcessing.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetWordProcessingForEditOutput {
        const json = this.toJSON();
        let result = new GetWordProcessingForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWordProcessingForEditOutput {
    wordProcessing: CreateOrEditWordProcessingDto;
}

export class WorkAssignDto implements IWorkAssignDto {
    name: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    assignee: string | undefined;
    progress: number;
    status: string | undefined;
    description: string | undefined;
    action: string | undefined;
    id: number;

    constructor(data?: IWorkAssignDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.assignee = data["assignee"];
            this.progress = data["progress"];
            this.status = data["status"];
            this.description = data["description"];
            this.action = data["action"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkAssignDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkAssignDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["assignee"] = this.assignee;
        data["progress"] = this.progress;
        data["status"] = this.status;
        data["description"] = this.description;
        data["action"] = this.action;
        data["id"] = this.id;
        return data; 
    }

    clone(): WorkAssignDto {
        const json = this.toJSON();
        let result = new WorkAssignDto();
        result.init(json);
        return result;
    }
}

export interface IWorkAssignDto {
    name: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    assignee: string | undefined;
    progress: number;
    status: string | undefined;
    description: string | undefined;
    action: string | undefined;
    id: number;
}

export class GetWorkAssignForViewDto implements IGetWorkAssignForViewDto {
    workAssign: WorkAssignDto;

    constructor(data?: IGetWorkAssignForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.workAssign = new WorkAssignDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.workAssign = data["workAssign"] ? WorkAssignDto.fromJS(data["workAssign"]) : new WorkAssignDto();
        }
    }

    static fromJS(data: any): GetWorkAssignForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkAssignForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workAssign"] = this.workAssign ? this.workAssign.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetWorkAssignForViewDto {
        const json = this.toJSON();
        let result = new GetWorkAssignForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetWorkAssignForViewDto {
    workAssign: WorkAssignDto;
}

export class PagedResultDtoOfGetWorkAssignForViewDto implements IPagedResultDtoOfGetWorkAssignForViewDto {
    totalCount: number;
    items: GetWorkAssignForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWorkAssignForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetWorkAssignForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWorkAssignForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWorkAssignForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetWorkAssignForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetWorkAssignForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetWorkAssignForViewDto {
    totalCount: number;
    items: GetWorkAssignForViewDto[] | undefined;
}

export class CreateOrEditWorkAssignDto implements ICreateOrEditWorkAssignDto {
    name: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    assignee: string | undefined;
    progress: number;
    status: string | undefined;
    description: string | undefined;
    action: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditWorkAssignDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.assignee = data["assignee"];
            this.progress = data["progress"];
            this.status = data["status"];
            this.description = data["description"];
            this.action = data["action"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWorkAssignDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWorkAssignDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["assignee"] = this.assignee;
        data["progress"] = this.progress;
        data["status"] = this.status;
        data["description"] = this.description;
        data["action"] = this.action;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditWorkAssignDto {
        const json = this.toJSON();
        let result = new CreateOrEditWorkAssignDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditWorkAssignDto {
    name: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    assignee: string | undefined;
    progress: number;
    status: string | undefined;
    description: string | undefined;
    action: string | undefined;
    id: number | undefined;
}

export class GetWorkAssignForEditOutput implements IGetWorkAssignForEditOutput {
    workAssign: CreateOrEditWorkAssignDto;

    constructor(data?: IGetWorkAssignForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.workAssign = new CreateOrEditWorkAssignDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.workAssign = data["workAssign"] ? CreateOrEditWorkAssignDto.fromJS(data["workAssign"]) : new CreateOrEditWorkAssignDto();
        }
    }

    static fromJS(data: any): GetWorkAssignForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkAssignForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workAssign"] = this.workAssign ? this.workAssign.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetWorkAssignForEditOutput {
        const json = this.toJSON();
        let result = new GetWorkAssignForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWorkAssignForEditOutput {
    workAssign: CreateOrEditWorkAssignDto;
}

export class WorkDetailDto implements IWorkDetailDto {
    workAssignId: number;
    donePersentage: number;
    date: moment.Moment;
    nameID: string | undefined;
    description: string | undefined;
    repply: string | undefined;
    attachment: string | undefined;
    id: number;

    constructor(data?: IWorkDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workAssignId = data["workAssignId"];
            this.donePersentage = data["donePersentage"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.nameID = data["nameID"];
            this.description = data["description"];
            this.repply = data["repply"];
            this.attachment = data["attachment"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workAssignId"] = this.workAssignId;
        data["donePersentage"] = this.donePersentage;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["nameID"] = this.nameID;
        data["description"] = this.description;
        data["repply"] = this.repply;
        data["attachment"] = this.attachment;
        data["id"] = this.id;
        return data; 
    }

    clone(): WorkDetailDto {
        const json = this.toJSON();
        let result = new WorkDetailDto();
        result.init(json);
        return result;
    }
}

export interface IWorkDetailDto {
    workAssignId: number;
    donePersentage: number;
    date: moment.Moment;
    nameID: string | undefined;
    description: string | undefined;
    repply: string | undefined;
    attachment: string | undefined;
    id: number;
}

export class GetWorkDetailForViewDto implements IGetWorkDetailForViewDto {
    workDetail: WorkDetailDto;

    constructor(data?: IGetWorkDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.workDetail = new WorkDetailDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.workDetail = data["workDetail"] ? WorkDetailDto.fromJS(data["workDetail"]) : new WorkDetailDto();
        }
    }

    static fromJS(data: any): GetWorkDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workDetail"] = this.workDetail ? this.workDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetWorkDetailForViewDto {
        const json = this.toJSON();
        let result = new GetWorkDetailForViewDto();
        result.init(json);
        return result;
    }
}

export interface IGetWorkDetailForViewDto {
    workDetail: WorkDetailDto;
}

export class PagedResultDtoOfGetWorkDetailForViewDto implements IPagedResultDtoOfGetWorkDetailForViewDto {
    totalCount: number;
    items: GetWorkDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWorkDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetWorkDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWorkDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWorkDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetWorkDetailForViewDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetWorkDetailForViewDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetWorkDetailForViewDto {
    totalCount: number;
    items: GetWorkDetailForViewDto[] | undefined;
}

export class CreateOrEditWorkDetailDto implements ICreateOrEditWorkDetailDto {
    workAssignId: number;
    donePersentage: number;
    date: moment.Moment;
    nameID: string | undefined;
    description: string | undefined;
    repply: string | undefined;
    attachment: string | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditWorkDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workAssignId = data["workAssignId"];
            this.donePersentage = data["donePersentage"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.nameID = data["nameID"];
            this.description = data["description"];
            this.repply = data["repply"];
            this.attachment = data["attachment"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWorkDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWorkDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workAssignId"] = this.workAssignId;
        data["donePersentage"] = this.donePersentage;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["nameID"] = this.nameID;
        data["description"] = this.description;
        data["repply"] = this.repply;
        data["attachment"] = this.attachment;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrEditWorkDetailDto {
        const json = this.toJSON();
        let result = new CreateOrEditWorkDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditWorkDetailDto {
    workAssignId: number;
    donePersentage: number;
    date: moment.Moment;
    nameID: string | undefined;
    description: string | undefined;
    repply: string | undefined;
    attachment: string | undefined;
    id: number | undefined;
}

export class GetWorkDetailForEditOutput implements IGetWorkDetailForEditOutput {
    workDetail: CreateOrEditWorkDetailDto;

    constructor(data?: IGetWorkDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.workDetail = new CreateOrEditWorkDetailDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.workDetail = data["workDetail"] ? CreateOrEditWorkDetailDto.fromJS(data["workDetail"]) : new CreateOrEditWorkDetailDto();
        }
    }

    static fromJS(data: any): GetWorkDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workDetail"] = this.workDetail ? this.workDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetWorkDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetWorkDetailForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWorkDetailForEditOutput {
    workDetail: CreateOrEditWorkDetailDto;
}

export class Body implements IBody {
    file: string;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.file = data["file"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        return data; 
    }

    clone(): Body {
        const json = this.toJSON();
        let result = new Body();
        result.init(json);
        return result;
    }
}

export interface IBody {
    file: string;
}

export class Data implements IData {

    constructor(data?: IData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Data {
        data = typeof data === 'object' ? data : {};
        let result = new Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Data {
        const json = this.toJSON();
        let result = new Data();
        result.init(json);
        return result;
    }
}

export interface IData {
}

export class ListDocumentHanding implements IListDocumentHanding {

    constructor(data?: IListDocumentHanding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): ListDocumentHanding {
        data = typeof data === 'object' ? data : {};
        let result = new ListDocumentHanding();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): ListDocumentHanding {
        const json = this.toJSON();
        let result = new ListDocumentHanding();
        result.init(json);
        return result;
    }
}

export interface IListDocumentHanding {
}

export class Anonymous implements IAnonymous {

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous {
        const json = this.toJSON();
        let result = new Anonymous();
        result.init(json);
        return result;
    }
}

export interface IAnonymous {
}

export class Anonymous2 implements IAnonymous2 {

    constructor(data?: IAnonymous2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Anonymous2 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous2 {
        const json = this.toJSON();
        let result = new Anonymous2();
        result.init(json);
        return result;
    }
}

export interface IAnonymous2 {
}

export class ListHistoryUploads implements IListHistoryUploads {

    constructor(data?: IListHistoryUploads) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): ListHistoryUploads {
        data = typeof data === 'object' ? data : {};
        let result = new ListHistoryUploads();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): ListHistoryUploads {
        const json = this.toJSON();
        let result = new ListHistoryUploads();
        result.init(json);
        return result;
    }
}

export interface IListHistoryUploads {
}

export class ListVanBan implements IListVanBan {

    constructor(data?: IListVanBan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): ListVanBan {
        data = typeof data === 'object' ? data : {};
        let result = new ListVanBan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): ListVanBan {
        const json = this.toJSON();
        let result = new ListVanBan();
        result.init(json);
        return result;
    }
}

export interface IListVanBan {
}

export class ListMemorize implements IListMemorize {

    constructor(data?: IListMemorize) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): ListMemorize {
        data = typeof data === 'object' ? data : {};
        let result = new ListMemorize();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): ListMemorize {
        const json = this.toJSON();
        let result = new ListMemorize();
        result.init(json);
        return result;
    }
}

export interface IListMemorize {
}

export class Anonymous3 implements IAnonymous3 {

    constructor(data?: IAnonymous3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Anonymous3 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous3 {
        const json = this.toJSON();
        let result = new Anonymous3();
        result.init(json);
        return result;
    }
}

export interface IAnonymous3 {
}

export class EntityId implements IEntityId {

    constructor(data?: IEntityId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): EntityId {
        data = typeof data === 'object' ? data : {};
        let result = new EntityId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): EntityId {
        const json = this.toJSON();
        let result = new EntityId();
        result.init(json);
        return result;
    }
}

export interface IEntityId {
}

export class AdditionalData implements IAdditionalData {
    paypal: { [key: string] : string; };
    stripe: { [key: string] : string; };

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.paypal = {};
            this.stripe = {};
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {};
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal[key] = data["Paypal"][key];
                }
            }
            if (data["Stripe"]) {
                this.stripe = {};
                for (let key in data["Stripe"]) {
                    if (data["Stripe"].hasOwnProperty(key))
                        this.stripe[key] = data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    data["Stripe"][key] = this.stripe[key];
            }
        }
        return data; 
    }

    clone(): AdditionalData {
        const json = this.toJSON();
        let result = new AdditionalData();
        result.init(json);
        return result;
    }
}

export interface IAdditionalData {
    paypal: { [key: string] : string; };
    stripe: { [key: string] : string; };
}

export class Data2 implements IData2 {

    constructor(data?: IData2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Data2 {
        data = typeof data === 'object' ? data : {};
        let result = new Data2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Data2 {
        const json = this.toJSON();
        let result = new Data2();
        result.init(json);
        return result;
    }
}

export interface IData2 {
}

export class Anonymous4 implements IAnonymous4 {

    constructor(data?: IAnonymous4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Anonymous4 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous4 {
        const json = this.toJSON();
        let result = new Anonymous4();
        result.init(json);
        return result;
    }
}

export interface IAnonymous4 {
}

export class ListTextBook implements IListTextBook {

    constructor(data?: IListTextBook) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): ListTextBook {
        data = typeof data === 'object' ? data : {};
        let result = new ListTextBook();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): ListTextBook {
        const json = this.toJSON();
        let result = new ListTextBook();
        result.init(json);
        return result;
    }
}

export interface IListTextBook {
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}